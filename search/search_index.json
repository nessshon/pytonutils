{"config":{"lang":["en","ru"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Tonutils is a high-level, object-oriented Python library designed to simplify interaction with the TON blockchain. It integrates several major services and tools, including:</p> <p>RPC APIs</p> <ul> <li>tonapi.io \u2014 REST API for accessing TON blockchain data.</li> <li>toncenter.com \u2014 fast and reliable HTTP API for The Open Network.</li> <li>quicknode.com \u2014 low-latency global infrastructure for HTTP access to TON.</li> <li>tatum.io \u2014 RPCs and APIs for Web3 projects: fast, reliable, affordable.</li> </ul> <p>Native ADNL</p> <ul> <li>pytoniq \u2014 library for direct interaction with TON Lite servers.</li> </ul> <p>Tonutils combines these capabilities into a powerful and flexible toolkit for developers, making it easier to build applications on top of the TON ecosystem.</p> <p>Note</p> <p>To reliably retrieve blockchain data \u2014 such as transaction lists, NFT lists, counts, and similar details \u2014 it is strongly recommended to use indexer APIs like Toncenter, Tonapi, and similar services. For working specifically with Tonapi, you can also use my Python library pytonapi.</p>"},{"location":"#contribution","title":"Contribution","text":"<p>Your contribution is welcome! If you have ideas for improvements or have identified a bug, please create an issue or submit a pull request on GitHub.</p> <p>Note</p> <p>The documentation is currently under development. Sections and materials are continuously being updated and expanded. Some parts may contain inaccuracies or incomplete details; please use with caution.</p>"},{"location":"donate/","title":"Donate","text":"<p>Thank you for considering supporting my work! Your contributions help me continue developing and improving this project. \u2764\ufe0f</p>"},{"location":"donate/#direct-wallet-donations","title":"Direct Wallet Donations","text":"<p>You can send donations directly to the following addresses:</p> <ul> <li> <p>TON <code>UQCZq3_Vd21-4y4m7Wc-ej9NFOhh_qvdfAkAYAOHoQ__Ness</code></p> </li> <li> <p>BTC <code>1FKJDBSxdtsMad84iYY96zLJBVEChehbx1</code></p> </li> <li> <p>USDT (TRC-20) <code>TGKmm9H3FApFw8xcgRcZDHSku68vozAjo9</code></p> </li> </ul>"},{"location":"donate/#donate-via-bots","title":"Donate via Bots","text":"<p>You can also donate conveniently using these bots:</p> <ul> <li> <p>Crypto Bot Donate through Crypto Bot</p> </li> <li> <p>xRocket Bot Donate through xRocket</p> </li> </ul>"},{"location":"sponsors/","title":"Sponsors","text":"<p>I sincerely thank everyone who supports this project. \u2764\ufe0f</p>"},{"location":"sponsors/#supported-by","title":"Supported by","text":"<ul> <li> <p>TON Society   Through the Grants and Bounties program.</p> </li> <li> <p>TONAPI   Providing essential infrastructure and API services.</p> </li> </ul>"},{"location":"sponsors/#special-thanks","title":"Special Thanks","text":"<ul> <li>Igroman787 </li> <li>Roman Inozemtsev </li> <li>Cron </li> </ul>"},{"location":"sponsors/#supporters","title":"Supporters","text":"<p>Thank you to everyone who has supported this project at any time!</p> <ul> <li><code>svatoshscammer.ton</code></li> <li><code>vtonsdk.t.me</code></li> </ul>"},{"location":"sponsors/#want-to-support","title":"Want to Support?","text":"<p>If you want to support my work, go to the Donate page! Your support helps the project grow and improve.</p>"},{"location":"cookbook/cnft/","title":"Creating Compressed NFTs","text":""},{"location":"cookbook/cnft/#introduction","title":"Introduction","text":"<p>This guide introduces the concept of Compressed NFTs (cNFTs) on the TON blockchain \u2014 a specialized asset format that optimizes data storage using compression algorithms and Merkle trees. It explains how cNFTs reduce storage and transmission costs while maintaining uniqueness and verifiability, and provides practical steps for deploying and managing efficient, large-scale NFT collections.</p>"},{"location":"cookbook/cnft/#features","title":"Features","text":"<ul> <li>Resource savings: Merkle trees store only essential data, reducing gas costs and network load.</li> <li>Improved scalability: Efficient contracts can handle large NFT volumes without performance loss.</li> <li>Optimized data storage: Keeping minimal on-chain information boosts system responsiveness and saves space.</li> <li>Enhanced security: Merkle trees enable fast data integrity checks and robust asset protection.</li> <li>Cost reduction: Shift minting costs to end users and create \u201cvirtual\u201d on-chain items only when needed.</li> </ul>"},{"location":"cookbook/cnft/#support","title":"Support","text":"<p>Current limitations Most popular wallets and marketplaces do not display unclaimed cNFTs or NFTs from collections that are not official partners. For example, the Telegram wallet and the Getgems marketplace index only the first 200 items for unofficial collections, which poses challenges for larger collections.</p> <p>Attack scenario A malicious actor could create hundreds of thousands of NFTs at minimal cost, forcing marketplaces to store all related data\u2014even if the attacker does not host the items but generates them on demand.</p> <p>Potential solution Provide a dedicated interface where users can claim their cNFTs. Once claimed, NFTs are indexed and displayed in wallets and marketplaces as standard NFTs, ensuring better visibility and accessibility.</p>"},{"location":"cookbook/cnft/#setup-deployment","title":"Setup &amp; Deployment","text":""},{"location":"cookbook/cnft/#nft-preparation","title":"NFT preparation","text":"<p>Before deployment, you need to prepare the metadata and images for your NFTs.</p>"},{"location":"cookbook/cnft/#metadata-preparation","title":"Metadata preparation","text":"<ul> <li> <p>Collection metadata   Create a <code>collection.json</code> file that includes the required fields as specified in the NFT token data standard. Example:</p> <pre><code>{\n    \"name\": \"&lt;collection name&gt;\",\n    \"description\": \"&lt;collection description&gt;\",\n    \"image\": \"&lt;link to the image (e.g. https://yourdomain.com/logo.png)&gt;\"\n}\n</code></pre> </li> <li> <p>NFT item metadata   For each NFT, create a separate JSON file (e.g., <code>0.json</code>, <code>1.json</code>, etc.) with the required fields as specified in the NFT token data standard. Example:</p> <pre><code>{\n    \"name\": \"&lt;item name&gt;\",\n    \"description\": \"&lt;item description&gt;\",\n    \"image\": \"&lt;link to the image (e.g. https://yourdomain.com/0.png)&gt;\"\n}\n</code></pre> </li> </ul>"},{"location":"cookbook/cnft/#resource-preparation","title":"Resource preparation","text":"<ul> <li>Images: Prepare images for the collection (for example, <code>logo.png</code> for the avatar) and for each NFT (for example, <code>0.png</code>, <code>1.png</code>, etc.).</li> <li>JSON files: Host your <code>collection.json</code> and NFT JSON files on a publicly accessible server or repository. Ensure each file has a unique URL.</li> </ul> <p>Note</p> <p>All images and JSON files must be directly accessible via their URLs.</p>"},{"location":"cookbook/cnft/#tc-manifest-preparation","title":"TC Manifest preparation","text":"<p>Create a TON Connect manifest JSON file to describe your application during the wallet connection process. Example:</p> <pre><code>{\n  \"url\": \"&lt;app url&gt;\",\n  \"name\": \"&lt;app name&gt;\",\n  \"iconUrl\": \"&lt;app icon url&gt;\"\n}\n</code></pre> <p>Note</p> <p>Ensure that this file is publicly accessible via its URL.</p>"},{"location":"cookbook/cnft/#owner-list-preparation","title":"Owner List preparation","text":"<p>Prepare an <code>owners.txt</code> file that lists the addresses of NFT owners, one per line. The first address corresponds to item index <code>0</code>, the second to item index <code>1</code>, and so on. Example:</p> <pre><code>UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K\nUQCDrgGaI6gWK-qlyw69xWZosurGxrpRgIgSkVsgahUtxZR0\n</code></pre>"},{"location":"cookbook/cnft/#infrastructure-preparation","title":"Infrastructure preparation","text":"<p>Set up a server to host your API and the interface for claiming NFTs. Also, obtain a domain for accessing the API. In this example, a local test deployment is run on a home machine using ngrok to create a public URL.</p>"},{"location":"cookbook/cnft/#claiming-api-setup","title":"Claiming API Setup","text":"<ol> <li> <p>Clone the repository    Clone the project containing all necessary source files:</p> <pre><code>git clone https://github.com/nessshon/cnft-toolbox \n</code></pre> </li> <li> <p>Install dependencies    Install Docker, Docker Compose, and ngrok, and ensure they are properly configured on your machine.</p> </li> <li> <p>Create a Telegram bot    Create a Telegram bot and obtain its API token.</p> </li> <li> <p>Expose your API    Use ngrok to create a public URL for testing:</p> <pre><code>ngrok http 8080 \n</code></pre> <p>For production: Set up a custom domain and configure Nginx to proxy requests to your API on port 8080. This involves:</p> <ul> <li>Registering a domain and pointing it to your server.</li> <li>Configuring Nginx to proxy requests to your API on port 8080.</li> </ul> </li> <li> <p>Create a <code>.env</code> file    Duplicate the <code>env.example</code> file to <code>.env</code> and update it with your specific configuration. The table below describes each key:</p> Key Description Example Notes <code>PORT</code> Port on which the API will run. <code>8080</code> <code>ADMIN_USERNAME</code> Admin username for accessing restricted functionalities. <code>admin</code> <code>ADMIN_PASSWORD</code> Admin password for accessing restricted functionalities. <code>password</code> <code>DEPTH</code> Depth for the NFT collection (max items = <code>2^DEPTH</code>; maximum <code>DEPTH</code> is 30). <code>20</code> <code>IS_TESTNET</code> Specify if you are connecting to the TON testnet (<code>true</code>) or mainnet (<code>false</code>). <code>true</code> or <code>false</code> <code>POSTGRES_PASSWORD</code> Password for PostgreSQL authentication. <code>secret</code> <code>POSTGRES_DB</code> Name of the PostgreSQL database. <code>merkleapi</code> <code>POSTGRES_URI</code> Full connection URI for PostgreSQL. <code>postgresql://postgres:secret@db:5432/merkleapi</code> <code>BOT_TOKEN</code> Token for your Telegram bot (from @BotFather). <code>123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11</code> Used for the NFT claiming interface. <code>API_BASE_URL</code> External domain of your API. <code>https://example.ngrok.io</code> Replace with your public URL (e.g., via ngrok). <code>TONCONNECT_MANIFEST_URL</code> URL for the TON Connect manifest file. <code>https://example.com/tonconnect-manifest.json</code> Replace with the public URL of your manifest file. <code>COLLECTION_ADDRESS</code> Address of the NFT collection. Fill this in after deploying the collection. </li> <li> <p>Start the API and database    Run the following command to start the API and database:</p> <pre><code>docker-compose up -d db api \n</code></pre> </li> <li> <p>Migrate the database    Create the required tables in the database:</p> <pre><code>docker-compose exec api /ctl migrate \n</code></pre> </li> <li> <p>Add owners    Place your <code>owners.txt</code> file (containing owner addresses) into the <code>api</code> folder, then run:</p> <pre><code>docker-compose exec api /ctl add /api/owners.txt \n</code></pre> </li> <li> <p>Rediscover items    In your browser, navigate to <code>&lt;API_URI&gt;/admin/rediscover</code> and log in using your <code>ADMIN_USERNAME</code> and <code>ADMIN_PASSWORD</code>. If successful, you will see <code>ok</code> in the browser. After a short time (depending on the number of items), a file (e.g., <code>1.json</code>) appears in the <code>api/apidata/upd</code> folder.</p> </li> <li> <p>Generate an update     Run the following command to generate an update:</p> <pre><code>docker-compose exec api /ctl genupd &lt;path-to-update-file&gt; &lt;collection-owner&gt; &lt;collection-meta&gt; &lt;item-meta-prefix&gt; &lt;royalty-base&gt; &lt;royalty-factor&gt; &lt;royalty-recipient&gt; &lt;api-uri-including-v1&gt; \n</code></pre> <p>Replace the placeholders as follows:</p> <ul> <li><code>&lt;path-to-update-file&gt;</code>: Path to the update file created in step 9 (e.g., <code>api/apidata/upd/1.json</code>).</li> <li><code>&lt;collection-owner&gt;</code>: Address of the NFT collection owner.</li> <li><code>&lt;collection-meta&gt;</code>: Full URL to the collection metadata file (e.g., <code>https://yourdomain.com/collection.json</code>).</li> <li><code>&lt;item-meta-prefix&gt;</code>: Common prefix for item metadata (for example, if item 0 has metadata at <code>https://yourdomain.com/0.json</code>, use <code>https://yourdomain.com/</code>).</li> <li><code>&lt;royalty-base&gt;</code>: Numerator for royalties (for example, <code>10</code> for 10% if royalty-factor is 100).</li> <li><code>&lt;royalty-factor&gt;</code>: Denominator for royalties (for example, <code>100</code>).</li> <li><code>&lt;royalty-recipient&gt;</code>: Address receiving royalties (this can be the same as <code>&lt;collection-owner&gt;</code>).</li> <li><code>&lt;api-uri-including-v1&gt;</code>: Public API URL with the <code>/v1</code> postfix (for example, if you used <code>https://yourapi.com/admin/rediscover</code> to generate the update file, use <code>https://yourapi.com/v1</code> here).</li> </ul> </li> <li> <p>Invoke the <code>ton://</code> deeplink     After generating the update, a <code>ton://</code> link appears in the console logs. Follow the link and confirm the transaction. For convenience, you can paste the link into a QR code generator and scan the QR code with the Tonhub wallet (on testnet or mainnet).</p> </li> <li> <p>Set the collection address     In your browser, navigate to <code>&lt;API_URI&gt;/admin/setaddr/&lt;collection-address&gt;</code>, replacing <code>&lt;collection-address&gt;</code> with the address observed during the deployment step.</p> </li> <li> <p>Wait for confirmation     Monitor the container API logs until you see a message indicating a <code>committed state</code>.</p> <pre><code>docker-compose logs api \n</code></pre> </li> <li> <p>Deployment complete!</p> </li> </ol>"},{"location":"cookbook/cnft/#run-claiming-bot","title":"Run Claiming Bot","text":"<ol> <li> <p>Update the <code>.env</code> file    Add the <code>COLLECTION_ADDRESS</code> obtained during deployment to your <code>.env</code> file.</p> </li> <li> <p>Start the Telegram bot    Run the following command to start the bot:</p> <pre><code>docker-compose up -d redis bot \n</code></pre> </li> <li> <p>Interact with the bot    Open Telegram, navigate to your bot, and follow its instructions to claim NFTs.</p> </li> <li> <p>Done!</p> </li> </ol>"},{"location":"cookbook/cnft/#updating-owners","title":"Updating owners","text":"<p>Follow these steps to update the list of owners and integrate the changes into your NFT collection:</p> <ol> <li> <p>Prepare the new owners file    Create a <code>new-owners.txt</code> file with the new owner addresses and place it in the <code>api</code> folder.</p> </li> <li> <p>Add new owners    Run:</p> <pre><code>docker-compose exec api /ctl add /api/new-owners.txt \n</code></pre> </li> <li> <p>Rediscover items    In your browser, navigate to <code>&lt;API_URI&gt;/admin/rediscover</code> and log in with your <code>ADMIN_USERNAME</code> and <code>ADMIN_PASSWORD</code>.</p> </li> <li> <p>Locate the update file    After rediscovering, locate the new update file in the <code>api/apidata/upd</code> folder (for example, <code>2.json</code> if the previous update was <code>1.json</code>).</p> </li> <li> <p>Generate an update    Run:</p> <pre><code>docker-compose exec api /ctl genupd &lt;path-to-update-file&gt; &lt;collection-address&gt; \n</code></pre> <p>Replace <code>&lt;path-to-update-file&gt;</code> with the new update file\u2019s path (e.g., <code>api/apidata/upd/2.json</code>) and <code>&lt;collection-address&gt;</code> with the NFT collection address.</p> </li> <li> <p>Invoke the <code>ton://</code> deeplink    Follow the generated <code>ton://</code> link and confirm the transaction. You may also generate a QR code from the link and scan it with the Tonhub wallet.</p> </li> <li> <p>Wait for confirmation    Monitor the container API logs until you see a message indicating a <code>committed state</code>.</p> <pre><code>docker-compose logs api \n</code></pre> </li> <li> <p>Done!</p> </li> </ol>"},{"location":"cookbook/cnft/#conclusion","title":"Conclusion","text":"<p>The Compressed NFT standard transforms the creation and management of NFT collections by offering a scalable, cost-effective solution for mass NFT production. By addressing the limitations of existing standards, this approach paves the way for broader adoption and innovative applications of NFT technology in community building and marketing campaigns.</p>"},{"location":"cookbook/cnft/#see-also","title":"See also","text":"<ul> <li>Compressed NFT standard implementation</li> <li>Reference augmenting API implementation</li> <li>Compressed NFT toolbox</li> </ul>"},{"location":"cookbook/subdomains/","title":"Minting TON DNS Subdomains","text":""},{"location":"cookbook/subdomains/#introduction","title":"Introduction","text":"<p>This guide walks you through creating and managing subdomains on the TON blockchain using open-source tools. It covers deploying subdomain management contracts, issuing subdomains, and managing DNS records with practical examples.</p>"},{"location":"cookbook/subdomains/#implementation","title":"Implementation","text":"<p>There are two open-source implementations available for managing subdomains on TON, depending on the level of complexity and control you need:</p>"},{"location":"cookbook/subdomains/#subdomain-collection","title":"Subdomain Collection","text":"<p>GitHub \u2197</p> <p>This is a more advanced solution where each subdomain is represented as an NFT. The owner of the collection is responsible for issuing subdomains, while each NFT owner has full control over their subdomain.</p> <p>Key Features:</p> <ul> <li>Subdomains can be transferred or sold</li> <li>Decentralized record management \u2014 each subdomain has its own smart contract</li> <li>Requires additional infrastructure (e.g., metadata API)</li> </ul>"},{"location":"cookbook/subdomains/#subdomain-manager","title":"Subdomain Manager","text":"<p>GitHub \u2197</p> <p>This is a basic implementation where a single smart contract acts as the centralized subdomain manager. The administrator is responsible for issuing subdomains and configuring their DNS records.</p> <p>Key Features:</p> <ul> <li>Suitable for simple use cases</li> <li>Quick and easy setup</li> <li>Centralized control through one smart contract</li> </ul>"},{"location":"cookbook/subdomains/#environment-setup","title":"Environment Setup","text":"<p>This guide uses Python along with the open-source tonutils library, which supports both subdomain management implementations.</p>"},{"location":"cookbook/subdomains/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>A registered .ton domain:<ul> <li>Mainnet: dns.ton.org</li> <li>Testnet: dns.ton.org?testnet=true</li> </ul> </li> </ul>"},{"location":"cookbook/subdomains/#install-dependencies","title":"Install Dependencies","text":"<p>Install the required Python library:</p> <pre><code>pip install tonutils\n</code></pre>"},{"location":"cookbook/subdomains/#additional-requirements-for-subdomain-collection","title":"Additional Requirements for Subdomain Collection","text":"<p>If you\u2019re using the Subdomain Collection approach, you\u2019ll also need:</p> <ul> <li>A server to host the metadata API</li> <li>A domain name pointing to that server for metadata access</li> <li>Docker and Docker Compose for easy deployment of the API</li> </ul>"},{"location":"cookbook/subdomains/#subdomain-collection_1","title":"Subdomain Collection","text":""},{"location":"cookbook/subdomains/#metadata-setup","title":"Metadata Setup","text":"<p>Before deploying the subdomain collection, you need to launch the metadata API. This service is responsible for generating dynamic images and attributes for your subdomain NFTs, making them visually identifiable.</p> <ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/nessshon/subdomains-toolbox\ncd metadata-api\n</code></pre> <ol> <li>Start the API using Docker:    The API will be running on port <code>8001</code>. You will need to configure SSL and set up a reverse proxy to expose it securely.</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Test the API:    Visit <code>https://your-domain.com/api/ton/example.png</code> in your browser. If set up correctly, you\u2019ll see a generated image for the subdomain <code>example</code>.</li> </ol>"},{"location":"cookbook/subdomains/#deploy-the-collection","title":"Deploy the Collection","text":"<p>Once the API is running, you can deploy the NFT collection smart contract for your subdomains.</p> <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_collection import SubdomainCollection\nfrom tonutils.dns.subdomain_collection.content import SubdomainCollectionContent\nfrom tonutils.dns.subdomain_collection.data import FullDomain\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# NFT domain name and address from TON DNS Domains\n# Obtainable from https://dns.ton.org/ or https://dns.ton.org/?testnet=true\nDOMAIN_NAME = \"ghost\"  # ghost \u2192 ghost.ton\nDOMAIN_ADDRESS = \"EQ...\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n# Base URL of the API for generating metadata for NFTs\n# API source code: https://github.com/nessshon/subdomains-toolbox\nAPI_BASE_URL = \"https://your-domain.com/api/ton/\"\n\n# Metadata for the NFT collection\nCOLLECTION_METADATA = {\n    \"name\": f\"{DOMAIN_NAME.title()} DNS Domains\",\n    \"image\": f\"{API_BASE_URL}{DOMAIN_NAME}.png\",\n    \"description\": f\"*.{DOMAIN_NAME}.ton domains\",\n    \"prefix_uri\": API_BASE_URL,\n}\n\"\"\"\nExample of the metadata for the NFT collection (JSON format):\n{\n    \"name\": \"Ghost DNS Domains\",\n    \"image\": \"https://your-domain.com/api/ton/ghost.png\",\n    \"description\": \"*.ghost.ton domains\",\n    \"prefix_uri\": \"https://your-domain.com/api/ton/\"\n}\n\"\"\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = SubdomainCollection(\n        owner_address=wallet.address,\n        content=SubdomainCollectionContent(**COLLECTION_METADATA),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=wallet.address,\n        ),\n        full_domain=FullDomain(DOMAIN_NAME, \"ton\"),\n    )\n\n    tx_hash = await wallet.batch_transfer(\n        [\n            # Deploy collection\n            TransferData(\n                destination=collection.address,\n                amount=0.05,\n                body=collection.build_deploy_body(),\n                state_init=collection.state_init,\n            ),\n            # Bind Subdomain Collection to the main domain\n            TransferData(\n                destination=DOMAIN_ADDRESS,\n                amount=0.05,\n                body=Domain.build_set_next_resolver_record_body(collection.address),\n            ),\n        ]\n    )\n\n    print(f\"Successfully deployed Subdomain Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#minting-subdomains","title":"Minting Subdomains","text":"<p>To mint a new subdomain as an NFT:</p> <ol> <li>Open your TON wallet (e.g., Tonkeeper).</li> <li>Send 0.1 TON to the Subdomain Collection contract address (printed during deployment).</li> <li>In the transaction comment field, enter the desired subdomain name (e.g., <code>alice</code> for <code>alice.ghost.ton</code>).</li> <li>Ensure the subdomain name is valid (alphanumeric, no special characters) and not already minted.</li> <li>After the transaction is confirmed, the subdomain NFT will be sent to your wallet.</li> </ol>"},{"location":"cookbook/subdomains/#managing-records","title":"Managing Records","text":""},{"location":"cookbook/subdomains/#setting-records","title":"Setting Records","text":"<p>The record-setting mechanism for NFT subdomains is similar to the one used in the TON DNS Domains collection. You can assign one of the following record types to a subdomain \u2014 examples for each are provided below.</p> Set Wallet Record <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Address of the wallet to be set (e.g., UQ...)\nWALLET_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_wallet_record_body(Address(WALLET_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Set Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# ADNL address (e.g., \"a1b2c3...\")\nADNL_ADDRESS = \"a1b2c3...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_site_record_body(ADNL_ADDRESS)\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Set TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Hex-encoded BAG ID (e.g., \"1234567890abcdef...\")\nBAG_ID = \"1234567890abcdef...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_storage_record_body(BAG_ID)\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Set Next Resolver Record <pre><code>import asyncio\n\nfrom pytoniq_core import Address\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Address of the next resolver contract (e.g., EQ...)\nCONTRACT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_next_resolver_record_body(Address(CONTRACT_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#deleting-records","title":"Deleting Records","text":"<p>Similarly, you can delete existing records. Below are examples for each type.</p> Delete Wallet Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_delete_wallet_record_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Delete Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_delete_site_record_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Delete TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_delete_storage_record_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Delete Next Resolver Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_delete_next_resolver_record_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#subdomain-manager_1","title":"Subdomain Manager","text":""},{"location":"cookbook/subdomains/#deploy-the-manager","title":"Deploy the Manager","text":"<p>Below is an example of how to deploy the Subdomain Manager using the tonutils Python library. This script initializes the smart contract, links it to the main domain, and sends the necessary transactions from your wallet.</p> <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Administrator address for managing the Subdomain Manager (e.g., UQ...)\nADMIN_ADDRESS = \"UQ...\"\n\n# NFT address of the main domain from TON DNS Domains collection (e.g., EQ...)\nDOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    subdomain_manager = SubdomainManager(Address(ADMIN_ADDRESS))\n\n    tx_hash = await wallet.batch_transfer(\n        [\n            # Deploy Subdomain Manager\n            TransferData(\n                destination=subdomain_manager.address,\n                amount=0.05,\n                state_init=subdomain_manager.state_init,\n            ),\n            # Bind Subdomain Manager to the main domain as a next resolver\n            TransferData(\n                destination=DOMAIN_ADDRESS,\n                amount=0.05,\n                body=Domain.build_set_next_resolver_record_body(subdomain_manager.address),\n            ),\n        ]\n    )\n\n    print(f\"Successfully deployed Subdomain Manager at address: {subdomain_manager.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#setting-records_1","title":"Setting Records","text":"<p>You can set one of the following record types for a subdomain. Below are examples for each.</p> Set Wallet Record <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Address of the wallet to be set for the subdomain (e.g., UQ...)\nWALLET_ADDRESS = \"UQ...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_wallet_record_body(SUBDOMAIN, Address(WALLET_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Set Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# ADNL address for the subdomain (e.g., \"a1b2c3...\")\nADNL_ADDRESS = \"a1b2c3...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_site_record_body(SUBDOMAIN, ADNL_ADDRESS)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Set TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# ID of the storage bag (hex string, e.g., \"1234567890abcdef...\")\nBAG_ID = \"1234567890abcdef...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_storage_record_body(SUBDOMAIN, BAG_ID)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Set Next Resolver Record <pre><code>import asyncio\n\nfrom pytoniq_core import Address\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Address of the next resolver contract (e.g., EQ...)\nCONTRACT_ADDRESS = \"EQ...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_next_resolver_record_body(SUBDOMAIN, Address(CONTRACT_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#deleting-records_1","title":"Deleting Records","text":"<p>Similarly, you can delete existing records. Below are examples for each type.</p> Delete Wallet Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_delete_wallet_record_body(SUBDOMAIN)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Delete Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_delete_site_record_body(SUBDOMAIN, False)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Delete TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_delete_storage_record_body(SUBDOMAIN, True)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Delete Next Resolver Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_delete_next_resolver_record_body(SUBDOMAIN)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#conclusion","title":"Conclusion","text":"<p>TON blockchain offers flexible options for subdomain management, whether you prefer a centralized approach with the Subdomain Manager or a decentralized, NFT-based solution with the Subdomain Collection. Both solutions are easy to implement and provide powerful tools to manage your subdomains and DNS records efficiently. This guide provides all the necessary steps to get started and take control of your subdomains on TON.</p>"},{"location":"cookbook/subdomains/#see-also","title":"See also","text":"<ul> <li>TON Subdomains Toolbox</li> <li>Subdomain Manager Contract</li> <li>Subdomain Collection Contract</li> </ul>"},{"location":"cookbook/vanity/","title":"Creating Vanity Address","text":""},{"location":"cookbook/vanity/#introduction","title":"Introduction","text":"<p>This guide explains how to create vanity addresses on the TON blockchain \u2014 contracts or wallets with custom patterns (for example, specific starting or ending characters) that make the address visually distinctive. Vanity addresses are often used for branding, better recognizability, or aesthetic purposes.</p>"},{"location":"cookbook/vanity/#vanity-contract-address","title":"Vanity Contract Address","text":"<p>To create a vanity contract address (for example, for a Jetton Master contract), follow these steps.</p>"},{"location":"cookbook/vanity/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/ton-community/vanity-contract\n</code></pre>"},{"location":"cookbook/vanity/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"cookbook/vanity/#run-the-generator","title":"Run the Generator","text":"<pre><code>python src/generator/run.py --end {suffix} -w -0 --case-sensitive {owner_address}\n</code></pre> <ul> <li>Replace <code>{suffix}</code> with the desired ending for the generated address.</li> <li>Replace <code>{owner_address}</code> with the wallet address from which the deployment will be made.</li> </ul> <p>Example:</p> <pre><code>python src/generator/run.py --end NESS -w -0 --case-sensitive UQCZq3_Vd21-4y4m7Wc-ej9NFOhh_qvdfAkAYAOHoQ__Ness\n</code></pre> <p>If a match is found, you will see a message like:</p> <pre><code>Found: EQC7PA9iWnUVWv001Drj3vTu-pmAkTc30OarHy5iDJ1uNESS salt: 7c9398f0999a96fe5480b5d573817255d53377a000be18d0fb47d090a5606dfe\n</code></pre>"},{"location":"cookbook/vanity/#deploy-the-contract","title":"Deploy the Contract","text":"<p>Copy the <code>salt</code> value and use it in the <code>SALT</code> constant in the deployment script:</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.jetton.content import JettonOnchainContent\nfrom tonutils.vanity import Vanity\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The salt for the vanity address\nSALT = \"\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_master = JettonMasterStandard(\n        content=JettonOnchainContent(\n            name=\"Ness Jetton\",\n            symbol=\"NESS\",\n            description=\"Probably nothing\",\n            decimals=9,\n            image=\"https://ton.org/download/ton_symbol.png\",\n        ),\n        admin_address=wallet.address,\n    )\n    vanity = Vanity(\n        owner_address=wallet.address,\n        salt=SALT,\n    )\n    body = vanity.build_deploy_body(jetton_master)\n\n    tx_hash = await wallet.transfer(\n        destination=vanity.address,\n        amount=0.05,\n        body=body,\n        state_init=vanity.state_init,\n    )\n\n    print(f\"Successfully deployed contract at address: {vanity.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"cookbook/vanity/#vanity-wallet-address","title":"Vanity Wallet Address","text":"<p>To create a vanity wallet address using GPU acceleration, follow these steps.</p>"},{"location":"cookbook/vanity/#check-requirements","title":"Check Requirements","text":"<p>NVIDIA GPU (driver version 555.* or later).</p>"},{"location":"cookbook/vanity/#download-binary","title":"Download Binary","text":"<p>Download the <code>gpu-generator-linux</code> binary from the latest release.</p>"},{"location":"cookbook/vanity/#run-the-generator_1","title":"Run the Generator","text":"<p>To start the generator with interactive input:</p> <pre><code>./gpu-generator-linux\n</code></pre> <p>To run the generator with predefined constraints directly from the command line:</p> <pre><code>./gpu-generator-linux -q \"start[*][T][O][N] | end[1][2][3]\"\n</code></pre> <p>Follow the on-screen instructions to monitor progress and view results.</p> <p>After a successful match, the tool will display the mnemonic phrase and the wallet ID for use with a <code>WalletV3R2</code> wallet.</p> <p>Constraints Syntax</p> <ul> <li> <p>Allowed characters: <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>_</code>, <code>-</code></p> </li> <li> <p>Start constraint (after <code>UQ</code> prefix, third character):</p> <p>Example \u2192 <code>start[A][P][P][L][E]</code> or <code>start[*][T][O][N]</code></p> </li> <li> <p>End constraint:</p> <p>Example \u2192 <code>end[T][O][N]</code> or <code>end[Tt][Oo][Nn]</code></p> </li> <li> <p>Combined constraints:</p> <p>Example \u2192 <code>start[*][T][O][N] &amp; end[T][O][N]</code></p> </li> <li> <p>Multiple variants (OR):</p> <p>Example \u2192 <code>start[*][T][O][N] &amp; end[T][O][N] | start[D][D][D] | end[0][0][0]</code></p> </li> </ul> <p>Performance Reference</p> Hardware 5 chars 6 chars 7 chars 8 chars Intel i5-8350U 4 min 4 h 40 m 12.5 days &gt; 2 years AMD Ryzen 5 3600 26 sec 30 min 31.5 h 84 days NVIDIA GTX 1650 SUPER 2 sec 2 min 2 h 5.5 days NVIDIA RTX 4090 &lt;1 sec 13 sec 13.5 min 14.5 h"},{"location":"cookbook/vanity/#use-the-generated-wallet","title":"Use the Generated Wallet","text":"<p>After obtaining the mnemonic and wallet ID, use the following code:</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Wallet ID\nWALLET_ID = 0\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC, WALLET_ID)\n\n    print(f\"Address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cookbook/vanity/#conclusion","title":"Conclusion","text":"<p>Vanity addresses are a cosmetic feature that can make your TON wallet or contract stand out. While they offer no functional advantage, they can be useful for branding, marketing, or personal aesthetics.</p>"},{"location":"cookbook/vanity/#see-also","title":"See also","text":"<ul> <li>Vanity Contract Generator</li> <li>Vanity Wallet Generator</li> </ul>"},{"location":"guide/dns-operations/","title":"DNS Operations","text":"<p>This section provides a complete guide to managing TON DNS records and subdomains using the <code>tonutils</code> library. It covers setting various DNS records, deploying and minting subdomains as NFTs, and using both subdomain collections and simple subdomain managers.</p>"},{"location":"guide/dns-operations/#set-records","title":"Set Records","text":""},{"location":"guide/dns-operations/#set-site","title":"Set Site","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the NFT domain where the site record will be set\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# The ADNL address that will be set in the DNS record\nADNL_ADDRESS = \"{hex}\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_site_record_body(ADNL_ADDRESS)\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Site record set successfully!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#set-wallet","title":"Set Wallet","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the NFT domain where the wallet record will be set\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# The address of the wallet that will be set in the DNS record\nWALLET_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_wallet_record_body(Address(WALLET_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Wallet record set successfully!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#set-storage","title":"Set Storage","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the NFT domain where the storage record will be set\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# The hex-encoded BAG ID for the storage record\nBAG_ID = \"{hex}\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_storage_record_body(BAG_ID)\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Storage record set successfully!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#set-next-resolver","title":"Set Next Resolver","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the NFT domain where the next resolver record will be set\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# The address of the contract to be set as the next resolver\nCONTRACT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_next_resolver_record_body(Address(CONTRACT_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Next resolver record set successfully!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#subdomain-collection","title":"Subdomain Collection","text":""},{"location":"guide/dns-operations/#deploy-collection","title":"Deploy Collection","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_collection import SubdomainCollection\nfrom tonutils.dns.subdomain_collection.content import SubdomainCollectionContent\nfrom tonutils.dns.subdomain_collection.data import FullDomain\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# NFT domain name and address from TON DNS Domains\n# Obtainable from https://dns.ton.org/ or https://dns.ton.org/?testnet=true\nDOMAIN_NAME = \"ghost\"  # ghost \u2192 ghost.ton\nDOMAIN_ADDRESS = \"EQ...\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n# The base URL of the API for generating metadata for NFTs.\n# API source code: https://github.com/nessshon/subdomains-toolbox\nAPI_BASE_URL = \"https://dns.ness.su/api/ton/\"\n\n# Metadata for the NFT collection\nCOLLECTION_METADATA = {\n    \"name\": f\"{DOMAIN_NAME.title()} DNS Domains\",\n    \"image\": f\"{API_BASE_URL}{DOMAIN_NAME}.png\",\n    \"description\": f\"*.{DOMAIN_NAME}.ton domains\",\n    \"prefix_uri\": API_BASE_URL,\n}\n\"\"\"\n{\n    \"name\": \"Ghost DNS Domains\",\n    \"image\": \"https://dns.ness.su/api/ton/ghost.png\",\n    \"description\": \"*.ghost.ton domains\",\n    \"prefix_uri\": \"https://dns.ness.su/api/ton/\"\n}\n\"\"\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = SubdomainCollection(\n        owner_address=wallet.address,\n        content=SubdomainCollectionContent(**COLLECTION_METADATA),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=wallet.address,\n        ),\n        full_domain=FullDomain(DOMAIN_NAME, \"ton\"),\n    )\n\n    tx_hash = await wallet.batch_transfer(\n        [\n            # Deploy collection\n            TransferData(\n                destination=collection.address,\n                amount=0.05,\n                body=collection.build_deploy_body(),\n                state_init=collection.state_init,\n            ),\n            # Binding a Subdomain Collection to the main domain\n            TransferData(\n                destination=DOMAIN_ADDRESS,\n                amount=0.05,\n                body=Domain.build_set_next_resolver_record_body(collection.address),\n            ),\n        ]\n    )\n\n    print(f\"Successfully deployed Subdomain Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#mint-subdomain-nft","title":"Mint Subdomain NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Subdomain Collection contract\nSUBDOMAIN_COLLECTION_ADDRESS = \"EQ...\"\n\n# The name of the subdomain to be minted\nSUBDOMAIN_NAME = \"alice\"  # alice \u2192 alice.ghost.ton\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_COLLECTION_ADDRESS,\n        amount=0.1,\n        body=SUBDOMAIN_NAME,\n    )\n\n    print(f\"Successfully minted subdomain {SUBDOMAIN_NAME}!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#simple-subdomain-manager","title":"Simple Subdomain Manager","text":""},{"location":"guide/dns-operations/#deploy-manager","title":"Deploy Manager","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network, False for main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the administrator for managing the Subdomain Manager\nADMIN_ADDRESS = \"UQ...\"\n\n# NFT domain address from TON DNS Domains\n# Obtainable from https://dns.ton.org/ or https://dns.ton.org/?testnet=true\nDOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    subdomain_manager = SubdomainManager(Address(ADMIN_ADDRESS))\n\n    tx_hash = await wallet.batch_transfer(\n        [\n            # Deploy collection\n            TransferData(\n                destination=subdomain_manager.address,\n                amount=0.05,\n                state_init=subdomain_manager.state_init,\n            ),\n            # Binding a Subdomain Manager to the main domain\n            TransferData(\n                destination=DOMAIN_ADDRESS,\n                amount=0.05,\n                body=Domain.build_set_next_resolver_record_body(subdomain_manager.address),\n            ),\n        ]\n    )\n\n    print(f\"Successfully deployed Subdomain Manager at address: {subdomain_manager.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#set-site-record","title":"Set Site Record","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the subdomain manager contract\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# The ADNL address to be set for the subdomain\nADNL_ADDRESS = \"{hex}\"\n\n# The subdomain to be registered\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_site_record_body(SUBDOMAIN, ADNL_ADDRESS)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Subdomain successfully registered and site record set!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#set-wallet-record","title":"Set Wallet Record","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the subdomain manager contract\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# The address of the wallet to be set for the subdomain\nWALLET_ADDRESS = \"UQ...\"\n\n# The subdomain to be registered\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_wallet_record_body(SUBDOMAIN, Address(WALLET_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Subdomain successfully registered and wallet set!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#set-storage-record","title":"Set Storage Record","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the subdomain manager contract\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# The ID of the storage bag to be set for the subdomain\nBAG_ID = \"{hex}\"\n\n# The subdomain to be registered\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_storage_record_body(SUBDOMAIN, BAG_ID)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Subdomain successfully registered and storage record set!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/dns-operations/#set-next-resolver-record","title":"Set Next Resolver Record","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the subdomain manager contract\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# The address of the next resolver contract\nCONTRACT_ADDRESS = \"EQ...\"\n\n# The subdomain to be registered\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_next_resolver_record_body(SUBDOMAIN, Address(CONTRACT_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully registered subdomain and set the next resolver!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/getting-testnet-assets/","title":"Getting testnet assets","text":"<p>This section explains how to claim testnet assets.</p>"},{"location":"guide/getting-testnet-assets/#ton","title":"TON","text":"TON To get TON, go to the Telegram bot and follow its instructions. Open Telegram Bot"},{"location":"guide/getting-testnet-assets/#not-jetton-9-decimals","title":"NOT Jetton (9 decimals)","text":"NOT Jetton To claim NOT jettons, scan this QR code in your TON wallet. Claim Testnet NOT"},{"location":"guide/getting-testnet-assets/#usd-jetton-6-decimals","title":"USD\u20ae Jetton (6 decimals)","text":"USD\u20ae Jetton To claim USD\u20ae jettons, scan this QR code in your TON wallet. Claim Testnet USD\u20ae"},{"location":"guide/installation-and-initialization/","title":"Installation and Initialization","text":"<p>This section explains how to install the <code>tonutils</code> library and select the appropriate client depending on your needs.</p>"},{"location":"guide/installation-and-initialization/#installation","title":"Installation","text":"<p>To install the base <code>tonutils</code> package:</p> <pre><code>pip install tonutils\n</code></pre> <p>If you need to use Native ADNL connections, install with optional dependencies:</p> <pre><code>pip install 'tonutils[pytoniq]'\n</code></pre>"},{"location":"guide/installation-and-initialization/#available-clients","title":"Available Clients","text":""},{"location":"guide/installation-and-initialization/#rpc-api","title":"RPC API","text":""},{"location":"guide/installation-and-initialization/#toncenter","title":"toncenter","text":"<p>toncenter.com \u2014 fast and reliable HTTP API for The Open Network.  </p> <p>Note</p> <p>API key is optional, but for better performance it is recommended to obtain one via  @tonapibot.</p> <pre><code>from tonutils.client import ToncenterV2Client\nfrom tonutils.client import ToncenterV3Client\n\nAPI_KEY = \"your api key\"  # Optional\nIS_TESTNET = True\n\n# Using Toncenter V3 client\nclient_v3 = ToncenterV3Client(api_key=API_KEY, is_testnet=IS_TESTNET)\n\n# Using Toncenter V2 client (if needed)\n# client_v2 = ToncenterV2Client(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"guide/installation-and-initialization/#tonapi","title":"tonapi","text":"<p>tonapi.io \u2014 REST API to the TON blockchain explorer.  </p> <p>Note</p> <p>Requires an API key from tonconsole.com.</p> <pre><code>from tonutils.client import TonapiClient\n\nAPI_KEY = \"your api key\"\nIS_TESTNET = True\nclient = TonapiClient(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"guide/installation-and-initialization/#quicknode","title":"quicknode","text":"<p>quicknode.com \u2014 low-latency HTTP API access to TON via global infrastructure.  </p> <p>Note</p> <p>Requires an API URL from quicknode.com.</p> <p>Quicknode does not support testnet!</p> <pre><code>from tonutils.client import QuicknodeClient\n\nHTTP_PROVIDER_URL = \"https://blissful-withered-surf.ton-mainnet.quiknode.pro/d6e8...1964\"\nclient = QuicknodeClient(HTTP_PROVIDER_URL)\n</code></pre>"},{"location":"guide/installation-and-initialization/#tatum","title":"tatum","text":"<p>tatum.io \u2014 RPCs and APIs powering Web3.  </p> <p>Note</p> <p>Requires an API key from tatum.io.</p> <pre><code>from tonutils.client import TatumClient\n\nAPI_KEY = \"your api key\"\nIS_TESTNET = True\nclient = TatumClient(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"guide/installation-and-initialization/#native-adnl","title":"Native ADNL","text":""},{"location":"guide/installation-and-initialization/#pytoniq","title":"pytoniq","text":"<p>pytoniq \u2014 library for direct interaction with Lite servers.  </p> <p>Note</p> <p>For better performance, provide your own config, which can be obtained from the liteserver bot.</p> <pre><code>from tonutils.client import LiteserverClient\n\nIS_TESTNET = True\nclient = LiteserverClient(is_testnet=IS_TESTNET)\n\n# Using custom configuration\n# config = {}  # Your LiteServer config here \n# client = LiteserverClient(config=config)\n</code></pre>"},{"location":"guide/jetton-operations/","title":"Jetton Operations","text":"<p>This section provides a complete guide to working with Jettons using the <code>tonutils</code> library. It covers operations for both Stablecoin Jettons (by Notcoin) and Standard Jettons, including deployment, minting, burning, administration, and swaps through decentralized exchanges like STON.fi and DeDust.io.</p>"},{"location":"guide/jetton-operations/#stablecoin-jetton","title":"Stablecoin Jetton","text":""},{"location":"guide/jetton-operations/#deploy-jetton-master","title":"Deploy Jetton Master","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.jetton.content import JettonStablecoinContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the administrator for managing the Jetton Master\nADMIN_ADDRESS = \"UQ...\"\n\n# URI for the off-chain content of the Jetton\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-example-offchain\nURI = \"https://example.com/jetton.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_master = JettonMasterStablecoin(\n        content=JettonStablecoinContent(URI),\n        admin_address=ADMIN_ADDRESS,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_master.address,\n        amount=0.05,\n        state_init=jetton_master.state_init,\n    )\n\n    print(f\"Successfully deployed Jetton Master at address: {jetton_master.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#upgrade-contract","title":"Upgrade Contract","text":"<pre><code>from pytoniq_core import Cell\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Cell containing the updated contract code\nNEW_CODE_CELL = Cell.one_from_boc(\"code hex\")\n\n# Cell containing the updated contract data\nNEW_DATA_CELL = Cell.one_from_boc(\"data hex\")\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_upgrade_message_body(\n        new_code=NEW_CODE_CELL,\n        new_data=NEW_DATA_CELL,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully upgraded the contract!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#mint-jetton","title":"Mint Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The amount of Jettons to mint (in base units, considering decimals)\nJETTON_AMOUNT = 1000000\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_mint_body(\n        destination=wallet.address,\n        jetton_amount=int(JETTON_AMOUNT * (10 ** 9)),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.1,\n        body=body,\n    )\n\n    print(f\"Successfully minted {JETTON_AMOUNT} Jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#burn-jetton","title":"Burn Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin, JettonWalletStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The amount of Jettons to burn (in base units, considering decimals)\nJETTON_AMOUNT = 0.01\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_wallet_address = await JettonMasterStablecoin.get_wallet_address(\n        client=client,\n        owner_address=wallet.address.to_str(),\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n    )\n    body = JettonWalletStablecoin.build_burn_body(\n        jetton_amount=int(JETTON_AMOUNT * (10 ** 9)),\n        response_address=wallet.address,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_wallet_address,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully burned {JETTON_AMOUNT} Jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#change-admin","title":"Change Admin","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract where the admin will be changed\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The new administrator address to be set for the Jetton Master contract\nNEW_ADMIN_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_change_admin_body(\n        new_admin_address=Address(NEW_ADMIN_ADDRESS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully changed the admin of the Jetton Master!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#drop-admin","title":"Drop Admin","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract where the admin will be changed\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_drop_admin_body()\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Jetton Master admin has been successfully dropped!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#change-content","title":"Change Content","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.jetton.content import JettonStablecoinContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# New URI for the Jetton offchain content\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-example-offchain\nNEW_URI = \"https://example.com/new-jetton.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_change_content_body(\n        new_content=JettonStablecoinContent(NEW_URI),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully updated Jetton content!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#standard-jetton","title":"Standard Jetton","text":""},{"location":"guide/jetton-operations/#deploy-jetton-master-onchain","title":"Deploy Jetton Master (onchain)","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.jetton.content import JettonOnchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the administrator for managing the Jetton Master\nADMIN_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_master = JettonMasterStandard(\n        content=JettonOnchainContent(\n            name=\"Ness Jetton\",\n            symbol=\"NESS\",\n            description=\"Probably nothing\",\n            decimals=9,\n            image=\"https://example.com/image.png\",\n        ),\n        admin_address=ADMIN_ADDRESS,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_master.address,\n        amount=0.05,\n        state_init=jetton_master.state_init,\n    )\n\n    print(f\"Successfully deployed Jetton Master at address: {jetton_master.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#deploy-jetton-master-offchain","title":"Deploy Jetton Master (offchain)","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.jetton.content import JettonOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the administrator for managing the Jetton Master\nADMIN_ADDRESS = \"UQ...\"\n\n# URI for the off-chain content of the Jetton\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-example-offchain\nURI = \"https://example.com/jetton.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_master = JettonMasterStandard(\n        content=JettonOffchainContent(URI),\n        admin_address=ADMIN_ADDRESS,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_master.address,\n        amount=0.05,\n        state_init=jetton_master.state_init,\n    )\n\n    print(f\"Successfully deployed Jetton Master at address: {jetton_master.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#mint-jetton_1","title":"Mint Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The amount of Jettons to mint (in base units, considering decimals)\nJETTON_AMOUNT = 1000000\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStandard.build_mint_body(\n        destination=wallet.address,\n        jetton_amount=int(JETTON_AMOUNT * (10 ** JETTON_DECIMALS)),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully minted {JETTON_AMOUNT} Jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#burn-jetton_1","title":"Burn Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard, JettonWalletStandard\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# The amount of Jettons to burn (in base units, considering decimals)\nJETTON_AMOUNT = 0.01\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_wallet_address = await JettonMasterStandard.get_wallet_address(\n        client=client,\n        owner_address=wallet.address.to_str(),\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n    )\n    body = JettonWalletStandard.build_burn_body(\n        jetton_amount=int(JETTON_AMOUNT * (10 ** JETTON_DECIMALS)),\n        response_address=wallet.address,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_wallet_address,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully burned {JETTON_AMOUNT} Jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#change-admin_1","title":"Change Admin","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract where the admin will be changed\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The new administrator address to be set for the Jetton Master contract\nNEW_ADMIN_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStandard.build_change_admin_body(\n        new_admin_address=Address(NEW_ADMIN_ADDRESS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully changed the admin of the Jetton Master!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#change-content_1","title":"Change Content","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.jetton.content import JettonOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# New URI for the Jetton offchain content\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-example-offchain\nNEW_URI = \"https://example.com/new-jetton.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStandard.build_change_content_body(\n        new_content=JettonOffchainContent(NEW_URI),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully updated Jetton content!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#swap-jettons","title":"Swap Jettons","text":""},{"location":"guide/jetton-operations/#using-stonfi","title":"Using STON.fi","text":""},{"location":"guide/jetton-operations/#swap-ton-jetton","title":"Swap TON \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of STON.fi. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.stonfi import StonfiRouterV2, StonfiRouterV1\nfrom tonutils.jetton.dex.stonfi.utils import get_stonfi_router_details\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master for swapping (TON &gt; USD\u20ae)\nTO_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap (in base units, considering decimals)\nTON_AMOUNT = 1\n\n# Minimum amount of Jettons to receive (in base units, considering decimals)\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    version, router_address, pton_address = await get_stonfi_router_details(\n        offer_address=\"ton\",\n        ask_address=TO_JETTON_MASTER_ADDRESS,\n        amount=TON_AMOUNT,\n        decimals=9,\n        is_testnet=client.is_testnet,\n    )\n\n    if version == 1:\n        router_v1 = StonfiRouterV1(client, router_address, pton_address)\n\n        to, value, body = await router_v1.get_swap_ton_to_jetton_tx_params(\n            user_wallet_address=wallet.address,\n            ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n            offer_amount=to_nano(TON_AMOUNT),\n            min_ask_amount=to_nano(MIN_AMOUNT, JETTON_DECIMALS),\n        )\n    else:\n        router_v2 = StonfiRouterV2(client, router_address, pton_address)\n\n        to, value, body = await router_v2.get_swap_ton_to_jetton_tx_params(\n            user_wallet_address=wallet.address,\n            receiver_address=wallet.address,\n            ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n            offer_amount=to_nano(TON_AMOUNT),\n            min_ask_amount=to_nano(MIN_AMOUNT, JETTON_DECIMALS),\n            refund_address=wallet.address,\n        )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#swap-jetton-ton","title":"Swap Jetton \u2192 TON","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of STON.fi. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.stonfi import StonfiRouterV2, StonfiRouterV1\nfrom tonutils.jetton.dex.stonfi.utils import get_stonfi_router_details\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n# Minimum amount of TON to receive\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    version, router_address, pton_address = await get_stonfi_router_details(\n        offer_address=FROM_JETTON_MASTER_ADDRESS,\n        ask_address=\"ton\",\n        amount=JETTON_AMOUNT,\n        decimals=JETTON_DECIMALS,\n        is_testnet=client.is_testnet,\n    )\n\n    if version == 1:\n        router_v1 = StonfiRouterV1(client, router_address, pton_address)\n\n        to, value, body = await router_v1.get_swap_jetton_to_ton_tx_params(\n            offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n            user_wallet_address=wallet.address,\n            offer_amount=to_nano(JETTON_AMOUNT, JETTON_DECIMALS),\n            min_ask_amount=to_nano(MIN_AMOUNT),\n        )\n    else:\n        router_v2 = StonfiRouterV2(client, router_address, pton_address)\n\n        to, value, body = await router_v2.get_swap_jetton_to_ton_tx_params(\n            offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n            receiver_address=wallet.address,\n            user_wallet_address=wallet.address,\n            offer_amount=to_nano(JETTON_AMOUNT, JETTON_DECIMALS),\n            min_ask_amount=to_nano(MIN_AMOUNT),\n            refund_address=wallet.address,\n        )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#swap-jetton-jetton","title":"Swap Jetton \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of STON.fi. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.stonfi import StonfiRouterV2, StonfiRouterV1\nfrom tonutils.jetton.dex.stonfi.utils import get_stonfi_router_details\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\nTO_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 6\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n# Minimum amount of Jettons to receive (in base units, considering decimals)\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    version, router_address, pton_address = await get_stonfi_router_details(\n        offer_address=FROM_JETTON_MASTER_ADDRESS,\n        ask_address=TO_JETTON_MASTER_ADDRESS,\n        amount=JETTON_AMOUNT,\n        decimals=FROM_JETTON_DECIMALS,\n        is_testnet=client.is_testnet,\n    )\n\n    if version == 1:\n        router_v1 = StonfiRouterV1(client, router_address, pton_address)\n        to, value, body = await router_v1.get_swap_jetton_to_jetton_tx_params(\n            user_wallet_address=wallet.address,\n            offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n            ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n            offer_amount=to_nano(JETTON_AMOUNT, FROM_JETTON_DECIMALS),\n            min_ask_amount=to_nano(MIN_AMOUNT, TO_JETTON_DECIMALS),\n        )\n    else:\n        router_v2 = StonfiRouterV2(client, router_address, pton_address)\n        to, value, body = await router_v2.get_swap_jetton_to_jetton_tx_params(\n            user_wallet_address=wallet.address,\n            receiver_address=wallet.address,\n            refund_address=wallet.address,\n            offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n            ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n            offer_amount=to_nano(JETTON_AMOUNT, FROM_JETTON_DECIMALS),\n            min_ask_amount=to_nano(MIN_AMOUNT, TO_JETTON_DECIMALS),\n        )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#using-dedustio","title":"Using DeDust.io","text":""},{"location":"guide/jetton-operations/#swap-ton-jetton_1","title":"Swap TON \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of DeDust.io. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.dedust import Factory\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap\nTON_AMOUNT = 1\n\n# Minimum amount of Jettons to receive (in base units, considering decimals)\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    to, value, body = await Factory(client).get_swap_ton_to_jetton_tx_params(\n        recipient_address=wallet.address,\n        offer_jetton_address=Address(JETTON_MASTER_ADDRESS),\n        offer_amount=to_nano(TON_AMOUNT),\n        min_ask_amount=to_nano(MIN_AMOUNT, JETTON_DECIMALS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#swap-jetton-ton_1","title":"Swap Jetton \u2192 TON","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of DeDust.io. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.dedust import Factory\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n# Minimum amount of TON to receive\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    to, value, body = await Factory(client).get_swap_jetton_to_ton_tx_params(\n        recipient_address=wallet.address,\n        offer_jetton_address=Address(JETTON_MASTER_ADDRESS),\n        offer_amount=to_nano(JETTON_AMOUNT, JETTON_DECIMALS),\n        min_ask_amount=to_nano(MIN_AMOUNT),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/jetton-operations/#swap-jetton-jetton_1","title":"Swap Jetton \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of DeDust.io. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.dedust import Factory\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\nTO_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 6\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Minimum amount of Jettons to receive (in base units, considering decimals)\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    to, value, body = await Factory(client).get_swap_jetton_to_jetton_tx_params(\n        recipient_address=wallet.address,\n        offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n        ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n        offer_amount=to_nano(JETTON_AMOUNT, FROM_JETTON_DECIMALS),\n        min_ask_amount=to_nano(MIN_AMOUNT, TO_JETTON_DECIMALS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/","title":"NFT Operations","text":"<p>This section provides a complete guide to working with NFT collections using the <code>tonutils</code> library. It covers Standard, Soulbound, Editable, and Editable Onchain collections, including deployment, minting, batch operations, editing, and administrative tasks.</p>"},{"location":"guide/nft-operations/#standard-collection","title":"Standard Collection","text":""},{"location":"guide/nft-operations/#deploy-collection","title":"Deploy Collection","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionStandard\nfrom tonutils.nft.content import CollectionOffchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT collection\nOWNER_ADDRESS = \"UQ...\"\n\n# URI of the collection's metadata\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-collection-metadata-example-offchain\nURI = \"https://example.com/nft/collection.json\"\nPREFIX_URI = \"https://example.com/nft/\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = CollectionStandard(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionOffchainContent(uri=URI, prefix_uri=PREFIX_URI),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n\n    \"\"\" If you want the option to withdraw extra balance in the future and store collection and NFT data on-chain,\n        you can use `CollectionStandardModified`. It removes the need for `prefix_uri` because NFTs minted in this\n        format include a direct link to the metadata for each item, rather than using a shared prefix for all items.\n\n    Example:\n\n    collection = CollectionStandardModified(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/collection.json`.\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=collection.address,\n        amount=0.05,\n        state_init=collection.state_init,\n    )\n\n    print(f\"Successfully deployed NFT Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#mint-nft","title":"Mint NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.nft.contract.standard.collection import CollectionStandard\nfrom tonutils.nft.contract.standard.nft import NFTStandard\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Index of the NFT to be minted\nNFT_INDEX = 0\n\n# Suffix URI of the NFT metadata\nSUFFIX_URI = f\"{NFT_INDEX}.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft = NFTStandard(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionStandard.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTOffchainContent(suffix_uri=SUFFIX_URI),\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionStandard` and `NFTStandard` with their modified versions,\n        and use `NFTModifiedOffchainContent` to specify the full `URI` for the NFT metadata.\n\n    Example:\n\n    nft = NFTStandardModified(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionStandardModified.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/0.json`.\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully minted NFT with index {NFT_INDEX}: {nft.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#batch-mint-nft","title":"Batch Mint NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionStandard\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Starting index for minting items\nFROM_INDEX = 0\n\n# Number of items to mint\nITEMS_COUNT = 100\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionStandard.build_batch_mint_body(\n        data=[\n            (\n                NFTOffchainContent(suffix_uri=f\"{index}.json\"),\n                Address(OWNER_ADDRESS),\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionStandard` with `CollectionStandardModified`, \n        and use `NFTModifiedOffchainContent` to specify the full `URI` for each NFT metadata.\n\n    Example:\n\n    body = CollectionStandardModified.build_batch_mint_body(\n        data=[\n            (\n                NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/{index}.json`.\n                Address(OWNER_ADDRESS),\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=ITEMS_COUNT * 0.05,\n        body=body,\n    )\n\n    print(f\"Successfully minted {ITEMS_COUNT} items in the collection at address: {COLLECTION_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#soulbound-collection","title":"Soulbound Collection","text":""},{"location":"guide/nft-operations/#deploy-collection_1","title":"Deploy Collection","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionSoulbound\nfrom tonutils.nft.content import CollectionOffchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\n\n# URI of the collection's metadata\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-collection-metadata-example-offchain\nURI = \"https://example.com/nft/collection.json\"\nPREFIX_URI = \"https://example.com/nft/\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = CollectionSoulbound(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionOffchainContent(uri=URI, prefix_uri=PREFIX_URI),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n\n    \"\"\" If you want the option to withdraw extra balance in the future and store collection and NFT data on-chain,\n        you can use `CollectionSoulboundModified`. It removes the need for `prefix_uri` because NFTs minted in this\n        format include a direct link to the metadata for each item, rather than using a shared prefix for all items.\n\n    Example:\n\n    collection = CollectionSoulboundModified(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/collection.json`.\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=collection.address,\n        amount=0.05,\n        state_init=collection.state_init,\n    )\n\n    print(f\"Successfully deployed NFT Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#mint-nft_1","title":"Mint NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionSoulbound, NFTSoulbound\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Index of the NFT to be minted\nNFT_INDEX = 0\n\n# Suffix URI of the NFT metadata\nSUFFIX_URI = f\"{NFT_INDEX}.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft = NFTSoulbound(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionSoulbound.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTOffchainContent(suffix_uri=SUFFIX_URI),\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionSoulbound` and `NFTSoulbound` with their modified versions, \n        and use `NFTModifiedOffchainContent` to specify the full `URI` for the NFT metadata.\n\n    Example:\n\n    nft = NFTSoulboundModified(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionSoulboundModified.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/0.json`.\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully minted NFT with index {NFT_INDEX}: {nft.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#batch-mint-nft_1","title":"Batch Mint NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionSoulbound\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner and editor of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nEDITOR_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Starting index for minting items\nFROM_INDEX = 0\n\n# Number of items to mint\nITEMS_COUNT = 100\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionSoulbound.build_batch_mint_body(\n        data=[\n            (\n                NFTOffchainContent(suffix_uri=f\"{index}.json\"),\n                Address(OWNER_ADDRESS),\n                Address(EDITOR_ADDRESS),\n                None,  # revoked at\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionSoulbound` with `CollectionSoulboundModified`, \n        and use `NFTModifiedOffchainContent` to specify the full `URI` for each NFT metadata.\n\n    Example:\n\n    body = CollectionSoulboundModified.build_batch_mint_body(\n        data=[\n            (\n                NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/{index}.json`.\n                Address(OWNER_ADDRESS),\n                Address(EDITOR_ADDRESS),\n                None,  # revoked at\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=ITEMS_COUNT * 0.05,\n        body=body,\n    )\n\n    print(f\"Minted {ITEMS_COUNT} items in collection {COLLECTION_ADDRESS}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#revoke-nft","title":"Revoke NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import NFTSoulbound\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be revoked\nNFT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    # Initialize TonapiClient and Wallet\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = NFTSoulbound.build_revoke_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully revoked NFT at address: {NFT_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#destroy-nft","title":"Destroy NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import NFTSoulbound\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be destroyed\nNFT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = NFTSoulbound.build_destroy_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully destroyed NFT at address: {NFT_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#editable-collection","title":"Editable Collection","text":""},{"location":"guide/nft-operations/#deploy-collection_2","title":"Deploy Collection","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable\nfrom tonutils.nft.content import CollectionOffchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT collection\nOWNER_ADDRESS = \"UQ...\"\n\n# URI of the collection's metadata\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-collection-metadata-example-offchain\nURI = \"https://example.com/nft/collection.json\"\nPREFIX_URI = \"https://example.com/nft/\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = CollectionEditable(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionOffchainContent(uri=URI, prefix_uri=PREFIX_URI),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n\n    \"\"\" If you want the option to withdraw extra balance in the future and store collection and NFT data on-chain,\n        you can use `CollectionEditableModified`. It removes the need for `prefix_uri` because NFTs minted in this\n        format include a direct link to the metadata for each item, rather than using a shared prefix for all items.\n\n    Example:\n\n    collection = CollectionEditableModified(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/collection.json`.\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=collection.address,\n        amount=0.05,\n        state_init=collection.state_init,\n    )\n\n    print(f\"Successfully deployed NFT Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#mint-nft_2","title":"Mint NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable, NFTEditable\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Index of the NFT to be minted\nNFT_INDEX = 0\n\n# Suffix URI of the NFT metadata\nSUFFIX_URI = f\"{NFT_INDEX}.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft = NFTEditable(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionEditable.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTOffchainContent(suffix_uri=SUFFIX_URI),\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionEditable` and `NFTEditable` with their modified versions,\n        and use `NFTModifiedOffchainContent` to specify the full `URI` for the NFT metadata.\n\n    Example:\n\n    nft = NFTEditableModified(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionEditableModified.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/0.json`.\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully minted NFT with index {NFT_INDEX}: {nft.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#batch-mint-nft_2","title":"Batch Mint NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner and editor of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nEDITOR_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Starting index for minting items\nFROM_INDEX = 0\n\n# Number of items to mint\nITEMS_COUNT = 100\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionEditable.build_batch_mint_body(\n        data=[\n            (\n                NFTOffchainContent(suffix_uri=f\"{index}.json\"),\n                Address(OWNER_ADDRESS),\n                Address(EDITOR_ADDRESS),\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionEditable` with `CollectionEditableModified`, \n        and use `NFTModifiedOffchainContent` to specify the full `URI` for each NFT metadata.\n\n    Example:\n\n    body = CollectionEditableModified.build_batch_mint_body(\n        data=[\n            (\n                NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/{index}.json`.\n                Address(OWNER_ADDRESS),\n                Address(EDITOR_ADDRESS),\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=ITEMS_COUNT * 0.05,\n        body=body,\n    )\n\n    print(f\"Minted {ITEMS_COUNT} items in collection {COLLECTION_ADDRESS}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#edit-nft-content","title":"Edit NFT Content","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import NFTEditable\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be edited\nNFT_ADDRESS = \"EQ...\"\n\n# Suffix URI of the NFT metadata\nSUFFIX_URI = f\"new-content.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = NFTEditable.build_edit_content_body(\n        content=NFTOffchainContent(suffix_uri=SUFFIX_URI),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully edited the content of NFT at address: {NFT_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#change-nft-editorship","title":"Change NFT Editorship","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import NFTEditable\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT whose editorship will be changed\nNFT_ADDRESS = \"EQ...\"\n\n# Address of the new editor to whom the editorship will be transferred\nNEW_EDITOR_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = NFTEditable.build_change_editorship_body(\n        editor_address=Address(NEW_EDITOR_ADDRESS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully changed the editorship of NFT {NFT_ADDRESS} to {NEW_EDITOR_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#edit-collection-content","title":"Edit Collection Content","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable\nfrom tonutils.nft.content import CollectionOffchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the royalty receiver and the NFT collection contract\nROYALTY_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# URI of the collection's metadata\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-collection-metadata-example-offchain\nURI = \"https://example.com/nft/collection.json\"\nPREFIX_URI = \"https://example.com/nft/\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 60  # 6% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionEditable.build_edit_content_body(\n        content=CollectionOffchainContent(uri=URI, prefix_uri=PREFIX_URI),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(ROYALTY_ADDRESS),\n        ),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully edited the collection at address: {COLLECTION_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#change-collection-owner","title":"Change Collection Owner","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the new owner to whom the collection ownership will be transferred\nNEW_OWNER_ADDRESS = \"UQ...\"\n\n# Address of the NFT collection whose ownership will be changed\nCOLLECTION_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionEditable.build_change_owner_body(\n        owner_address=Address(NEW_OWNER_ADDRESS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully changed the owner of collection {COLLECTION_ADDRESS} to {NEW_OWNER_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#editable-onchain-collection","title":"Editable Onchain Collection","text":""},{"location":"guide/nft-operations/#deploy-collection_3","title":"Deploy Collection","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditableModified\nfrom tonutils.nft.content import CollectionModifiedOnchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT collection\nOWNER_ADDRESS = \"UQ...\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = CollectionEditableModified(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionModifiedOnchainContent(\n            name=\"Welcome to TON\",\n            description=\"Each digital artwork represents a memorable token\",\n            image_data=b'image data',\n        ),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=collection.address,\n        amount=0.05,\n        state_init=collection.state_init,\n    )\n\n    print(f\"Successfully deployed NFT Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#mint-nft_3","title":"Mint NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditableModified, NFTEditableModified\nfrom tonutils.nft.content import NFTModifiedOnchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Index of the NFT to be minted\nNFT_INDEX = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft = NFTEditableModified(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionEditableModified.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTModifiedOnchainContent(\n            name=\"TON Collectible #0\",\n            description=\"Memorable token for completing an onboarding quest about the TON ecosystem\",\n            image_data=b'image data',\n        ),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully minted NFT with index {NFT_INDEX}: {nft.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#return-collection-balance","title":"Return Collection Balance","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditableModified\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT collection contract\nCOLLECTION_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionEditableModified.build_return_balance()\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully returned the balance of collection {COLLECTION_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#listing-on-getgemsio","title":"Listing on Getgems.io","text":""},{"location":"guide/nft-operations/#list-nft-for-sale","title":"List NFT for Sale","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection, NFT\nfrom tonutils.nft.marketplace.getgems.addresses import *\nfrom tonutils.nft.marketplace.getgems.contract.salev3r3 import SaleV3R3\nfrom tonutils.utils import to_nano\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be listed for sale\nNFT_ADDRESS = \"EQ..\"\n\n# Sale price for the NFT in TON\nPRICE = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft_data = await NFT.get_nft_data(client, NFT_ADDRESS)\n    royalty_params = await Collection.get_royalty_params(client, nft_data.collection_address)\n\n    price = to_nano(PRICE)\n    royalty_fee = int(price * (royalty_params.base / royalty_params.factor))\n    marketplace_fee = int(price * 0.05)\n\n    sale = SaleV3R3(\n        nft_address=NFT_ADDRESS,\n        owner_address=wallet.address,\n        marketplace_address=TESTNET_GETGEMS_ADDRESS if IS_TESTNET else GETGEMS_ADDRESS,\n        marketplace_fee_address=TESTNET_GETGEMS_FEE_ADDRESS if IS_TESTNET else GETGEMS_FEE_ADDRESS,\n        royalty_address=royalty_params.address,\n        marketplace_fee=marketplace_fee,\n        royalty_fee=royalty_fee,\n        price=price,\n    )\n    body = sale.build_transfer_nft_body(\n        destination=Address(TESTNET_GETGEMS_DEPLOYER_ADDRESS if IS_TESTNET else GETGEMS_DEPLOYER_ADDRESS),\n        owner_address=wallet.address,\n        state_init=sale.state_init,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.25,\n        body=body,\n    )\n\n    # Print the result of the operation\n    print(f\"NFT {NFT_ADDRESS} successfully put on sale at price {PRICE} TON.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#change-nft-price","title":"Change NFT Price","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection, NFT\nfrom tonutils.nft.marketplace.getgems.contract.salev3r3 import SaleV3R3\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT and sale contract\nNFT_ADDRESS = \"EQ...\"\nSALE_ADDRESS = \"EQ...\"\n\n# New sale price for the NFT in TON\nPRICE = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft_data = await NFT.get_nft_data(client, NFT_ADDRESS)\n    royalty_params = await Collection.get_royalty_params(client, nft_data.collection_address)\n\n    price = int(PRICE * 1e9)\n    royalty_fee = int(price * (royalty_params.base / royalty_params.factor))\n    marketplace_fee = int(price * 0.05)\n\n    body = SaleV3R3.build_change_price_body(\n        marketplace_fee=marketplace_fee,\n        royalty_fee=royalty_fee,\n        price=price,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=SALE_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n\n    print(f\"Successfully updated the price for NFT sale.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/nft-operations/#cancel-nft-sale","title":"Cancel NFT Sale","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft.marketplace.getgems.contract.salev3r3 import SaleV3R3\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the sale contract\nSALE_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SaleV3R3.build_cancel_sale_body()\n\n    tx_hash = await wallet.transfer(\n        destination=SALE_ADDRESS,\n        amount=0.2,\n        body=body,\n    )\n\n    print(\"Sale has been successfully canceled.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/","title":"Wallet Operations","text":"<p>This section provides a complete guide to managing wallets using the <code>tonutils</code> library. It covers key operations such as:</p> <ul> <li>Creating and deploying wallets</li> <li>Importing wallets from mnemonic or private key</li> <li>Sending transactions (TON, NFTs, Jettons)</li> <li>Performing batch transfers</li> <li>Executing Jetton swaps (via STON.fi and DeDust.io)</li> </ul>"},{"location":"guide/wallet-operations/#supported-wallet","title":"Supported Wallet","text":"<p>The library supports multiple wallet versions and types:</p> <ul> <li>Standard wallets:   <code>WalletV2R1</code>, <code>WalletV2R2</code>, <code>WalletV3R1</code>, <code>WalletV3R2</code>, <code>WalletV4R1</code>, <code>WalletV4R2</code>, <code>WalletV5R1</code></li> <li>Highload wallets (for services and exchanges):   <code>HighloadWalletV2</code>, <code>HighloadWalletV3</code></li> <li>Preprocessed wallets (for economical batch operations):   <code>PreprocessedWalletV2</code>, <code>PreprocessedWalletV2R1</code></li> </ul>"},{"location":"guide/wallet-operations/#recommendations","title":"Recommendations","text":"<ul> <li>For general use, it\u2019s recommended to work with wallet versions v3r2 to v5r1, preferably v5r1 for full feature support.</li> <li>For service and exchange integrations, use HighloadWalletV3.</li> <li>For large-scale batch transfers where gas optimization is critical, use PreprocessedWallet types.</li> </ul>"},{"location":"guide/wallet-operations/#create-wallet","title":"Create Wallet","text":"<p>To create a new wallet, use the <code>.create()</code> method provided by the wallet class you select. This generates a wallet instance along with its public key, private key, and mnemonic phrase.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import (\n    # Uncomment the following lines to use different wallet versions:\n    # WalletV2R1,\n    # WalletV2R2,\n    # WalletV3R1,\n    # WalletV3R2,\n    # WalletV4R1,\n    WalletV4R2,\n    # WalletV5R1,\n    # HighloadWalletV2,\n    # HighloadWalletV3,\n    # PreprocessedWalletV2,\n    # PreprocessedWalletV2R1,\n)\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.create(client)\n\n    # Uncomment and use the following lines to create different wallet versions:\n    # wallet, public_key, private_key, mnemonic = WalletV3R2.create(client)\n    # wallet, public_key, private_key, mnemonic = WalletV4R1.create(client)\n    # wallet, public_key, private_key, mnemonic = WalletV4R2.create(client)\n    # wallet, public_key, private_key, mnemonic = WalletV5R1.create(client)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV2.create(client)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV3.create(client)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2.create(client)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2R1.create(client)\n\n    print(\"Wallet has been successfully created!\")\n    print(f\"Address: {wallet.address.to_str()}\")\n    print(f\"Mnemonic: {mnemonic}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guide/wallet-operations/#import-wallet","title":"Import Wallet","text":"<p>You can import a wallet either from a mnemonic phrase or directly from a private key.</p>"},{"location":"guide/wallet-operations/#from-mnemonic","title":"From Mnemonic","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guide/wallet-operations/#from-private-key","title":"From Private Key","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Private key (32 or 64 bytes)\nPRIVATE_KEY: bytes = b\"your_private_key_bytes\"\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet = WalletV4R2.from_private_key(client, PRIVATE_KEY)\n\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guide/wallet-operations/#deploy-wallet","title":"Deploy Wallet","text":"<p>To deploy a wallet, reconstruct it from a mnemonic and call the <code>.deploy()</code> method. This will publish the wallet contract on-chain.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import (\n    # Uncomment the following lines to use different wallet versions:\n    # WalletV2R1,\n    # WalletV2R2,\n    # WalletV3R1,\n    # WalletV3R2,\n    # WalletV4R1,\n    WalletV4R2,\n    # WalletV5R1,\n    # HighloadWalletV2,\n    # HighloadWalletV3,\n    # PreprocessedWalletV2,\n    # PreprocessedWalletV2R1,\n)\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    # Uncomment and use the following lines to create different wallet versions from mnemonic:\n    # wallet, public_key, private_key, mnemonic = WalletV2R1.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV2R2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV3R2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV4R1.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV5R1.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV3.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2R1.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.deploy()\n\n    print(f\"Wallet deployed successfully!\")\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#transfers","title":"Transfers","text":""},{"location":"guide/wallet-operations/#send-ton","title":"Send TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Optional comment to include in the forward payload\nCOMMENT = \"Hello from tonutils!\"\n\n# Amount to transfer in TON\nAMOUNT = 0.01\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer(\n        destination=DESTINATION_ADDRESS,\n        amount=AMOUNT,\n        body=COMMENT,\n    )\n\n    print(f\"Successfully transferred {AMOUNT} TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#send-nft","title":"Send NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be transferred and the new owner address\nNFT_ADDRESS = \"EQ...\"\nNEW_OWNER_ADDRESS = \"UQ...\"\n\n# Optional comment to include in the forward payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer_nft(\n        destination=NEW_OWNER_ADDRESS,\n        nft_address=NFT_ADDRESS,\n        forward_payload=COMMENT,\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#send-jetton","title":"Send Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to transfer (in base units, considering decimals)\nJETTON_AMOUNT = 0.01\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Comment to include in the transfer payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer_jetton(\n        destination=DESTINATION_ADDRESS,\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n        forward_payload=COMMENT,\n    )\n\n    print(f\"Successfully transferred {JETTON_AMOUNT} jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-transfers","title":"Batch Transfers","text":""},{"location":"guide/wallet-operations/#batch-send-ton","title":"Batch Send TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_transfer(\n        data_list=[\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n        ]\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-send-nft","title":"Batch Send NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferNFTData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_nft_transfer(\n        data_list=[\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            )\n        ]\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-send-jetton","title":"Batch Send Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferJettonData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_jetton_transfer(\n        data_list=[\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n        ]\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#jetton-swaps","title":"Jetton Swaps","text":""},{"location":"guide/wallet-operations/#using-stonfi","title":"Using STON.fi","text":""},{"location":"guide/wallet-operations/#swap-ton-jetton","title":"Swap TON \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of STON.fi. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master for swapping (TON &gt; USD\u20ae)\nTO_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap (in TON)\nSWAP_TON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.stonfi_swap_ton_to_jetton(\n        jetton_master_address=TO_JETTON_MASTER_ADDRESS,\n        ton_amount=SWAP_TON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#swap-jetton-ton","title":"Swap Jetton \u2192 TON","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of STON.fi. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master for swapping (TON &gt; USD\u20ae)\nTO_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.stonfi_swap_jetton_to_ton(\n        jetton_master_address=TO_JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#swap-jetton-jetton","title":"Swap Jetton \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of STON.fi. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\nTO_JETTON_MASTER_ADDRESS = \"EQAvlWFDxGF2lXm67y4yzC17wYKD9A0guwPkMs1gOsM__NOT\"  # noqa\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 6\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.stonfi_swap_jetton_to_jetton(\n        from_jetton_master_address=FROM_JETTON_MASTER_ADDRESS,\n        to_jetton_master_address=TO_JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        from_jetton_decimals=FROM_JETTON_DECIMALS,\n        to_jetton_decimals=TO_JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-ton-jetton","title":"Batch Swap TON \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of STON.fi. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import StonfiSwapTONToJettonData\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_stonfi_swap_ton_to_jetton(\n        data_list=[\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ],\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-jetton-ton","title":"Batch Swap Jetton \u2192 TON","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of STON.fi. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import StonfiSwapJettonToTONData\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_stonfi_swap_jetton_to_ton(\n        data_list=[\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ],\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-jetton-jetton","title":"Batch Swap Jetton \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of STON.fi. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import StonfiSwapJettonToJettonData\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_stonfi_swap_jetton_to_jetton(\n        data_list=[\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n        ],\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#using-dedustio","title":"Using DeDust.io","text":""},{"location":"guide/wallet-operations/#swap-ton-jetton_1","title":"Swap TON \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of DeDust.io. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap (in TON)\nSWAP_TON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.dedust_swap_ton_to_jetton(\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n        ton_amount=SWAP_TON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#swap-jetton-ton_1","title":"Swap Jetton \u2192 TON","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of DeDust.io. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.dedust_swap_jetton_to_ton(\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#swap-jetton-jetton_1","title":"Swap Jetton \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of DeDust.io. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQ...\"\nTO_JETTON_MASTER_B_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 9\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.dedust_swap_jetton_to_jetton(\n        from_jetton_master_address=FROM_JETTON_MASTER_ADDRESS,\n        to_jetton_master_address=TO_JETTON_MASTER_B_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        from_jetton_decimals=FROM_JETTON_DECIMALS,\n        to_jetton_decimals=TO_JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-ton-jetton_1","title":"Batch Swap TON \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of DeDust.io. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import DedustSwapTONToJettonData\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_dedust_swap_ton_to_jetton(\n        data_list=[\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ]\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-jetton-ton_1","title":"Batch Swap Jetton \u2192 TON","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of DeDust.io. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import DedustSwapJettonToTONData\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_dedust_swap_jetton_to_ton(\n        data_list=[\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ]\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-jetton-jetton_1","title":"Batch Swap Jetton \u2192 Jetton","text":"<p>Note</p> <p>Before using these instructions, please consult the official documentation of DeDust.io. Use with caution and always test carefully on a testnet first. I take no responsibility for any lost funds. If you find errors or have suggestions for improvement, feel free to open a pull request \u2014 let\u2019s make this better together.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import DedustSwapJettonToJettonData\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_dedust_swap_jetton_to_jetton(\n        data_list=[\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n        ]\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/","title":"Sending Transactions","text":"<p>This guide provides step-by-step instructions for integrating and managing transaction sending using the <code>TonConnect</code> from the <code>tonutils</code> library. Whether you're a beginner or an experienced developer, this guide will help you implement transaction functionality efficiently.</p>"},{"location":"guide/ton-connect/sending-transactions/#installation","title":"Installation","text":"<p>Install the necessary Python packages using <code>pip</code>:</p> <pre><code>pip install tonutils aiofiles\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/#configuration","title":"Configuration","text":""},{"location":"guide/ton-connect/sending-transactions/#create-tonconnect-manifest","title":"Create TonConnect Manifest","text":"<p>Create a JSON file describing your application. This manifest is displayed in the wallet during connection.</p> <pre><code>{\n  \"url\": \"&lt;app-url&gt;\",                        // required\n  \"name\": \"&lt;app-name&gt;\",                      // required\n  \"iconUrl\": \"&lt;app-icon-url&gt;\",               // required\n  \"termsOfUseUrl\": \"&lt;terms-of-use-url&gt;\",     // optional\n  \"privacyPolicyUrl\": \"&lt;privacy-policy-url&gt;\" // optional\n}\n</code></pre> <p>Note</p> <p>Ensure this file is publicly accessible via its URL.</p>"},{"location":"guide/ton-connect/sending-transactions/#storage-implementation","title":"Storage Implementation","text":"<p>The <code>FileStorage</code> class manages persistent storage of connection data using a JSON file.</p> <pre><code>import json\nimport os\nfrom asyncio import Lock\nfrom typing import Optional, Dict\n\nimport aiofiles\n\nfrom tonutils.tonconnect import IStorage\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/#initialize-tonconnect","title":"Initialize TonConnect","text":"<p>Set up the TonConnect instance with the manifest URL and storage implementation.</p> <pre><code>from storage import FileStorage\n\nfrom tonutils.tonconnect import TonConnect\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/#event-handling","title":"Event Handling","text":"<p>Handling events is essential for responding to transaction actions and errors. There are two primary methods to handle events: using decorators and using context managers.</p>"},{"location":"guide/ton-connect/sending-transactions/#using-decorators","title":"Using Decorators","text":"<p>Decorators associate event handlers with specific events. This method is straightforward and keeps your event handling logic organized.</p> <pre><code>@tc.on_event(Event.TRANSACTION)\nasync def on_transaction(transaction: SendTransactionResponse) -&gt; None:\n    print(f\"[Transaction SENT] Transaction successfully sent. Message hash: {transaction.normalized_hash}\")\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/#using-context-managers","title":"Using Context Managers","text":"<p>Context managers provide a controlled environment for handling events, ensuring proper setup and teardown.</p> <pre><code>async with connector.pending_transaction_context(rpc_request_id) as response:\n    if isinstance(response, TonConnectError):\n        print(f\"Error sending transaction: {response.message}\")\n    else:\n        print(f\"Transaction successful! Hash: {response.normalized_hash}\")\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/#passing-additional-parameters","title":"Passing Additional Parameters","text":"<p>In some cases, you may want to provide custom data or context to your event handlers \u2014 for example, adding tags, notes, or extra flags.</p> <p>You can achieve this by using the <code>connector.add_event_kwargs</code> method, which attaches additional keyword arguments that will be passed into the handler alongside the default parameters.</p> <p>Step 1: Add Custom Parameters</p> <p>Call <code>add_event_kwargs</code> before triggering or waiting on an event:</p> <pre><code>connector.add_event_kwargs(\n    event=Event.TRANSACTION,\n    comment=\"Hello from tonutils!\",\n)\n</code></pre> <p>Step 2: Update the Event Handler to Receive Them</p> <p>Define the handler to accept these extra parameters:</p> <pre><code>@tc.on_event(Event.TRANSACTION)\nasync def on_transaction(user_id: int, transaction: SendTransactionResponse, comment: str) -&gt; None:\n    print(f\"Comment: {comment}\")\n</code></pre> <p>Key Points:</p> <ul> <li>You can attach multiple parameters (any keyword arguments).</li> <li>The handler function must include matching parameter names.</li> <li>This mechanism works for all supported events (<code>CONNECT</code>, <code>DISCONNECT</code>, <code>TRANSACTION</code>, etc.).</li> </ul>"},{"location":"guide/ton-connect/sending-transactions/#sending-transactions","title":"Sending Transactions","text":""},{"location":"guide/ton-connect/sending-transactions/#sending-a-single-transaction","title":"Sending a Single Transaction","text":"<p>To send a single transaction, use the <code>send_transfer</code> method. This method sends a transaction to a specified destination with a certain amount and an optional message body.</p> <pre><code>rpc_request_id = await connector.send_transfer(\n    destination=connector.account.address,\n    amount=0.000000001,  # Amount in TON\n    body=\"Hello from tonutils!\",\n)\nprint(\"Request to send one transaction has been sent.\")\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/#sending-a-batch-of-transactions","title":"Sending a Batch of Transactions","text":"<p>To send multiple messages, use the <code>send_batch_transfer</code> method.</p> <pre><code># Get the maximum number of messages supported\nmax_messages = connector.get_max_supported_messages()\nprint(f\"Maximum number of messages: {max_messages}. Sending {max_messages} transactions...\")\n\nrpc_request_id = await connector.send_batch_transfer(\n    data_list=[\n        TransferData(\n            destination=connector.account.address,\n            amount=0.000000001,\n            body=\"Hello from tonutils!\",\n        ) for _ in range(max_messages)  # Create the maximum number of messages\n    ]\n)\nprint(\"Request to send a batch of transactions has been sent.\")\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/#handling-transaction-status","title":"Handling Transaction Status","text":"<p>After sending a transaction, you may want to check its status to determine if it has been confirmed by the user in the wallet.</p> <pre><code># Get the transaction status (whether it has been confirmed by the user in the wallet)\nis_pending = connector.is_transaction_pending(rpc_request_id)\nprint(f\"Transaction is pending confirmation: {is_pending}\")\n\n# Use a context manager to get the transaction result by rpc_request_id\nasync with connector.pending_transaction_context(rpc_request_id) as response:\n    if isinstance(response, TonConnectError):\n        print(f\"Error sending transaction: {response.message}\")\n    else:\n        print(f\"Transaction successful! Hash: {response.normalized_hash}\")\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/#complete-example","title":"Complete Example","text":"<p>Below is a comprehensive example demonstrating connector initialization, event handling, sending transactions, and wallet management.</p> <pre><code>import asyncio\nimport json\nimport os\nfrom asyncio import Lock\nfrom typing import Dict, Optional\n\nimport aiofiles\n\nfrom tonutils.tonconnect import TonConnect, IStorage\nfrom tonutils.tonconnect.models import Event, EventError, SendTransactionResponse\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\nfrom tonutils.wallet.data import TransferData\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n\n@tc.on_event(Event.TRANSACTION)\nasync def on_transaction(transaction: SendTransactionResponse) -&gt; None:\n    \"\"\"\n    Handler for successful transaction events.\n    Processes all successful transactions and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - transaction (SendTransactionResponse): Transaction information\n    - rpc_request_id (int): Transaction request identifier\n    - Additional parameters can be passed using `connector.add_event_kwargs(...)`\n      Example: `connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    Transaction details can be obtained from the following attributes:\n    - transaction.boc (str): BoC\n    - transaction.normalized_hash (str): Message hash\n    - transaction.cell (Cell): Transaction Cell\n    \"\"\"\n    print(f\"[Transaction SENT] Transaction successfully sent. Message hash: {transaction.normalized_hash}\")\n\n\n@tc.on_event(EventError.TRANSACTION)\nasync def on_transaction_error(error: TonConnectError) -&gt; None:\n    \"\"\"\n    Handler for transaction error events.\n    Processes all errors that occur when sending transactions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - error (TonConnectError): Error information\n    - rpc_request_id (int): Transaction request identifier\n    - Additional parameters can be passed using `connector.add_event_kwargs(...)`\n      Example: `connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    The type of error can be determined using isinstance:\n    - UserRejectsError: User declined the transaction.\n    - RequestTimeoutError: Send request timed out for the transaction.\n    \"\"\"\n    if isinstance(error, UserRejectsError):\n        print(f\"[Transaction ERROR] User rejected the transaction.\")\n    elif isinstance(error, RequestTimeoutError):\n        print(f\"[Transaction ERROR] Transaction request timed out.\")\n    else:\n        print(f\"[Transaction ERROR] Failed to send transaction: {error.message}\")\n\n\nasync def main() -&gt; None:\n    user_id = 12345  # Example user identifier\n\n    # Initialize the connector for the user\n    connector = await tc.init_connector(user_id)\n\n    # Start the event processing loop\n    while True:\n        # Check wallet connection\n        if not connector.connected:\n            print(\"Wallet not connected! Please connect the wallet to continue.\")\n\n            # Get all available wallets\n            wallets = await tc.get_wallets()\n\n            # As an example, we will select the wallet with index 1 (Tonkeeper)\n            selected_wallet = wallets[1]\n            connect_url = await connector.connect_wallet(selected_wallet)\n            print(f\"Please connect your wallet by visiting the following URL:\\n{connect_url}\")\n            print(\"Waiting for wallet connection...\")\n\n            async with connector.connect_wallet_context() as response:\n                if isinstance(response, TonConnectError):\n                    print(f\"Connection error: {response.message}\")\n                else:\n                    print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n\n        # If the wallet is connected, prompt the user to choose an action\n        call = input(\n            \"\\nChoose an action:\\n\"\n            \"1. Send a transaction\\n\"\n            \"2. Send a batch of transactions\\n\"\n            \"3. Disconnect wallet\\n\"\n            \"q. Quit\\n\"\n            \"\\nEnter your choice: \"\n        ).strip()\n\n        if call in [\"1\", \"2\"]:\n            if call == \"1\":\n                print(\"Preparing to send one transaction...\")\n                rpc_request_id = await connector.send_transfer(\n                    destination=connector.account.address,\n                    amount=0.000000001,\n                    body=\"Hello from tonutils!\",\n                )\n                print(\"Request to send one transaction has been sent.\")\n            else:\n                print(\"Preparing to send a batch of transactions...\")\n                # Get the maximum number of messages supported in a transaction\n                max_messages = connector.get_max_supported_messages()\n                print(f\"Maximum number of messages: {max_messages}. Sending {max_messages} transactions...\")\n\n                rpc_request_id = await connector.send_batch_transfer(\n                    data_list=[\n                        TransferData(\n                            destination=connector.account.address,\n                            amount=0.000000001,\n                            body=\"Hello from tonutils!\",\n                        ) for _ in range(max_messages)  # Create the maximum number of messages\n                    ]\n                )\n                print(\"Request to send a batch of transactions has been sent.\")\n\n            # Add additional parameters to be passed to event handlers\n            connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")\n\n            # Get the transaction status (whether it has been confirmed by the user in the wallet)\n            # Note: This is different from blockchain confirmation\n            is_pending = connector.is_transaction_pending(rpc_request_id)\n            print(f\"Transaction is pending confirmation: {is_pending}\")\n\n            # In addition to the handler, you can use a context manager to get the transaction result by rpc_request_id\n            async with connector.pending_transaction_context(rpc_request_id) as response:\n                if isinstance(response, TonConnectError):\n                    print(f\"Error sending transaction: {response.message}\")\n                else:\n                    print(f\"Transaction successful! Hash: {response.normalized_hash}\")\n\n        elif call == \"3\":\n            # Disconnect the wallet\n            await connector.disconnect_wallet()\n            print(\"Wallet successfully disconnected.\")\n\n        elif call.lower() == \"q\":\n            print(\"Exiting the program...\")\n            break\n\n        else:\n            print(\"Invalid choice! Please select a valid option.\")\n\n    # Close all TonConnect connections\n    await tc.close_all()\n\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except (KeyboardInterrupt, SystemExit):\n        # Ensure all connections are closed in case of interruption\n        asyncio.run(tc.close_all())\n</code></pre>"},{"location":"guide/ton-connect/sending-transactions/#conclusion","title":"Conclusion","text":"<p>By following this cookbook, you can successfully integrate TonConnect into your script enabling seamless wallet connections and transaction sending.</p>"},{"location":"guide/ton-connect/telegram-bot-integration/","title":"Telegram Bot Integration","text":"<p>This guide provides step-by-step instructions to integrate and manage wallet connections and transactions within a Telegram Bot using the <code>TonConnect</code> from the <code>tonutils</code> library. Whether you're a beginner or an experienced developer, this cookbook will help you implement wallet connectivity and transaction functionalities efficiently within your Telegram Bot.</p>"},{"location":"guide/ton-connect/telegram-bot-integration/#installation","title":"Installation","text":"<p>Install the necessary Python packages using <code>pip</code>:</p> <pre><code>pip install tonutils aiogram redis\n</code></pre>"},{"location":"guide/ton-connect/telegram-bot-integration/#structure","title":"Structure","text":"<p>Organize your project files as follows:</p> <pre><code>telegram-tonconnect-bot/\n\u251c\u2500\u2500 bot.py\n\u251c\u2500\u2500 storage.py\n</code></pre> <ul> <li>bot.py: Main bot script containing bot logic.</li> <li>storage.py: Custom storage implementation for TonConnect.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#configuration","title":"Configuration","text":""},{"location":"guide/ton-connect/telegram-bot-integration/#create-tonconnect-manifest","title":"Create TonConnect Manifest","text":"<p>Create a JSON file describing your application. This manifest is displayed in the wallet during connection.</p> <pre><code>{\n  \"url\": \"&lt;app-url&gt;\",                        // required\n  \"name\": \"&lt;app-name&gt;\",                      // required\n  \"iconUrl\": \"&lt;app-icon-url&gt;\",               // required\n  \"termsOfUseUrl\": \"&lt;terms-of-use-url&gt;\",     // optional\n  \"privacyPolicyUrl\": \"&lt;privacy-policy-url&gt;\" // optional\n}\n</code></pre> <p>Note</p> <p>Ensure this file is publicly accessible via its URL.</p>"},{"location":"guide/ton-connect/telegram-bot-integration/#storage-implementation","title":"Storage Implementation","text":"<p>TonConnect requires a storage system to manage its data. Here, we implement a Redis-based storage class.</p> <pre><code># storage.py\n\nfrom typing import Optional\n\nfrom redis.asyncio import Redis\n\nfrom tonutils.tonconnect import IStorage\n\n\nclass TCRedisStorage(IStorage):\n    def __init__(self, redis_client: Redis):\n        self.redis = redis_client\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        await self.redis.set(name=key, value=value)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        value = await self.redis.get(name=key)\n        return value.decode() if value else default_value\n\n    async def remove_item(self, key: str) -&gt; None:\n        await self.redis.delete(key)\n</code></pre>"},{"location":"guide/ton-connect/telegram-bot-integration/#initialization","title":"Initialization","text":"<p>Create a Python script and set up the initial configuration.</p> <pre><code># bot.py\n\nimport base64\nfrom contextlib import suppress\nfrom typing import List\n\nfrom aiogram import Dispatcher, Bot\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.filters import CommandStart\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.storage.redis import RedisStorage\nfrom aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, CallbackQuery\nfrom aiogram.utils.keyboard import InlineKeyboardBuilder\nfrom aiogram.utils.markdown import hide_link, hcode\nfrom redis.asyncio import Redis\n\nfrom storage import TCRedisStorage\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.models import WalletApp, Event, EventError, SendTransactionResponse\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\nfrom tonutils.wallet.data import TransferData\n\nBOT_TOKEN = \"your bot token\"\nREDIS_DSN = \"redis://localhost:6379\"\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize Redis\nredis = Redis.from_url(url=REDIS_DSN)\n\n# Initialize Dispatcher with Redis Storage\ndp = Dispatcher(storage=RedisStorage(redis))\n\n# Initialize Telegram Bot\nbot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=\"HTML\"))\n\n# Initialize TonConnect\ntc = TonConnect(storage=TCRedisStorage(redis), manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n</code></pre> <ul> <li>Redis Initialization: Establishes a connection to the Redis server.</li> <li>Dispatcher &amp; Bot Initialization: Sets up the dispatcher with Redis storage and initializes the bot.</li> <li>TonConnect Initialization: Sets up TonConnect with custom Redis storage and the manifest URL.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#bot-helper-functions","title":"Bot Helper Functions","text":""},{"location":"guide/ton-connect/telegram-bot-integration/#keyboards","title":"Keyboards","text":"<p>Functions to create various inline keyboards used in the bot.</p>"},{"location":"guide/ton-connect/telegram-bot-integration/#connect-wallet-keyboard","title":"Connect Wallet Keyboard","text":"<p>Creates an inline keyboard for selecting and connecting wallets.</p> <pre><code>def _connect_wallet_markup(\n        wallets: List[WalletApp],\n        selected_wallet: WalletApp,\n        connect_url: str,\n) -&gt; InlineKeyboardMarkup:\n    wallets_buttons = [\n        InlineKeyboardButton(\n            text=f\"\u2022 {wallet.name} \u2022\" if wallet.app_name == selected_wallet.app_name else wallet.name,\n            callback_data=f\"app_wallet:{wallet.app_name}\",\n        )\n        for wallet in wallets\n    ]\n    connect_wallet_button = InlineKeyboardButton(\n        text=f\"Connect {selected_wallet.name}\",\n        url=connect_url,\n    )\n    builder = InlineKeyboardBuilder()\n    builder.row(connect_wallet_button)\n    builder.row(*wallets_buttons, width=2)\n\n    return builder.as_markup()\n</code></pre> <ul> <li>Wallet Buttons: Lists available wallets, highlighting the selected one.</li> <li>Connect Button: Provides a direct link to connect the selected wallet.</li> <li>Layout: Uses <code>InlineKeyboardBuilder</code> to organize buttons neatly.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#confirm-transaction-keyboard","title":"Confirm Transaction Keyboard","text":"<p>Creates an inline keyboard for confirming or canceling a transaction.</p> <pre><code>def _confirm_transaction_markup(url: str, wallet_name: str) -&gt; InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(\n        inline_keyboard=[\n            [InlineKeyboardButton(text=f\"Open {wallet_name}\", url=url)],\n            [InlineKeyboardButton(text=\"Cancel\", callback_data=\"cancel_transaction\")],\n        ]\n    )\n</code></pre> <ul> <li>Open Wallet Button: Directs the user to their wallet for transaction confirmation.</li> <li>Cancel Button: Allows the user to cancel the pending transaction.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#choose-action-keyboard","title":"Choose Action Keyboard","text":"<p>Creates an inline keyboard for selecting actions after wallet connection.</p> <pre><code>def _choose_action_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Send transaction\", callback_data=\"send_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Send batch transaction\", callback_data=\"send_batch_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Disconnect wallet\", callback_data=\"disconnect_wallet\"))\n\n    return builder.as_markup()\n</code></pre> <ul> <li>Actions: Users can choose to send a single transaction, send multiple transactions in a batch, or disconnect their   wallet.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#go-to-main-menu-keyboard","title":"Go to Main Menu Keyboard","text":"<p>Creates an inline keyboard to navigate back to the main menu.</p> <pre><code>def _go_to_main_menu_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Main menu\", callback_data=\"main_menu\"))\n\n    return builder.as_markup()\n</code></pre> <ul> <li>Main Menu Button: Provides a way for users to return to the primary interface.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#windows","title":"Windows","text":"<p>Define various user interface windows that respond to user interactions and TonConnect events.</p>"},{"location":"guide/ton-connect/telegram-bot-integration/#connect-wallet-window","title":"Connect Wallet Window","text":"<p>Displays the wallet connection interface to the user.</p> <pre><code>async def connect_wallet_window(state: FSMContext, user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    state_data = await state.get_data()\n    wallets = await tc.get_wallets()\n\n    selected_wallet = state_data.get(\"selected_wallet\", wallets[0].app_name)\n    selected_wallet = next(wallet for wallet in wallets if wallet.app_name == selected_wallet)\n    connect_url = await connector.connect_wallet(wallet_app=selected_wallet)\n\n    qrcode_url = (\n        f\"https://qrcode.ness.su/create?\"\n        f\"box_size=20&amp;border=7&amp;image_padding=20\"\n        f\"&amp;data={base64.b64encode(connect_url.encode()).decode()}\"\n        f\"&amp;image_url={base64.b64encode(selected_wallet.image.encode()).decode()}\"\n    )\n\n    text = f\"{hide_link(qrcode_url)}Connect your wallet!\"\n    reply_markup = _connect_wallet_markup(wallets, selected_wallet, connect_url)\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>Connector Initialization: Prepares the TonConnect connector for the user.</li> <li>Wallet Selection: Retrieves available wallets and selects the preferred one.</li> <li>QR Code Generation: Generates a QR code URL for wallet connection.</li> <li>User Prompt: Sends a message prompting the user to connect their wallet with the appropriate inline keyboard.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#wallet-connected-window","title":"Wallet Connected Window","text":"<p>Displays the connected wallet information and available actions.</p> <pre><code>async def wallet_connected_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    wallet_address = connector.wallet.account.address.to_str(is_bounceable=False)\n\n    reply_markup = _choose_action_markup()\n    text = f\"Connected wallet:\\n{hcode(wallet_address)}\\n\\nChoose an action:\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>Wallet Information: Shows the connected wallet's address.</li> <li>Available Actions: Presents options to send transactions, send batch transactions, or disconnect the wallet.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#send-transaction-window","title":"Send Transaction Window","text":"<p>Prompts the user to confirm the transaction in their wallet.</p> <pre><code>async def send_transaction_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    reply_markup = _confirm_transaction_markup(\n        url=connector.wallet_app.direct_url,\n        wallet_name=connector.wallet_app.name,\n    )\n\n    text = \"Please confirm the transaction in your wallet.\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>User Prompt: Instructs the user to confirm the transaction within their wallet.</li> <li>Confirmation Options: Provides buttons to open the wallet or cancel the transaction.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#transaction-sent-window","title":"Transaction Sent Window","text":"<p>Displays the transaction details after a successful send.</p> <pre><code>async def transaction_sent_window(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    text = (\n        \"Transaction sent!\\n\\n\"\n        f\"Transaction msg hash:\\n{hcode(transaction.normalized_hash)}\\n\"\n        f\"Transaction BoC:\\n{hcode(transaction.boc)}\\n\"\n    )\n    reply_markup = _go_to_main_menu_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>Transaction Details: Provides the transaction hash and BoC (Bag of Cells) for reference.</li> <li>Navigation: Offers a button to return to the main menu.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#error-window","title":"Error Window","text":"<p>Displays error messages with an option to retry or go back.</p> <pre><code>async def error_window(user_id: int, message_text: str, button_text: str, callback_data: str) -&gt; None:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=button_text, callback_data=callback_data))\n    reply_markup = builder.as_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=message_text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>Error Message: Communicates the issue to the user.</li> <li>Retry Option: Provides a button to attempt the failed action again or navigate elsewhere.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#utils","title":"Utils","text":"<p>Function to delete the last message sent to the user to keep the chat clean.</p> <pre><code>async def delete_last_message(user_id: int, message_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    last_message_id = (await state.get_data()).get(\"last_message_id\")\n\n    if last_message_id is not None:\n        with suppress(Exception):\n            await bot.delete_message(chat_id=user_id, message_id=last_message_id)\n\n    await state.update_data(last_message_id=message_id)\n</code></pre> <ul> <li>Purpose: Ensures that only the latest message is visible to the user, enhancing the user experience by reducing   clutter.</li> <li>Functionality:<ul> <li>Retrieves the last message ID from the user's state data.</li> <li>Attempts to delete the last message if it exists.</li> <li>Updates the state with the new message ID.</li> </ul> </li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#tonconnect-handlers","title":"TonConnect handlers","text":"<p>TonConnect utilizes event-driven architecture to handle various wallet-related actions. This section outlines how to handle these events within your bot.</p>"},{"location":"guide/ton-connect/telegram-bot-integration/#connect-event","title":"Connect Event","text":"<p>Handler for successful wallet connection events.</p> <pre><code>@tc.on_event(Event.CONNECT)\nasync def connect_event(user_id: int) -&gt; None:\n    await wallet_connected_window(user_id)\n</code></pre> <ul> <li>Trigger: When a wallet is successfully connected.</li> <li>Action: Displays the connected wallet information and available actions to the user.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#connect-error-event","title":"Connect Error Event","text":"<p>Handler for wallet connection errors.</p> <pre><code>@tc.on_event(EventError.CONNECT)\nasync def connect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = \"You rejected the wallet connection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = \"Connection request timed out.\"\n    else:\n        message_text = f\"Connection error. Error: {error.message}\"\n    await error_window(user_id, message_text, button_text, callback_data)\n</code></pre> <ul> <li>Error Types:<ul> <li>UserRejectsError: User declined the connection.</li> <li>RequestTimeoutError: Connection request timed out.</li> <li>Other errors: Generic connection issues.</li> </ul> </li> <li>Action: Displays an error message with an option to retry.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#disconnect-event","title":"Disconnect Event","text":"<p>Handler for successful wallet disconnection events.</p> <pre><code>@tc.on_event(Event.DISCONNECT)\nasync def disconnect_event(user_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    await connect_wallet_window(state, user_id)\n</code></pre> <ul> <li>Trigger: When a wallet is successfully disconnected.</li> <li>Action: Prompts the user to reconnect their wallet.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#disconnect-error-event","title":"Disconnect Error Event","text":"<p>Handler for wallet disconnection errors.</p> <pre><code>@tc.on_event(EventError.DISCONNECT)\nasync def disconnect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = \"You rejected the wallet disconnection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = \"Disconnect request timed out.\"\n    else:\n        message_text = f\"Disconnect error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n</code></pre> <ul> <li>Error Types:<ul> <li>UserRejectsError: User declined the disconnection.</li> <li>RequestTimeoutError: Disconnection request timed out.</li> <li>Other errors: Generic disconnection issues.</li> </ul> </li> <li>Action: Displays an error message with an option to retry.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#transaction-event","title":"Transaction Event","text":"<p>Handler for successful transaction events.</p> <pre><code>@tc.on_event(Event.TRANSACTION)\nasync def transaction_event(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    await transaction_sent_window(user_id, transaction)\n</code></pre> <ul> <li>Trigger: When a transaction is successfully sent.</li> <li>Action: Displays transaction details to the user</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#transaction-error-event","title":"Transaction Error Event","text":"<p>Handler for transaction errors.</p> <pre><code>@tc.on_event(EventError.TRANSACTION)\nasync def transaction_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"main_menu\"\n    if isinstance(error, UserRejectsError):\n        message_text = \"You rejected the transaction.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = \"Transaction request timed out.\"\n    else:\n        message_text = f\"Transaction error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n</code></pre> <ul> <li>Error Types:<ul> <li>UserRejectsError: User declined the transaction.</li> <li>RequestTimeoutError: Transaction request timed out.</li> <li>Other errors: Generic transaction issues.</li> </ul> </li> <li>Action: Displays an error message with an option to return to the main menu.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#bot-handlers","title":"Bot handlers","text":"<p>Here's how the bot's functionalities come together in handling various scenarios.</p>"},{"location":"guide/ton-connect/telegram-bot-integration/#start-command-handler","title":"Start Command Handler","text":"<p>Handles the /start command to initiate the wallet connection process or display connected wallet actions.</p> <pre><code>@dp.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(message.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n    if connector.is_transaction_pending(rpc_request_id):\n        connector.cancel_pending_transaction(rpc_request_id)\n\n    if not connector.connected:\n        await connect_wallet_window(state, message.from_user.id)\n    else:\n        await wallet_connected_window(message.from_user.id)\n</code></pre> <ul> <li>Initialization: Prepares the connector for the user.</li> <li>Pending Transactions: Cancels any ongoing transactions to prevent conflicts.</li> <li>Connection Status: Determines whether to prompt for wallet connection or display available actions.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#callback-query-handler","title":"Callback Query Handler","text":"<p>Handles various callback queries from inline buttons.</p> <pre><code>@dp.callback_query()\nasync def callback_query_handler(callback_query: CallbackQuery, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(callback_query.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n\n    if callback_query.data.startswith(\"app_wallet:\"):\n        selected_wallet = callback_query.data.split(\":\")[1]\n        await state.update_data(selected_wallet=selected_wallet)\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"main_menu\":\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"connect_wallet\":\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"disconnect_wallet\":\n        connector.add_event_kwargs(Event.DISCONNECT, state=state)\n        await connector.disconnect_wallet()\n\n    elif callback_query.data == \"cancel_transaction\":\n        if connector.is_transaction_pending(rpc_request_id):\n            connector.cancel_pending_transaction(rpc_request_id)\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"send_transaction\":\n        rpc_request_id = await connector.send_transfer(\n            destination=connector.account.address,\n            amount=0.000000001,\n            body=\"Hello from tonutils!\",\n        )\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    elif callback_query.data == \"send_batch_transaction\":\n        transfer_data = [\n            TransferData(\n                destination=connector.account.address,\n                amount=0.000000001,\n                body=\"Hello from tonutils!\",\n            ) for _ in range(4)\n        ]\n        rpc_request_id = await connector.send_batch_transfer(transfer_data)\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    await callback_query.answer()\n</code></pre> <ul> <li>Wallet Selection (<code>app_wallet</code>:): Updates the selected wallet and prompts the user to reconnect.</li> <li>Main Menu (<code>main_menu</code>): Returns to the wallet connected window.</li> <li>Connect Wallet (<code>connect_wallet</code>): Initiates the wallet connection process.</li> <li>Disconnect Wallet (<code>disconnect_wallet</code>): Initiates the wallet disconnection process.</li> <li>Cancel Transaction (<code>cancel_transaction</code>): Cancels any pending transactions and returns to the connected wallet   window.</li> <li>Send Transaction (<code>send_transaction</code>): Initiates a single transaction and prompts the user to confirm.</li> <li>Send Batch Transaction (<code>send_batch_transaction</code>): Initiates multiple transactions in a batch and prompts the user   to confirm.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#running-the-bot","title":"Running the Bot","text":"<p>Finally, define the main entry point to start the bot.</p> <pre><code>async def main():\n    await dp.start_polling(bot)\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre> <ul> <li>Main Function: Starts polling to listen for incoming updates from Telegram.</li> <li>Entry Point: Ensures the bot starts when the script is executed directly.</li> </ul>"},{"location":"guide/ton-connect/telegram-bot-integration/#complete-example","title":"Complete Example","text":"<p>For reference, here's the complete <code>bot.py</code> script integrating all the components discussed above.</p> <pre><code># bot.py\nimport base64\nfrom contextlib import suppress\nfrom typing import List\n\nfrom aiogram import Dispatcher, Bot\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.filters import CommandStart\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.storage.redis import RedisStorage\nfrom aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, CallbackQuery\nfrom aiogram.utils.keyboard import InlineKeyboardBuilder\nfrom aiogram.utils.markdown import hide_link, hcode\nfrom redis.asyncio import Redis\n\nfrom storage import TCRedisStorage\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.models import WalletApp, Event, EventError, SendTransactionResponse\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\nfrom tonutils.wallet.data import TransferData\n\nBOT_TOKEN = \"your bot token\"\nREDIS_DSN = \"redis://localhost:6379\"\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\nredis = Redis.from_url(url=REDIS_DSN)\ndp = Dispatcher(storage=RedisStorage(redis))\nbot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=\"HTML\"))\ntc = TonConnect(storage=TCRedisStorage(redis), manifest_url=TC_MANIFEST_URL,\n                wallets_fallback_file_path=\"./wallets.json\")\n\n\nasync def delete_last_message(user_id: int, message_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    last_message_id = (await state.get_data()).get(\"last_message_id\")\n\n    if last_message_id is not None:\n        with suppress(Exception):\n            await bot.delete_message(chat_id=user_id, message_id=last_message_id)\n\n    await state.update_data(last_message_id=message_id)\n\n\ndef _connect_wallet_markup(\n        wallets: List[WalletApp],\n        selected_wallet: WalletApp,\n        connect_url: str,\n) -&gt; InlineKeyboardMarkup:\n    wallets_button = [\n        *[\n            InlineKeyboardButton(\n                text=f\"\u2022 {wallet.name} \u2022\" if wallet.app_name == selected_wallet.app_name else wallet.name,\n                callback_data=f\"app_wallet:{wallet.app_name}\",\n            ) for wallet in wallets\n        ]\n    ]\n    connect_wallet_button = InlineKeyboardButton(\n        text=f\"Connect {selected_wallet.name}\",\n        url=connect_url,\n    )\n    builder = InlineKeyboardBuilder()\n    builder.row(connect_wallet_button)\n    builder.row(*wallets_button, width=2)\n\n    return builder.as_markup()\n\n\ndef _confirm_transaction_markup(url: str, wallet_name: str) -&gt; InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(\n        inline_keyboard=[\n            [InlineKeyboardButton(text=f\"Open {wallet_name}\", url=url)],\n            [InlineKeyboardButton(text=f\"Cancel\", callback_data=\"cancel_transaction\")],\n        ]\n    )\n\n\ndef _choose_action_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Send transaction\", callback_data=\"send_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Send batch transaction\", callback_data=\"send_batch_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Disconnect wallet\", callback_data=\"disconnect_wallet\"))\n\n    return builder.as_markup()\n\n\ndef _go_to_main_menu_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Main menu\", callback_data=\"main_menu\"))\n\n    return builder.as_markup()\n\n\nasync def connect_wallet_window(state: FSMContext, user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    state_data = await state.get_data()\n    wallets = await tc.get_wallets()\n\n    selected_wallet = state_data.get(\"selected_wallet\", wallets[0].app_name)\n    selected_wallet = next(w for w in wallets if w.app_name == selected_wallet)\n    connect_url = await connector.connect_wallet(wallet_app=selected_wallet)\n\n    qrcode_url = (\n        f\"https://qrcode.ness.su/create?\"\n        f\"box_size=20&amp;border=7&amp;image_padding=20\"\n        f\"&amp;data={base64.b64encode(connect_url.encode()).decode()}\"\n        f\"&amp;image_url={base64.b64encode(selected_wallet.image.encode()).decode()}\"\n    )\n\n    text = f\"{hide_link(qrcode_url)}Connect your wallet!\"\n    reply_markup = _connect_wallet_markup(wallets, selected_wallet, connect_url)\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def wallet_connected_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    wallet_address = connector.wallet.account.address.to_str(is_bounceable=False)\n\n    reply_markup = _choose_action_markup()\n    text = f\"Connected wallet:\\n{hcode(wallet_address)}\\n\\nChoose an action:\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def send_transaction_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    reply_markup = _confirm_transaction_markup(\n        url=connector.wallet_app.direct_url,\n        wallet_name=connector.wallet_app.name,\n    )\n\n    text = \"Please confirm the transaction in your wallet.\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def transaction_sent_window(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    text = (\n        \"Transaction sent!\\n\\n\"\n        f\"Transaction msg hash:\\n{hcode(transaction.normalized_hash)}\\n\"\n        f\"Transaction BoC:\\n{hcode(transaction.boc)}\\n\"\n    )\n    reply_markup = _go_to_main_menu_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def error_window(user_id: int, message_text: str, button_text: str, callback_data: str) -&gt; None:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=button_text, callback_data=callback_data))\n    reply_markup = builder.as_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=message_text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\n@tc.on_event(Event.CONNECT)\nasync def connect_event(user_id: int) -&gt; None:\n    await wallet_connected_window(user_id)\n\n\n@tc.on_event(EventError.CONNECT)\nasync def connect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = f\"You rejected the wallet connection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = f\"Connection request timed out.\"\n    else:\n        message_text = f\"Connection error. Error: {error.message}\"\n    await error_window(user_id, message_text, button_text, callback_data)\n\n\n@tc.on_event(Event.DISCONNECT)\nasync def disconnect_event(user_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    await connect_wallet_window(state, user_id)\n\n\n@tc.on_event(EventError.DISCONNECT)\nasync def disconnect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = f\"You rejected the wallet disconnection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = f\"Disconnect request timed out.\"\n    else:\n        message_text = f\"Disconnect error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n\n\n@tc.on_event(Event.TRANSACTION)\nasync def transaction_event(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    await transaction_sent_window(user_id, transaction)\n\n\n@tc.on_event(EventError.TRANSACTION)\nasync def transaction_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"main_menu\"\n    if isinstance(error, UserRejectsError):\n        message_text = f\"You rejected the transaction.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = f\"Transaction request timed out.\"\n    else:\n        message_text = f\"Transaction error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n\n\n@dp.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(message.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n    if connector.is_transaction_pending(rpc_request_id):\n        connector.cancel_pending_transaction(rpc_request_id)\n\n    if not connector.connected:\n        await connect_wallet_window(state, message.from_user.id)\n    else:\n        await wallet_connected_window(message.from_user.id)\n\n\n@dp.callback_query()\nasync def callback_query_handler(callback_query: CallbackQuery, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(callback_query.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n\n    if callback_query.data.startswith(\"app_wallet:\"):\n        selected_wallet = callback_query.data.split(\":\")[1]\n        await state.update_data(selected_wallet=selected_wallet)\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"main_menu\":\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"connect_wallet\":\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"disconnect_wallet\":\n        connector.add_event_kwargs(Event.DISCONNECT, state=state)\n        await connector.disconnect_wallet()\n\n    elif callback_query.data == \"cancel_transaction\":\n        if connector.is_transaction_pending(rpc_request_id):\n            connector.cancel_pending_transaction(rpc_request_id)\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"send_transaction\":\n        rpc_request_id = await connector.send_transfer(\n            destination=connector.account.address,\n            amount=0.000000001,\n            body=\"Hello from tonutils!\",\n        )\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    elif callback_query.data == \"send_batch_transaction\":\n        transfer_data = [\n            TransferData(\n                destination=connector.account.address,\n                amount=0.000000001,\n                body=\"Hello from tonutils!\",\n            ) for _ in range(4)\n        ]\n        rpc_request_id = await connector.send_batch_transfer(transfer_data)\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    await callback_query.answer()\n\n\nasync def main():\n    await dp.start_polling(bot)\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/ton-connect/telegram-bot-integration/#conclusion","title":"Conclusion","text":"<p>By following this cookbook, you can successfully integrate TonConnect into your Telegram Bot, enabling seamless wallet connections and transaction management.</p>"},{"location":"guide/ton-connect/wallet-connection/","title":"Wallet Connection","text":"<p>This guide provides concise instructions to integrate and manage wallet connections using the <code>TonConnect</code> from the <code>tonutils</code> library. Whether you're a beginner or an experienced developer, this guide will help you implement wallet connectivity efficiently.</p>"},{"location":"guide/ton-connect/wallet-connection/#installation","title":"Installation","text":"<p>Install the necessary Python packages using <code>pip</code>:</p> <pre><code>pip install tonutils aiofiles\n</code></pre>"},{"location":"guide/ton-connect/wallet-connection/#configuration","title":"Configuration","text":""},{"location":"guide/ton-connect/wallet-connection/#create-tonconnect-manifest","title":"Create TonConnect Manifest","text":"<p>Create a JSON file describing your application. This manifest is displayed in the wallet during connection.</p> <pre><code>{\n  \"url\": \"&lt;app-url&gt;\",                        // required\n  \"name\": \"&lt;app-name&gt;\",                      // required\n  \"iconUrl\": \"&lt;app-icon-url&gt;\",               // required\n  \"termsOfUseUrl\": \"&lt;terms-of-use-url&gt;\",     // optional\n  \"privacyPolicyUrl\": \"&lt;privacy-policy-url&gt;\" // optional\n}\n</code></pre> <p>Note</p> <p>Ensure this file is publicly accessible via its URL.</p>"},{"location":"guide/ton-connect/wallet-connection/#storage-implementation","title":"Storage Implementation","text":"<p>The <code>FileStorage</code> class manages persistent storage of connection data using a JSON file.</p> <pre><code>import json\nimport os\nfrom asyncio import Lock\nfrom typing import Optional, Dict\n\nimport aiofiles\n\nfrom tonutils.tonconnect import IStorage\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n</code></pre>"},{"location":"guide/ton-connect/wallet-connection/#initialize-tonconnect","title":"Initialize TonConnect","text":"<p>Set up the TonConnect instance with the manifest URL and storage implementation.</p> <pre><code>from storage import FileStorage\n\nfrom tonutils.tonconnect import TonConnect\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n</code></pre>"},{"location":"guide/ton-connect/wallet-connection/#event-handling","title":"Event Handling","text":"<p>Handling events is essential for responding to wallet actions and errors. There are two primary methods to handle events: using decorators and using context managers.</p>"},{"location":"guide/ton-connect/wallet-connection/#using-decorators","title":"Using Decorators","text":"<p>Decorators associate event handlers with specific events. This method is straightforward and keeps your event handling logic organized.</p> <pre><code>@tc.on_event(Event.CONNECT)\nasync def on_wallet_connect(user_id: int, wallet: WalletInfo) -&gt; None:\n    wallet_address = wallet.account.address.to_str(is_bounceable=False)\n    print(f\"Wallet {wallet_address} connected to user {user_id}.\")\n</code></pre>"},{"location":"guide/ton-connect/wallet-connection/#using-context-managers","title":"Using Context Managers","text":"<p>Context managers provide a controlled environment for handling events, ensuring proper setup and teardown.</p> <pre><code>async with connector.connect_wallet_context() as response:\n    if isinstance(response, TonConnectError):\n        print(f\"Connection error: {response.message}\")\n    else:\n        print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n</code></pre>"},{"location":"guide/ton-connect/wallet-connection/#passing-additional-parameters","title":"Passing Additional Parameters","text":"<p>In some cases, you may want to provide custom data or context to your event handlers \u2014 for example, adding tags, notes, or extra flags.</p> <p>You can achieve this by using the <code>connector.add_event_kwargs</code> method, which attaches additional keyword arguments that will be passed into the handler alongside the default parameters.</p> <p>Step 1: Add Custom Parameters</p> <p>Call <code>add_event_kwargs</code> before triggering or waiting on an event:</p> <pre><code>connector.add_event_kwargs(\n    event=Event.CONNECT,\n    comment=\"Hello from tonutils!\",\n)\n</code></pre> <p>Step 2: Update the Event Handler to Receive Them</p> <p>Define the handler to accept these extra parameters:</p> <pre><code>@tc.on_event(Event.CONNECT)\nasync def on_wallet_connect(user_id: int, wallet: WalletInfo, comment: str) -&gt; None:\n    print(f\"Comment: {comment}\")\n</code></pre> <p>Key Points:</p> <ul> <li>You can attach multiple parameters (any keyword argument).</li> <li>The handler function must include matching parameter names.</li> <li>This mechanism works for all supported events (<code>CONNECT</code>, <code>DISCONNECT</code>, <code>TRANSACTION</code>, etc.).</li> </ul>"},{"location":"guide/ton-connect/wallet-connection/#complete-example","title":"Complete Example","text":"<p>Below is an example demonstrating connector initialization, event handling, and wallet management.</p> <pre><code>import json\nimport os\nfrom asyncio import Lock\nfrom typing import Dict, Optional\n\nimport aiofiles\n\nfrom tonutils.tonconnect import TonConnect, IStorage\nfrom tonutils.tonconnect.models import Event, EventError, WalletInfo\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"  # noqa\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n\n@tc.on_event(Event.CONNECT)\nasync def on_wallet_connect(user_id: int, wallet: WalletInfo) -&gt; None:\n    \"\"\"\n    Handler for successful wallet connection events.\n    Processes all successful wallet connections and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - wallet (WalletInfo): Wallet information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.CONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    Wallet details can be obtained from the following attributes:\n    - wallet.account (Account): Information about an account with an address, chain/network,\n                                wallet state_init, and optional public key information.\n    - wallet.ton_proof (TonProof): Verification details such as timestamp, domain information,\n                                   payload, and a signature.\n    - wallet.device (DeviceInfo): Information about a device associated with a wallet.\n    \"\"\"\n    wallet_address = wallet.account.address.to_str(is_bounceable=False)\n    print(f\"[CONNECT EVENT] Wallet {wallet_address} connected to user {user_id}.\")\n\n\n@tc.on_event(EventError.CONNECT)\nasync def on_wallet_connect_error(user_id: int, error: TonConnectError) -&gt; None:\n    \"\"\"\n    Handler for connection error events.\n    Processes all errors that occur when connecting wallets.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - error (TonConnectError): Error information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.CONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    The type of error can be determined using isinstance:\n    - UserRejectsError: User rejected the wallet connection.\n    - RequestTimeoutError: Wallet connection timed out.\n    \"\"\"\n    if isinstance(error, UserRejectsError):\n        print(f\"[CONNECT ERROR] User {user_id} rejected the wallet connection.\")\n    elif isinstance(error, RequestTimeoutError):\n        print(f\"[CONNECT ERROR] Connection request timed out for user {user_id}.\")\n    else:\n        print(f\"[CONNECT ERROR] Connection error for user {user_id}. Error: {error.message}\")\n\n\n@tc.on_event(Event.DISCONNECT)\nasync def on_wallet_disconnect(user_id: int, wallet: WalletInfo) -&gt; None:\n    \"\"\"\n    Handler for disconnected wallet events.\n    Processes all successful wallet disconnections and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - wallet (WalletInfo): Wallet information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.DISCONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n    \"\"\"\n    wallet_address = wallet.account.address.to_str(is_bounceable=False)\n    print(f\"[DISCONNECT EVENT] Wallet {wallet_address} disconnected from user {user_id}.\")\n\n\n@tc.on_event(EventError.DISCONNECT)\nasync def on_wallet_disconnect_error(user_id: int, error: TonConnectError) -&gt; None:\n    \"\"\"\n    Handler for disconnected wallet events.\n    Processes all successful wallet disconnections and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - error (TonConnectError): Error information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.DISCONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n    \"\"\"\n    if isinstance(error, RequestTimeoutError):\n        print(f\"[DISCONNECT ERROR] Disconnect request timed out for user {user_id}.\")\n    else:\n        print(f\"[DISCONNECT ERROR] Disconnect error for user {user_id}. Error: {error.message}\")\n\n\nasync def main() -&gt; None:\n    user_id = 12345  # Example user ID\n\n    # Initialize the connector for the user\n    connector = await tc.init_connector(user_id)\n\n    # Check if the wallet is already connected\n    if not connector.connected:\n        # Get all available wallets\n        wallets = await tc.get_wallets()\n\n        # As an example, we will select the wallet with index 1 (Tonkeeper)\n        selected_wallet = wallets[1]\n        connect_url = await connector.connect_wallet(selected_wallet)\n        print(f\"Please connect your wallet by visiting the following URL:\\n{connect_url}\")\n\n        # Add additional parameters to be passed to event handlers\n        connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")\n        # After this, you can use:\n        \"\"\"\n        @tc.on_event(Event.CONNECT)\n        async def on_wallet_connect(user_id: int, wallet: WalletInfo, comment: str) -&gt; None:...\n        \"\"\"\n\n        print(\"Waiting for wallet connection...\")\n        async with connector.connect_wallet_context() as response:\n            if isinstance(response, TonConnectError):\n                print(f\"Connection error: {response.message}\")\n            else:\n                print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n\n    else:\n        wallet_address = connector.account.address.to_str(is_bounceable=False)\n        print(f\"Wallet already connected: {wallet_address}\")\n\n        # Prompt the user to disconnect the wallet\n        user_input = input(\"Do you want to disconnect the wallet? (y/n): \").strip().lower()\n\n        if user_input == 'y':\n            # Disconnect the wallet\n            await connector.disconnect_wallet()\n            print(\"Wallet successfully disconnected.\")\n        else:\n            print(\"Wallet remains connected.\")\n\n    # Close all TonConnect connections\n    await tc.close_all()\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    try:\n        asyncio.run(main())\n    except (KeyboardInterrupt, SystemExit):\n        # Ensure all connections are closed in case of interruption\n        asyncio.run(tc.close_all())\n</code></pre>"},{"location":"guide/ton-connect/wallet-connection/#ton-proof-example","title":"Ton Proof Example","text":"<p>To confirm ownership of a wallet, use Ton Proof to validate signed payloads.</p> <pre><code>from storage import FileStorage\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError\nfrom tonutils.tonconnect.utils.proof import generate_proof_payload, verify_proof_payload\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n\nasync def main() -&gt; None:\n    user_id = 1  # Example user ID\n\n    # Initialize the connector for the user\n    connector = await tc.init_connector(user_id)\n\n    # Generate the proof payload\n    proof_payload = generate_proof_payload()\n\n    # Check if the wallet is already connected\n    if not connector.connected:\n        # Get all available wallets\n        wallets = await tc.get_wallets()\n\n        # As an example, we will select the wallet with index 1 (Tonkeeper)\n        selected_wallet = wallets[1]\n        connect_url = await connector.connect_wallet(selected_wallet, ton_proof=proof_payload)\n        print(f\"Please connect your wallet by visiting the following URL:\\n{connect_url}\")\n\n        print(\"Waiting for wallet connection...\")\n        async with connector.connect_wallet_context() as response:\n            if isinstance(response, TonConnectError):\n                print(f\"Connection error: {response.message}\")\n            else:\n                if verify_proof_payload(proof_payload, connector.wallet):\n                    print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n                else:\n                    await connector.disconnect_wallet()\n                    print(\"Proof verification failed.\")\n\n    else:\n        wallet_address = connector.account.address.to_str(is_bounceable=False)\n        print(f\"Wallet already connected: {wallet_address}\")\n\n        # Prompt the user to disconnect the wallet\n        user_input = input(\"Do you want to disconnect the wallet? (y/n): \").strip().lower()\n\n        if user_input == 'y':\n            # Disconnect the wallet\n            await connector.disconnect_wallet()\n            print(\"Wallet successfully disconnected.\")\n        else:\n            print(\"Wallet remains connected.\")\n\n    # Close all TonConnect connections\n    await tc.close_all()\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    try:\n        asyncio.run(main())\n    except (KeyboardInterrupt, SystemExit):\n        # Ensure all connections are closed in case of interruption\n        asyncio.run(tc.close_all())\n</code></pre>"},{"location":"guide/ton-connect/wallet-connection/#conclusion","title":"Conclusion","text":"<p>By following this cookbook, you can successfully integrate TonConnect into your script enabling seamless wallet connections.</p>"},{"location":"how-to/create-multiple-wallets/","title":"Create Multiple Wallets","text":"<p>This example shows how to generate multiple wallet addresses from a single mnemonic by changing the <code>subwallet_id</code>. Each <code>subwallet_id</code> produces a unique address under the same seed phrase.</p>"},{"location":"how-to/create-multiple-wallets/#example","title":"Example","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Subwallet ID\nWALLET_ID = 0\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC, WALLET_ID)\n\n    print(f\"Address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/create-multiple-wallets/#explanation","title":"Explanation","text":"<ul> <li><code>subwallet_id</code> \u2192 a 32-bit integer used to derive distinct wallet addresses from the same mnemonic.</li> <li> <p>Use cases:</p> <ul> <li>Splitting funds across logical accounts.</li> <li>Managing separate balances.</li> <li>Creating derived wallets for contract operations.</li> </ul> </li> </ul>"},{"location":"how-to/create-multiple-wallets/#important-notes","title":"Important Notes","text":"<ul> <li> <p><code>subwallet_id</code> (or <code>wallet_id</code>) is not supported in:</p> <ul> <li><code>WalletV2*</code></li> <li><code>PreprocessedWallet*</code></li> </ul> </li> <li> <p>Default <code>wallet_id</code> values:</p> <ul> <li>All wallet types except <code>WalletV5R1</code> \u2192 <code>698983191</code></li> <li> <p><code>WalletV5R1</code>:</p> global_id workchain wallet_version subwallet_number wallet_id -239 0 0 0 2147483409 -239 -1 0 0 8388369 -3 0 0 0 2147483645 -3 -1 0 0 8388605 </li> </ul> </li> </ul>"},{"location":"how-to/get-contract-code-and-data/","title":"Get Contract code and data","text":"<p>To retrieve the code and data of a contract, you can use TON explorers such as tonviewer.com, tonscan.org, and others, or use the <code>get_raw_account</code> method programmatically.</p>"},{"location":"how-to/get-contract-code-and-data/#using-ton-explorers","title":"Using TON explorers","text":"<ol> <li>Open Tonviewer.</li> <li>Enter the contract address into the search field.</li> <li>Navigate to the Code tab.</li> <li>The Bytecode section contains the contract code.</li> <li>The Raw data section contains the contract data.</li> </ol>"},{"location":"how-to/get-contract-code-and-data/#using-get_raw_account-method","title":"Using <code>get_raw_account</code> method","text":"<pre><code>from tonutils.client import ToncenterV3Client\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    contract_address = \"EQ...\"\n    account = await client.get_raw_account(contract_address)\n\n    # Print contract code (hex-encoded BOC)\n    print(account.code.to_boc().hex())\n\n    # Print contract data (hex-encoded BOC)\n    print(account.data.to_boc().hex())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre> <p>See RawAccount fields overview</p>"},{"location":"how-to/get-contract-information/","title":"Get Contract information","text":"<p>This example shows how to retrieve full contract details, including balance, status, code, data, and last transaction metadata.</p>"},{"location":"how-to/get-contract-information/#example","title":"Example","text":"<pre><code>from tonutils.client import ToncenterV3Client\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    contract_address = \"EQ...\"\n\n    contract = await client.get_raw_account(contract_address)\n\n    print(f\"Balance: {contract.balance}\")\n    print(f\"Status: {contract.status}\")\n    print(f\"Code: {contract.code}\")\n    print(f\"Data: {contract.data}\")\n    print(f\"Last Transaction LT: {contract.last_transaction_lt}\")\n    print(f\"Last Transaction Hash: {contract.last_transaction_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-contract-information/#rawaccount-fields-overview","title":"<code>RawAccount</code> fields overview","text":"<ul> <li> <p>balance \u2192 integer (in nanoTON)   Current balance of the contract.</p> </li> <li> <p>status \u2192 string   Contract status, one of:</p> <ul> <li><code>active</code> \u2192 contract exists and is active</li> <li><code>nonexist</code> \u2192 contract does not exist</li> <li><code>frozen</code> \u2192 contract is frozen</li> <li><code>uninit</code> \u2192 contract exists but is not initialized</li> </ul> </li> <li> <p>code \u2192 <code>Cell</code> (optional)   The contract\u2019s executable code (if present).</p> </li> <li> <p>data \u2192 <code>Cell</code> (optional)   The contract\u2019s persistent data (if present).</p> </li> <li> <p>last_transaction_lt \u2192 integer (optional)   Logical time (LT) of the most recent transaction.</p> </li> <li> <p>last_transaction_hash \u2192 string (optional)   Hash of the most recent transaction.</p> </li> <li> <p>state_init \u2192 <code>StateInit</code> (optional)   Combined object representing the full contract state if both code and data are available.</p> </li> </ul>"},{"location":"how-to/get-jetton-wallet-address/","title":"Get Jetton Wallet address","text":"<p>There are several ways to obtain the address of a Jetton Wallet.</p>"},{"location":"how-to/get-jetton-wallet-address/#standard-jetton","title":"Standard Jetton","text":""},{"location":"how-to/get-jetton-wallet-address/#using-get-method","title":"Using get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    owner_address = \"UQ...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = await JettonMasterStandard.get_wallet_address(\n        client,\n        owner_address,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-jetton-wallet-address/#calculating-locally","title":"Calculating locally","text":"<p>Note</p> <p>Prepare the Jetton Wallet contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.jetton import JettonMasterStandard\n\n\ndef main() -&gt; None:\n    owner_address = \"UQ...\"\n    jetton_wallet_code = \"...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = JettonMasterStandard.calculate_user_jetton_wallet_address(\n        owner_address,\n        jetton_wallet_code,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-jetton-wallet-address/#stablecoin-jetton","title":"Stablecoin Jetton","text":"<p>e.g., USD\u20ae, NOT</p>"},{"location":"how-to/get-jetton-wallet-address/#using-get-method_1","title":"Using get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    owner_address = \"UQ...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = await JettonMasterStablecoin.get_wallet_address(\n        client,\n        owner_address,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-jetton-wallet-address/#calculating-locally_1","title":"Calculating locally","text":"<p>Note</p> <p>Prepare the Jetton Wallet contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.jetton import JettonMasterStablecoin\n\n\ndef main() -&gt; None:\n    owner_address = \"UQ...\"\n    jetton_wallet_code = \"...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = JettonMasterStablecoin.calculate_user_jetton_wallet_address(\n        owner_address,\n        jetton_wallet_code,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-nft-item-address/","title":"Get NFT Item address","text":"<p>There are several ways to obtain the address of an NFT Item.</p>"},{"location":"how-to/get-nft-item-address/#standard-collections","title":"Standard collections","text":""},{"location":"how-to/get-nft-item-address/#using-get-method","title":"Using get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    nft_index = 1\n    collection_address = \"EQ...\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        nft_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-nft-item-address/#calculating-locally","title":"Calculating locally","text":"<p>Note</p> <p>Prepare the NFT Item contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.nft import Collection\n\n\ndef main() -&gt; None:\n    nft_index = 1\n    nft_item_code = \"...\"\n    collection_address = \"EQ...\"\n\n    nft_address = Collection.calculate_nft_item_address(\n        nft_index,\n        nft_item_code,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-nft-item-address/#ton-dns-domains-collection","title":"TON DNS Domains collection","text":"<p>Note</p> <p>The index is computed as <code>slice_hash(name)</code>. See Use FunC hash functions for details.</p>"},{"location":"how-to/get-nft-item-address/#using-get-method_1","title":"Using get-method","text":"<pre><code>from pytoniq_core import begin_cell\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\nfrom tonutils.utils import slice_hash\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    domain_name = \"temp\"\n    domain_index = slice_hash(begin_cell().store_string(domain_name))\n    collection_address = \"EQ...\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        domain_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-nft-item-address/#calculating-locally_1","title":"Calculating locally","text":"<p>Note</p> <p>Prepare the NFT Item contract code by following the instructions in Get Contract code and data.</p> <pre><code>from pytoniq_core import begin_cell\nfrom tonutils.nft import Collection\nfrom tonutils.utils import slice_hash\n\n\ndef main() -&gt; None:\n    domain_name = \"temp\"\n    domain_index = slice_hash(begin_cell().store_string(domain_name))\n    nft_item_code = \"...\"\n    collection_address = \"EQ...\"\n\n    nft_address = Collection.calculate_nft_item_address(\n        domain_index,\n        nft_item_code,\n        collection_address,\n        index_len=256,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-nft-item-address/#telegram-gifts-anonymous-telegram-numbers","title":"Telegram Gifts / Anonymous Telegram Numbers","text":"<p>Note</p> <p>The index is computed as <code>string_hash(telemint_token_name)</code>. See Use FunC hash functions for details.</p>"},{"location":"how-to/get-nft-item-address/#using-get-method_2","title":"Using get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\nfrom tonutils.utils import string_hash\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    telemint_token_name = \"8888888\"\n    token_index = string_hash(telemint_token_name)\n    collection_address = \"EQ...\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        token_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-nft-item-address/#calculating-locally_2","title":"Calculating locally","text":"<p>Note</p> <p>Prepare the NFT Item contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.nft import Collection\nfrom tonutils.utils import string_hash\n\n\ndef main() -&gt; None:\n    telemint_token_name = \"8888888\"\n    token_index = string_hash(telemint_token_name)\n    nft_item_code = \"...\"\n    collection_address = \"EQ...\"\n\n    nft_address = Collection.calculate_nft_item_address(\n        token_index,\n        nft_item_code,\n        collection_address,\n        index_len=256,\n        is_telemint_token=True,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/send-claim-mintless-jetton/","title":"Send/Claim Mintless jetton","text":"<p>This example contains information on how to claim or send mintless Jettons using <code>TonapiClient</code>.</p> <p>Note</p> <p>You need an API key from tonconsole.com.</p>"},{"location":"how-to/send-claim-mintless-jetton/#send-mintless-jetton","title":"Send Mintless Jetton","text":"<pre><code>from typing import Any, Dict, Union\n\nimport aiohttp\nfrom aiohttp import ClientResponseError\nfrom pytoniq_core import Address, Cell, Slice, StateInit, begin_cell\n\nfrom tonutils.client import TonapiClient\nfrom tonutils.jetton import JettonWalletStandard\nfrom tonutils.utils import to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# API key for accessing the Tonapi (obtainable from https://tonconsole.com)\nAPI_KEY = \"\"\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Comment for transfer payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = TonapiClient(api_key=API_KEY)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_data = await get_jetton(client, wallet.address.to_str())\n    if jetton_data is None:\n        raise Exception(\"Jetton data not found. Are there jettons in this wallet?\")\n\n    jetton_balance = int(jetton_data[\"balance\"])\n    custom_payload_api_uri = jetton_data[\"jetton\"][\"custom_payload_api_uri\"]\n    jetton_custom_payload = await get_payload(custom_payload_api_uri, wallet.address.to_str())\n    jetton_wallet_address = jetton_custom_payload[\"jetton_wallet\"]\n\n    if not await is_claimed(client, jetton_wallet_address):\n        custom_payload = Cell.one_from_boc(jetton_custom_payload[\"custom_payload\"])\n        state_init = StateInit.deserialize(Slice.one_from_boc(jetton_custom_payload[\"state_init\"]))\n    else:\n        custom_payload = state_init = None\n\n    body = JettonWalletStandard.build_transfer_body(\n        recipient_address=Address(DESTINATION_ADDRESS),\n        response_address=wallet.address,\n        jetton_amount=jetton_balance,\n        custom_payload=custom_payload,\n        forward_payload=(\n            begin_cell()\n            .store_uint(0, 32)\n            .store_snake_string(COMMENT)\n            .end_cell()\n        ),\n        forward_amount=1,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_wallet_address,\n        amount=0.1,\n        body=body,\n        state_init=state_init,\n        bounce=True,\n    )\n\n    print(f\"Successfully transferred {to_amount(jetton_balance)} jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nasync def get_jetton(client: TonapiClient, addr: str) -&gt; Union[Dict[str, Any], None]:\n    method = f\"/v2/accounts/{addr}/jettons\"\n    params = {\"supported_extensions\": \"custom_payload\"}\n    try:\n        result = await client._request(\"GET\", path=method, params=params)  # noqa\n        return next(\n            (b for b in result.get(\"balances\", [])\n             if Address(b[\"jetton\"][\"address\"]) == Address(JETTON_MASTER_ADDRESS)),\n            None\n        )\n    except Exception as e:\n        print(f\"Error fetching jetton data: {e}\")\n        return None\n\n\nasync def get_payload(api_uri: str, wallet_address: str) -&gt; Dict[str, Any]:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"{api_uri}/wallet/{wallet_address}\") as response:\n            response.raise_for_status()\n            return await response.json()\n\n\nasync def is_claimed(client: TonapiClient, jetton_addr: str) -&gt; bool:\n    try:\n        result = await client.run_get_method(jetton_addr, \"is_claimed\")\n        return bool(result[0])\n    except ClientResponseError as e:\n        if e.status == 404:\n            return False\n        raise\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/send-claim-mintless-jetton/#claim-mintless-jetton","title":"Claim Mintless Jetton","text":"<pre><code>from typing import Any, Dict, Union\n\nimport aiohttp\nfrom aiohttp import ClientResponseError\nfrom pytoniq_core import Address, Cell, Slice, StateInit\n\nfrom tonutils.client import TonapiClient\nfrom tonutils.jetton import JettonWalletStandard\nfrom tonutils.utils import to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# API key for accessing the Tonapi (obtainable from https://tonconsole.com)\nAPI_KEY = \"\"\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = TonapiClient(api_key=API_KEY)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_data = await get_jetton(client, wallet.address.to_str())\n    if jetton_data is None:\n        raise Exception(\"Jetton data not found. Are there jettons in this wallet?\")\n\n    jetton_balance = int(jetton_data[\"balance\"])\n    custom_payload_api_uri = jetton_data[\"jetton\"][\"custom_payload_api_uri\"]\n    jetton_custom_payload = await get_payload(custom_payload_api_uri, wallet.address.to_str())\n    jetton_wallet_address = jetton_custom_payload[\"jetton_wallet\"]\n\n    if not await is_claimed(client, jetton_wallet_address):\n        custom_payload = Cell.one_from_boc(jetton_custom_payload[\"custom_payload\"])\n        state_init = StateInit.deserialize(Slice.one_from_boc(jetton_custom_payload[\"state_init\"]))\n    else:\n        print(\"Jetton already claimed!\")\n        return\n\n    body = JettonWalletStandard.build_transfer_body(\n        recipient_address=wallet.address,\n        response_address=wallet.address,\n        jetton_amount=jetton_balance,\n        custom_payload=custom_payload,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_wallet_address,\n        amount=0.1,\n        body=body,\n        state_init=state_init,\n        bounce=True,\n    )\n\n    print(f\"Successfully claimed {to_amount(jetton_balance)} jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nasync def get_jetton(client: TonapiClient, addr: str) -&gt; Union[Dict[str, Any], None]:\n    method = f\"/v2/accounts/{addr}/jettons\"\n    params = {\"supported_extensions\": \"custom_payload\"}\n    try:\n        result = await client._request(\"GET\", path=method, params=params)  # noqa\n        return next(\n            (b for b in result.get(\"balances\", [])\n             if Address(b[\"jetton\"][\"address\"]) == Address(JETTON_MASTER_ADDRESS)),\n            None\n        )\n    except Exception as e:\n        print(f\"Error fetching jetton data: {e}\")\n        return None\n\n\nasync def get_payload(api_uri: str, wallet_address: str) -&gt; Dict[str, Any]:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"{api_uri}/wallet/{wallet_address}\") as response:\n            response.raise_for_status()\n            return await response.json()\n\n\nasync def is_claimed(client: TonapiClient, jetton_addr: str) -&gt; bool:\n    try:\n        result = await client.run_get_method(jetton_addr, \"is_claimed\")\n        return bool(result[0])\n    except ClientResponseError as e:\n        if e.status == 404:\n            return False\n        raise\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/send-encrypted-message/","title":"Send Encrypted message","text":"<p>This example shows how to send a TON transfer with an encrypted comment. The encrypted comment ensures the payload is securely delivered only to the intended recipient.</p>"},{"location":"how-to/send-encrypted-message/#example","title":"Example","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the recipient wallet\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Amount to transfer in TON\nTRANSFER_AMOUNT = 0.01\n\n# Comment to include in the transfer payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = await wallet.build_encrypted_comment_body(\n        text=COMMENT,\n        destination=DESTINATION_ADDRESS,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=DESTINATION_ADDRESS,\n        amount=TRANSFER_AMOUNT,\n        body=body,\n    )\n\n    print(f\"Successfully transferred {TRANSFER_AMOUNT} TON to address {DESTINATION_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/send-gasless-transaction/","title":"Send Gasless transaction","text":"<p>This example demonstrates how to send a gasless Jetton transfer.</p> <p>Note</p> <p>This method leverages the gasless relayer feature provided by tonapi.io. You must obtain an API key from tonconsole.com.</p>"},{"location":"how-to/send-gasless-transaction/#prerequisites","title":"Prerequisites","text":"<p>Install dependencies:</p> <pre><code>pip install pytonapi\n</code></pre>"},{"location":"how-to/send-gasless-transaction/#example","title":"Example","text":"<pre><code>from pytonapi import AsyncTonapi\nfrom pytoniq_core import Address, Cell\n\nfrom tonutils.client import TonapiClient\nfrom tonutils.jetton import JettonMasterStandard, JettonWalletStandard\nfrom tonutils.utils import to_nano\nfrom tonutils.wallet import WalletV5R1\n\n# API key for accessing the Tonapi (obtainable from https://tonconsole.com)\nAPI_KEY = \"\"\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to transfer (in base units, considering decimals)\nJETTON_AMOUNT = 0.01\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Amount for jetton transfer.\nBASE_JETTON_SEND_AMOUNT = 0.05\n\n\nasync def main() -&gt; None:\n    tonapi, client = AsyncTonapi(api_key=API_KEY), TonapiClient(api_key=API_KEY)\n    wallet, public_key, private_key, _ = WalletV5R1.from_mnemonic(client, MNEMONIC)\n\n    gasless_config = await tonapi.gasless.get_config()\n    relayer_address = Address(gasless_config.relay_address)\n\n    jetton_wallet_address = await JettonMasterStandard.get_wallet_address(\n        client=client,\n        owner_address=wallet.address,\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n    )\n    tether_transfer_body = JettonWalletStandard.build_transfer_body(\n        jetton_amount=to_nano(JETTON_AMOUNT, JETTON_DECIMALS),\n        recipient_address=Address(DESTINATION_ADDRESS),\n        response_address=relayer_address,\n        forward_amount=1,\n    )\n    message_to_estimate = wallet.create_internal_msg(\n        dest=jetton_wallet_address,\n        value=to_nano(BASE_JETTON_SEND_AMOUNT),\n        body=tether_transfer_body,\n    )\n\n    sign_raw_params = await tonapi.gasless.estimate_gas_price(\n        master_id=JETTON_MASTER_ADDRESS,\n        body={\n            \"wallet_address\": wallet.address.to_str(),\n            \"wallet_public_key\": public_key.hex(),\n            \"messages\": [\n                {\n                    \"boc\": message_to_estimate.serialize().to_boc().hex(),\n                }\n            ]\n        }\n    )\n\n    try:\n        seqno = await WalletV5R1.get_seqno(client, wallet.address)\n    except (Exception,):\n        seqno = 0\n\n    tether_transfer_for_send = wallet.create_signed_internal_msg(\n        messages=[\n            wallet.create_wallet_internal_message(\n                destination=Address(message.address),\n                value=int(message.amount),\n                body=Cell.one_from_boc(message.payload),\n            ) for message in sign_raw_params.messages\n        ],\n        seqno=seqno,\n        valid_until=sign_raw_params.valid_until,\n    )\n    ext_message = wallet.create_external_msg(\n        dest=wallet.address,\n        body=tether_transfer_for_send,\n        state_init=wallet.state_init if seqno == 0 else None,\n    )\n\n    await tonapi.gasless.send(\n        body={\n            \"wallet_public_key\": public_key.hex(),\n            \"boc\": ext_message.serialize().to_boc().hex(),\n        }\n    )\n\n    print(f\"A gasless transfer sent!\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/use-func-hash-functions/","title":"Use FunC hash functions","text":""},{"location":"how-to/use-func-hash-functions/#cell_hash","title":"cell_hash","text":"<p>Calculates the representation hash of the given cell <code>c</code> and returns it as a 256-bit unsigned integer <code>x</code>. This function is handy for signing and verifying signatures of arbitrary entities structured as a tree of cells.</p> <pre><code>from tonutils.utils import cell_hash\nfrom pytoniq_core import begin_cell\n\n\ndef main() -&gt; None:\n    c = begin_cell().store_string(\"ness\").end_cell()\n    x = cell_hash(c)\n    print(x)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/use-func-hash-functions/#slice_hash","title":"slice_hash","text":"<p>Computes the hash of the given slice <code>s</code> and returns it as a 256-bit unsigned integer <code>x</code>. The result is equivalent to creating a standard cell containing only the data and references from <code>s</code> and then computing its hash using <code>cell_hash</code>.</p> <pre><code>from tonutils.utils import slice_hash\nfrom pytoniq_core import begin_cell\n\n\ndef main() -&gt; None:\n    s = begin_cell().store_string(\"ness\")\n    x = slice_hash(s)\n    print(x)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/use-func-hash-functions/#string_hash","title":"string_hash","text":"<p>Calculates the SHA-256 hash of the data bits in the given slice <code>s</code>. A cell underflow exception is thrown if the bit length of <code>s</code> is not a multiple of eight. The hash is returned as a 256-bit unsigned integer <code>x</code>.</p> <pre><code>from tonutils.utils import string_hash\n\n\ndef main() -&gt; None:\n    s = \"ness\"\n    x = string_hash(s)\n    print(x)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/","title":"\u041e\u0431\u0437\u043e\u0440","text":"<p>Tonutils \u2014 \u044d\u0442\u043e \u0432\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u0430\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043d\u043e-\u043e\u0440\u0438\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u043d\u0430 Python, \u043f\u0440\u0435\u0434\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u043d\u0430\u044f \u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0441 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u043e\u043c TON. \u041e\u043d\u0430 \u0438\u043d\u0442\u0435\u0433\u0440\u0438\u0440\u0443\u0435\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0445 \u0441\u0435\u0440\u0432\u0438\u0441\u043e\u0432 \u0438 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u043e\u0432, \u0432\u043a\u043b\u044e\u0447\u0430\u044f:</p> <p>RPC API</p> <ul> <li>tonapi.io \u2014 REST API \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u0434\u0430\u043d\u043d\u044b\u043c \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u0430 TON.</li> <li>toncenter.com \u2014 \u0431\u044b\u0441\u0442\u0440\u044b\u0439 \u0438 \u043d\u0430\u0434\u0451\u0436\u043d\u044b\u0439 HTTP API \u0434\u043b\u044f The Open Network.</li> <li>quicknode.com \u2014 \u0438\u043d\u0444\u0440\u0430\u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0441 \u043d\u0438\u0437\u043a\u043e\u0439 \u0437\u0430\u0434\u0435\u0440\u0436\u043a\u043e\u0439 \u0434\u043b\u044f HTTP-\u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a TON.</li> <li>tatum.io \u2014 RPC \u0438 API \u0434\u043b\u044f Web3-\u043f\u0440\u043e\u0435\u043a\u0442\u043e\u0432: \u0431\u044b\u0441\u0442\u0440\u044b\u0435, \u043d\u0430\u0434\u0451\u0436\u043d\u044b\u0435, \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435.</li> </ul> <p>\u041d\u0430\u0442\u0438\u0432\u043d\u044b\u0439 ADNL</p> <ul> <li>pytoniq \u2014 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u043f\u0440\u044f\u043c\u043e\u0433\u043e \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0441 \u043b\u0430\u0439\u0442-\u0441\u0435\u0440\u0432\u0435\u0440\u0430\u043c\u0438 TON.</li> </ul> <p>Tonutils \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u044f\u0435\u0442 \u044d\u0442\u0438 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0432 \u043c\u043e\u0449\u043d\u044b\u0439 \u0438 \u0433\u0438\u0431\u043a\u0438\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u0434\u043b\u044f \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u0432, \u043e\u0431\u043b\u0435\u0433\u0447\u0430\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439 \u043d\u0430 \u0431\u0430\u0437\u0435 \u044d\u043a\u043e\u0441\u0438\u0441\u0442\u0435\u043c\u044b TON.</p> <p>Note</p> <p>\u0414\u043b\u044f \u043d\u0430\u0434\u0451\u0436\u043d\u043e\u0433\u043e \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u0430 \u2014 \u0442\u0430\u043a\u0438\u0445 \u043a\u0430\u043a \u0441\u043f\u0438\u0441\u043a\u0438 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439, \u0441\u043f\u0438\u0441\u043a\u0438 NFT, \u0438\u0445 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438 \u0442.\u043f. \u2014 \u043d\u0430\u0441\u0442\u043e\u044f\u0442\u0435\u043b\u044c\u043d\u043e \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u0442\u0441\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0438\u043d\u0434\u0435\u043a\u0441\u0438\u0440\u0443\u044e\u0449\u0438\u0435 API, \u0442\u0430\u043a\u0438\u0435 \u043a\u0430\u043a Toncenter, Tonapi \u0438 \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u044b\u0435 \u0441\u0435\u0440\u0432\u0438\u0441\u044b. \u0414\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 Tonapi \u0442\u0430\u043a\u0436\u0435 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430 \u043c\u043e\u044f \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u043d\u0430 Python: pytonapi.</p>"},{"location":"ru/#_1","title":"\u0412\u043a\u043b\u0430\u0434 \u0432 \u043f\u0440\u043e\u0435\u043a\u0442","text":"<p>\u0412\u0430\u0448 \u0432\u043a\u043b\u0430\u0434 \u043f\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u0442\u0441\u044f! \u0415\u0441\u043b\u0438 \u0443 \u0432\u0430\u0441 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043b\u0443\u0447\u0448\u0435\u043d\u0438\u044e \u0438\u043b\u0438 \u0432\u044b \u043d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443, \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 issue \u0438\u043b\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u044c\u0442\u0435 pull request \u043d\u0430 GitHub.</p> <p>Note</p> <p>\u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438. \u0420\u0430\u0437\u0434\u0435\u043b\u044b \u0438 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u044b \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u044f\u044e\u0442\u0441\u044f. \u041d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0447\u0430\u0441\u0442\u0438 \u043c\u043e\u0433\u0443\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u043d\u0435\u0442\u043e\u0447\u043d\u043e\u0441\u0442\u0438 \u0438\u043b\u0438 \u0431\u044b\u0442\u044c \u043d\u0435\u043f\u043e\u043b\u043d\u044b\u043c\u0438 \u2014 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e.</p>"},{"location":"ru/donate/","title":"\u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0430\u0442\u044c","text":"<p>\u0411\u043b\u0430\u0433\u043e\u0434\u0430\u0440\u044e \u0437\u0430 \u0438\u043d\u0442\u0435\u0440\u0435\u0441 \u043a \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0435 \u043c\u043e\u0435\u0439 \u0440\u0430\u0431\u043e\u0442\u044b! \u0412\u0430\u0448 \u0432\u043a\u043b\u0430\u0434 \u043f\u043e\u043c\u043e\u0433\u0430\u0435\u0442 \u043c\u043d\u0435 \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0430\u0442\u044c \u0440\u0430\u0437\u0432\u0438\u0442\u0438\u0435 \u0438 \u0443\u043b\u0443\u0447\u0448\u0435\u043d\u0438\u0435 \u044d\u0442\u043e\u0433\u043e \u043f\u0440\u043e\u0435\u043a\u0442\u0430. \u2764\ufe0f</p>"},{"location":"ru/donate/#_1","title":"\u041f\u0440\u044f\u043c\u044b\u0435 \u0434\u043e\u043d\u0430\u0442\u044b \u043d\u0430 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0438","text":"<p>\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u0434\u043e\u043d\u0430\u0442 \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u043d\u0430 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0430\u0434\u0440\u0435\u0441\u0430:</p> <ul> <li> <p>TON <code>UQCZq3_Vd21-4y4m7Wc-ej9NFOhh_qvdfAkAYAOHoQ__Ness</code></p> </li> <li> <p>BTC <code>1FKJDBSxdtsMad84iYY96zLJBVEChehbx1</code></p> </li> <li> <p>USDT (TRC-20) <code>TGKmm9H3FApFw8xcgRcZDHSku68vozAjo9</code></p> </li> </ul>"},{"location":"ru/donate/#_2","title":"\u0414\u043e\u043d\u0430\u0442\u044b \u0447\u0435\u0440\u0435\u0437 \u0431\u043e\u0442\u043e\u0432","text":"<p>\u0422\u0430\u043a\u0436\u0435 \u043c\u043e\u0436\u043d\u043e \u0443\u0434\u043e\u0431\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u0434\u043e\u043d\u0430\u0442 \u0447\u0435\u0440\u0435\u0437 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0431\u043e\u0442\u043e\u0432:</p> <ul> <li> <p>Crypto Bot \u0414\u043e\u043d\u0430\u0442 \u0447\u0435\u0440\u0435\u0437 Crypto Bot</p> </li> <li> <p>xRocket Bot \u0414\u043e\u043d\u0430\u0442 \u0447\u0435\u0440\u0435\u0437 xRocket</p> </li> </ul>"},{"location":"ru/sponsors/","title":"\u0421\u043f\u043e\u043d\u0441\u043e\u0440\u044b","text":"<p>\u042f \u0438\u0441\u043a\u0440\u0435\u043d\u043d\u0435 \u0431\u043b\u0430\u0433\u043e\u0434\u0430\u0440\u044e \u0432\u0441\u0435\u0445, \u043a\u0442\u043e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442. \u2764\ufe0f</p>"},{"location":"ru/sponsors/#_2","title":"\u041f\u0440\u0438 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0435","text":"<ul> <li> <p>TON Society   \u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 Grants and Bounties.</p> </li> <li> <p>TONAPI   \u041f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0432\u0430\u0436\u043d\u0443\u044e \u0438\u043d\u0444\u0440\u0430\u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u0438 API-\u0441\u0435\u0440\u0432\u0438\u0441\u044b.</p> </li> </ul>"},{"location":"ru/sponsors/#_3","title":"\u041e\u0441\u043e\u0431\u0430\u044f \u0431\u043b\u0430\u0433\u043e\u0434\u0430\u0440\u043d\u043e\u0441\u0442\u044c","text":"<ul> <li>Igroman787 </li> <li>Roman Inozemtsev </li> <li>Cron </li> </ul>"},{"location":"ru/sponsors/#_4","title":"\u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0430\u0432\u0448\u0438\u0435","text":"<p>\u0421\u043f\u0430\u0441\u0438\u0431\u043e \u0432\u0441\u0435\u043c, \u043a\u0442\u043e \u043a\u043e\u0433\u0434\u0430-\u043b\u0438\u0431\u043e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u043b \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442!</p> <ul> <li><code>svatoshscammer.ton</code> </li> <li><code>vtonsdk.t.me</code></li> </ul>"},{"location":"ru/sponsors/#_5","title":"\u0425\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0430\u0442\u044c?","text":"<p>\u0415\u0441\u043b\u0438 \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u043c\u043e\u044e \u0440\u0430\u0431\u043e\u0442\u0443 \u2014 \u043f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u043d\u0430 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443 \u0434\u043e\u043d\u0430\u0442\u043e\u0432. \u0412\u0430\u0448\u0430 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 \u043f\u043e\u043c\u043e\u0433\u0430\u0435\u0442 \u043f\u0440\u043e\u0435\u043a\u0442\u0443 \u0440\u0430\u0437\u0432\u0438\u0432\u0430\u0442\u044c\u0441\u044f \u0438 \u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c\u0441\u044f \u043b\u0443\u0447\u0448\u0435.</p>"},{"location":"ru/cookbook/cnft/","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0436\u0430\u0442\u044b\u0445 NFT","text":""},{"location":"ru/cookbook/cnft/#_1","title":"\u0412\u0432\u0435\u0434\u0435\u043d\u0438\u0435","text":"<p>\u042d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u0437\u043d\u0430\u043a\u043e\u043c\u0438\u0442 \u0441 \u043a\u043e\u043d\u0446\u0435\u043f\u0446\u0438\u0435\u0439 \u0441\u0436\u0430\u0442\u044b\u0445 NFT (cNFT) \u0432 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u0435 TON \u2014 \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u043e\u043c \u0446\u0438\u0444\u0440\u043e\u0432\u044b\u0445 \u0430\u043a\u0442\u0438\u0432\u043e\u0432, \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u043e\u0432 \u0441\u0436\u0430\u0442\u0438\u044f \u0438 \u0434\u0435\u0440\u0435\u0432\u044c\u0435\u0432 \u041c\u0435\u0440\u043a\u043b\u0430. \u0417\u0434\u0435\u0441\u044c \u043e\u0431\u044a\u044f\u0441\u043d\u044f\u0435\u0442\u0441\u044f, \u043a\u0430\u043a cNFT \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044e\u0442 \u0441\u043d\u0438\u0436\u0430\u0442\u044c \u0437\u0430\u0442\u0440\u0430\u0442\u044b \u043d\u0430 \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u0440\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0438 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c\u043e\u0441\u0442\u0438, \u0430 \u0442\u0430\u043a\u0436\u0435 \u043f\u0440\u0438\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u043f\u0440\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0448\u0430\u0433\u0438 \u043f\u043e \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u044e \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044e \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u0438\u0440\u0443\u0435\u043c\u044b\u043c\u0438 NFT-\u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f\u043c\u0438.</p>"},{"location":"ru/cookbook/cnft/#_2","title":"\u041e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438","text":"<ul> <li>\u042d\u043a\u043e\u043d\u043e\u043c\u0438\u044f \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432: \u0414\u0435\u0440\u0435\u0432\u044c\u044f \u041c\u0435\u0440\u043a\u043b\u0430 \u0445\u0440\u0430\u043d\u044f\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435, \u0441\u043d\u0438\u0436\u0430\u044f \u0440\u0430\u0441\u0445\u043e\u0434\u044b \u043d\u0430 \u0433\u0430\u0437 \u0438 \u043d\u0430\u0433\u0440\u0443\u0437\u043a\u0443 \u043d\u0430 \u0441\u0435\u0442\u044c.</li> <li>\u0423\u043b\u0443\u0447\u0448\u0435\u043d\u043d\u0430\u044f \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u0438\u0440\u0443\u0435\u043c\u043e\u0441\u0442\u044c: \u042d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u0435 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u044b \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u044e\u0442 \u0431\u043e\u043b\u044c\u0448\u0438\u0435 \u043e\u0431\u044a\u0451\u043c\u044b NFT \u0431\u0435\u0437 \u043f\u043e\u0442\u0435\u0440\u0438 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438.</li> <li>\u041e\u043f\u0442\u0438\u043c\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0445: \u041c\u0438\u043d\u0438\u043c\u0438\u0437\u0430\u0446\u0438\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043d\u0430 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u0435 \u0443\u0441\u043a\u043e\u0440\u044f\u0435\u0442 \u0440\u0430\u0431\u043e\u0442\u0443 \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u0438 \u044d\u043a\u043e\u043d\u043e\u043c\u0438\u0442 \u043c\u0435\u0441\u0442\u043e.</li> <li>\u041f\u043e\u0432\u044b\u0448\u0435\u043d\u043d\u0430\u044f \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u044c: \u0414\u0435\u0440\u0435\u0432\u044c\u044f \u041c\u0435\u0440\u043a\u043b\u0430 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u044e\u0442 \u0431\u044b\u0441\u0442\u0440\u044b\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u0446\u0435\u043b\u043e\u0441\u0442\u043d\u043e\u0441\u0442\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438 \u043d\u0430\u0434\u0451\u0436\u043d\u0443\u044e \u0437\u0430\u0449\u0438\u0442\u0443 \u0430\u043a\u0442\u0438\u0432\u043e\u0432.</li> <li>\u0421\u043d\u0438\u0436\u0435\u043d\u0438\u0435 \u0437\u0430\u0442\u0440\u0430\u0442: \u041f\u0435\u0440\u0435\u043d\u043e\u0441 \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u0438 \u0432\u044b\u043f\u0443\u0441\u043a\u0430 \u043d\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u201c\u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0445\u201d on-chain \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438.</li> </ul>"},{"location":"ru/cookbook/cnft/#_3","title":"\u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430","text":"<p>\u0422\u0435\u043a\u0443\u0449\u0438\u0435 \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f \u0411\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u043e \u043f\u043e\u043f\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0438 \u043c\u0430\u0440\u043a\u0435\u0442\u043f\u043b\u0435\u0439\u0441\u043e\u0432 \u043d\u0435 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0442 \u043d\u0435\u0437\u0430\u0442\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u043d\u044b\u0435 cNFT \u0438\u043b\u0438 NFT \u0438\u0437 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0439, \u043d\u0435 \u044f\u0432\u043b\u044f\u044e\u0449\u0438\u0445\u0441\u044f \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u043c\u0438 \u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430\u043c\u0438. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, Telegram Wallet \u0438 \u043c\u0430\u0440\u043a\u0435\u0442\u043f\u043b\u0435\u0439\u0441 Getgems \u0438\u043d\u0434\u0435\u043a\u0441\u0438\u0440\u0443\u044e\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0435\u0440\u0432\u044b\u0435 200 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0434\u043b\u044f \u043d\u0435\u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0445 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0439, \u0447\u0442\u043e \u0441\u043e\u0437\u0434\u0430\u0451\u0442 \u0442\u0440\u0443\u0434\u043d\u043e\u0441\u0442\u0438 \u043f\u0440\u0438 \u0440\u0430\u0431\u043e\u0442\u0435 \u0441 \u043a\u0440\u0443\u043f\u043d\u044b\u043c\u0438 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f\u043c\u0438.</p> <p>\u0421\u0446\u0435\u043d\u0430\u0440\u0438\u0439 \u0430\u0442\u0430\u043a\u0438 \u0417\u043b\u043e\u0443\u043c\u044b\u0448\u043b\u0435\u043d\u043d\u0438\u043a \u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0441\u043e\u0442\u043d\u0438 \u0442\u044b\u0441\u044f\u0447 NFT \u0441 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u043c\u0438 \u0437\u0430\u0442\u0440\u0430\u0442\u0430\u043c\u0438, \u0432\u044b\u043d\u0443\u0436\u0434\u0430\u044f \u043c\u0430\u0440\u043a\u0435\u0442\u043f\u043b\u0435\u0439\u0441\u044b \u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0441\u043e\u043f\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u2014 \u0434\u0430\u0436\u0435 \u0435\u0441\u043b\u0438 \u0441\u0430\u043c\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043d\u0435 \u0440\u0430\u0437\u043c\u0435\u0449\u0435\u043d\u044b, \u0430 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u043f\u043e \u0442\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044e.</p> <p>\u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0435 \u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u041f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441, \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0438 \u0441\u043c\u043e\u0433\u0443\u0442 \u0441\u0430\u043c\u043e\u0441\u0442\u043e\u044f\u0442\u0435\u043b\u044c\u043d\u043e \u00ab\u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044c\u00bb (claim) \u0441\u0432\u043e\u0438 cNFT. \u041f\u043e\u0441\u043b\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 NFT \u0438\u043d\u0434\u0435\u043a\u0441\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0442\u0441\u044f \u0432 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430\u0445 \u0438 \u043d\u0430 \u043c\u0430\u0440\u043a\u0435\u0442\u043f\u043b\u0435\u0439\u0441\u0430\u0445 \u043a\u0430\u043a \u043e\u0431\u044b\u0447\u043d\u044b\u0435 NFT, \u0447\u0442\u043e \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0435\u0442 \u043b\u0443\u0447\u0448\u0443\u044e \u0432\u0438\u0434\u0438\u043c\u043e\u0441\u0442\u044c \u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0441\u0442\u044c.</p>"},{"location":"ru/cookbook/cnft/#_4","title":"\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u0438 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435","text":""},{"location":"ru/cookbook/cnft/#nft","title":"\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 NFT","text":"<p>\u041f\u0435\u0440\u0435\u0434 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u0438\u0442\u044c \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0432\u0430\u0448\u0438\u0445 NFT.</p>"},{"location":"ru/cookbook/cnft/#_5","title":"\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0445","text":"<ul> <li> <p>\u041c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0435 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438   \u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0430\u0439\u043b <code>collection.json</code>, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u043e\u043b\u044f \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441\u043e \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043e\u043c \u0434\u0430\u043d\u043d\u044b\u0445 NFT-\u0442\u043e\u043a\u0435\u043d\u043e\u0432.   \u041f\u0440\u0438\u043c\u0435\u0440:</p> <pre><code>{\n    \"name\": \"&lt;collection name&gt;\",\n    \"description\": \"&lt;collection description&gt;\",\n    \"image\": \"&lt;link to the image (e.g. https://yourdomain.com/logo.png)&gt;\"\n}\n</code></pre> </li> <li> <p>\u041c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0435 NFT-\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432   \u0414\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e NFT \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 JSON-\u0444\u0430\u0439\u043b (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, <code>0.json</code>, <code>1.json</code> \u0438 \u0442.\u0434.) \u0441 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u043c\u0438 \u043f\u043e\u043b\u044f\u043c\u0438, \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u043c\u0438 \u0432 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 NFT-\u0442\u043e\u043a\u0435\u043d\u043e\u0432.   \u041f\u0440\u0438\u043c\u0435\u0440:</p> <pre><code>{\n    \"name\": \"&lt;item name&gt;\",\n    \"description\": \"&lt;item description&gt;\",\n    \"image\": \"&lt;link to the image (e.g. https://yourdomain.com/0.png)&gt;\"\n}\n</code></pre> </li> </ul>"},{"location":"ru/cookbook/cnft/#_6","title":"\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432","text":"<ul> <li>\u0418\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f: \u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u044c\u0442\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, <code>logo.png</code> \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0432\u0430\u0442\u0430\u0440\u0430) \u0438 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e NFT (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, <code>0.png</code>, <code>1.png</code> \u0438 \u0442.\u0434.).</li> <li>JSON-\u0444\u0430\u0439\u043b\u044b: \u0420\u0430\u0437\u043c\u0435\u0441\u0442\u0438\u0442\u0435 \u0444\u0430\u0439\u043b <code>collection.json</code> \u0438 JSON-\u0444\u0430\u0439\u043b\u044b \u0434\u043b\u044f NFT \u043d\u0430 \u043e\u0431\u0449\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u043c \u0441\u0435\u0440\u0432\u0435\u0440\u0435 \u0438\u043b\u0438 \u0432 \u0440\u0435\u043f\u043e\u0437\u0438\u0442\u043e\u0440\u0438\u0438. \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u0443 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0439 URL.</li> </ul> <p>Note</p> <p>\u0412\u0441\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0438 JSON-\u0444\u0430\u0439\u043b\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u043f\u043e \u0441\u0432\u043e\u0438\u043c URL-\u0430\u0434\u0440\u0435\u0441\u0430\u043c.</p>"},{"location":"ru/cookbook/cnft/#tc","title":"\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442\u0430 TC","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 JSON-\u0444\u0430\u0439\u043b \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442\u0430 TON Connect, \u043e\u043f\u0438\u0441\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u0432\u0430\u0448\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430. \u041f\u0440\u0438\u043c\u0435\u0440:</p> <pre><code>{\n  \"url\": \"&lt;app url&gt;\",\n  \"name\": \"&lt;app name&gt;\",\n  \"iconUrl\": \"&lt;app icon url&gt;\"\n}\n</code></pre> <p>Note</p> <p>\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u0434\u0430\u043d\u043d\u044b\u0439 \u0444\u0430\u0439\u043b \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043f\u043e URL-\u0430\u0434\u0440\u0435\u0441\u0443 \u0432 \u043e\u0442\u043a\u0440\u044b\u0442\u043e\u043c \u0434\u043e\u0441\u0442\u0443\u043f\u0435.</p>"},{"location":"ru/cookbook/cnft/#_7","title":"\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u0441\u043f\u0438\u0441\u043a\u0430 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0435\u0432","text":"<p>\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u044c\u0442\u0435 \u0444\u0430\u0439\u043b <code>owners.txt</code>, \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u0443\u043a\u0430\u0436\u0438\u0442\u0435 \u0430\u0434\u0440\u0435\u0441\u0430 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0435\u0432 NFT \u2014 \u043f\u043e \u043e\u0434\u043d\u043e\u043c\u0443 \u0430\u0434\u0440\u0435\u0441\u0443 \u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0443. \u041f\u0435\u0440\u0432\u044b\u0439 \u0430\u0434\u0440\u0435\u0441 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u0441 \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u043c <code>0</code>, \u0432\u0442\u043e\u0440\u043e\u0439 \u2014 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u0441 \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u043c <code>1</code> \u0438 \u0442.\u0434. \u041f\u0440\u0438\u043c\u0435\u0440:</p> <pre><code>UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K\nUQCDrgGaI6gWK-qlyw69xWZosurGxrpRgIgSkVsgahUtxZR0\n</code></pre>"},{"location":"ru/cookbook/cnft/#_8","title":"\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u0438\u043d\u0444\u0440\u0430\u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b","text":"<p>\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u0440\u0430\u0437\u043c\u0435\u0449\u0435\u043d\u0438\u044f \u0432\u0430\u0448\u0435\u0433\u043e API \u0438 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 (claim) NFT. \u0422\u0430\u043a\u0436\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u0435 \u0434\u043e\u043c\u0435\u043d\u043d\u043e\u0435 \u0438\u043c\u044f \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a API. \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u0435 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0435 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043d\u0430 \u0434\u043e\u043c\u0430\u0448\u043d\u0435\u043c \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u0435 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e ngrok \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043f\u0443\u0431\u043b\u0438\u0447\u043d\u043e\u0433\u043e URL.</p>"},{"location":"ru/cookbook/cnft/#api-nft","title":"\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 API \u0434\u043b\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430 NFT","text":"<ol> <li> <p>\u041a\u043b\u043e\u043d\u0438\u0440\u0443\u0439\u0442\u0435 \u0440\u0435\u043f\u043e\u0437\u0438\u0442\u043e\u0440\u0438\u0439    \u041a\u043b\u043e\u043d\u0438\u0440\u0443\u0439\u0442\u0435 \u043f\u0440\u043e\u0435\u043a\u0442, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u0432\u0441\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b:</p> <pre><code>git clone https://github.com/nessshon/cnft-toolbox \n</code></pre> </li> <li> <p>\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438    \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 Docker, Docker Compose \u0438 ngrok, \u0438 \u0443\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u043e\u043d\u0438 \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043d\u044b \u043d\u0430 \u0432\u0430\u0448\u0435\u0439 \u043c\u0430\u0448\u0438\u043d\u0435.</p> </li> <li> <p>\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 Telegram-\u0431\u043e\u0442\u0430    \u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0431\u043e\u0442\u0430 \u0432 Telegram \u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u0435 \u0435\u0433\u043e API-\u0442\u043e\u043a\u0435\u043d.</p> </li> <li> <p>\u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0443\u043f \u043a API    \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 ngrok \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043f\u0443\u0431\u043b\u0438\u0447\u043d\u043e\u0433\u043e URL \u0434\u043b\u044f \u0442\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f:</p> <pre><code>ngrok http 8080 \n</code></pre> <p>\u0414\u043b\u044f \u043f\u0440\u043e\u0434\u0430\u043a\u0448\u0435\u043d\u0430: \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u0434\u043e\u043c\u0435\u043d \u0438 \u0441\u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u0443\u0439\u0442\u0435 Nginx \u0434\u043b\u044f \u043f\u0440\u043e\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u043a \u0432\u0430\u0448\u0435\u043c\u0443 API \u043d\u0430 \u043f\u043e\u0440\u0442 8080. \u042d\u0442\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0432 \u0441\u0435\u0431\u044f:</p> <ul> <li>\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044e \u0434\u043e\u043c\u0435\u043d\u0430 \u0438 \u043f\u0440\u0438\u0432\u044f\u0437\u043a\u0443 \u0435\u0433\u043e \u043a \u0432\u0430\u0448\u0435\u043c\u0443 \u0441\u0435\u0440\u0432\u0435\u0440\u0443.</li> <li>\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0443 Nginx \u0434\u043b\u044f \u043f\u0440\u043e\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u043d\u0430 \u043f\u043e\u0440\u0442 8080.</li> </ul> </li> <li> <p>\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0430\u0439\u043b <code>.env</code>    \u0421\u043a\u043e\u043f\u0438\u0440\u0443\u0439\u0442\u0435 \u0444\u0430\u0439\u043b <code>env.example</code> \u043f\u043e\u0434 \u0438\u043c\u0435\u043d\u0435\u043c <code>.env</code> \u0438 \u043e\u0431\u043d\u043e\u0432\u0438\u0442\u0435 \u0435\u0433\u043e \u0441 \u0443\u0447\u0451\u0442\u043e\u043c \u0432\u0430\u0448\u0435\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438. \u041d\u0438\u0436\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u043e \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430:</p> Key Description Example Notes <code>PORT</code> \u041f\u043e\u0440\u0442, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u0431\u0443\u0434\u0435\u0442 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c API. <code>8080</code> <code>ADMIN_USERNAME</code> \u0418\u043c\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430 \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c. <code>admin</code> <code>ADMIN_PASSWORD</code> \u041f\u0430\u0440\u043e\u043b\u044c \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430 \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c. <code>password</code> <code>DEPTH</code> \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 NFT (\u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 = <code>2^DEPTH</code>; \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 <code>DEPTH</code> \u2014 30). <code>20</code> <code>IS_TESTNET</code> \u0423\u043a\u0430\u0436\u0438\u0442\u0435, \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0435\u0441\u044c \u043b\u0438 \u0432\u044b \u043a \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438 TON (<code>true</code>) \u0438\u043b\u0438 \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0441\u0435\u0442\u0438 (<code>false</code>). <code>true</code> or <code>false</code> <code>POSTGRES_PASSWORD</code> \u041f\u0430\u0440\u043e\u043b\u044c \u0434\u043b\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a PostgreSQL. <code>secret</code> <code>POSTGRES_DB</code> \u0418\u043c\u044f \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 PostgreSQL. <code>merkleapi</code> <code>POSTGRES_URI</code> \u041f\u043e\u043b\u043d\u044b\u0439 URI \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a PostgreSQL. <code>postgresql://postgres:secret@db:5432/merkleapi</code> <code>BOT_TOKEN</code> \u0422\u043e\u043a\u0435\u043d \u0432\u0430\u0448\u0435\u0433\u043e Telegram-\u0431\u043e\u0442\u0430 (\u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u0447\u0435\u0440\u0435\u0437 @BotFather). <code>123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11</code> \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 NFT. <code>API_BASE_URL</code> \u0412\u043d\u0435\u0448\u043d\u0438\u0439 \u0434\u043e\u043c\u0435\u043d \u0432\u0430\u0448\u0435\u0433\u043e API. <code>https://example.ngrok.io</code> \u0417\u0430\u043c\u0435\u043d\u0438\u0442\u0435 \u043d\u0430 \u0432\u0430\u0448 \u043f\u0443\u0431\u043b\u0438\u0447\u043d\u044b\u0439 URL (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0447\u0435\u0440\u0435\u0437 ngrok). <code>TONCONNECT_MANIFEST_URL</code> URL \u043a \u0444\u0430\u0439\u043b\u0443 \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442\u0430 TON Connect. <code>https://example.com/tonconnect-manifest.json</code> \u0417\u0430\u043c\u0435\u043d\u0438\u0442\u0435 \u043d\u0430 \u043f\u0443\u0431\u043b\u0438\u0447\u043d\u044b\u0439 \u0430\u0434\u0440\u0435\u0441 \u0432\u0430\u0448\u0435\u0433\u043e \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442\u0430. <code>COLLECTION_ADDRESS</code> \u0410\u0434\u0440\u0435\u0441 NFT-\u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438. \u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u043f\u043e\u0441\u043b\u0435 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u044f \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438. </li> <li> <p>\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 API \u0438 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445    \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e \u043a\u043e\u043c\u0430\u043d\u0434\u0443 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 API \u0438 \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445:</p> <pre><code>docker-compose up -d db api \n</code></pre> </li> <li> <p>\u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u043c\u0438\u0433\u0440\u0430\u0446\u0438\u0438 \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445    \u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0432 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445:</p> <pre><code>docker-compose exec api /ctl migrate \n</code></pre> </li> <li> <p>\u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0435\u0432    \u041f\u043e\u043c\u0435\u0441\u0442\u0438\u0442\u0435 \u0444\u0430\u0439\u043b <code>owners.txt</code> (\u0441 \u0430\u0434\u0440\u0435\u0441\u0430\u043c\u0438 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0435\u0432) \u0432 \u043f\u0430\u043f\u043a\u0443 <code>api</code>, \u0437\u0430\u0442\u0435\u043c \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435:</p> <pre><code>docker-compose exec api /ctl add /api/owners.txt \n</code></pre> </li> <li> <p>\u041f\u0435\u0440\u0435\u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0435\u043d\u0438\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432    \u0412 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0435 \u043f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 <code>&lt;API_URI&gt;/admin/rediscover</code> \u0438 \u0432\u043e\u0439\u0434\u0438\u0442\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f <code>ADMIN_USERNAME</code> \u0438 <code>ADMIN_PASSWORD</code>. \u041f\u0440\u0438 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u043c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u0432\u044b \u0443\u0432\u0438\u0434\u0438\u0442\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 <code>ok</code>. \u0421\u043f\u0443\u0441\u0442\u044f \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u0440\u0435\u043c\u044f (\u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432) \u0432 \u043f\u0430\u043f\u043a\u0435 <code>api/apidata/upd</code> \u043f\u043e\u044f\u0432\u0438\u0442\u0441\u044f \u0444\u0430\u0439\u043b, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 <code>1.json</code>.</p> </li> <li> <p>\u0421\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0439\u0442\u0435 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435     \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e \u043a\u043e\u043c\u0430\u043d\u0434\u0443 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f:</p> <pre><code>docker-compose exec api /ctl genupd &lt;path-to-update-file&gt; &lt;collection-owner&gt; &lt;collection-meta&gt; &lt;item-meta-prefix&gt; &lt;royalty-base&gt; &lt;royalty-factor&gt; &lt;royalty-recipient&gt; &lt;api-uri-including-v1&gt; \n</code></pre> <p>\u0417\u0430\u043c\u0435\u043d\u0438\u0442\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c:</p> <ul> <li><code>&lt;path-to-update-file&gt;</code>: \u041f\u0443\u0442\u044c \u043a \u0444\u0430\u0439\u043b\u0443 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f, \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u043e\u043c\u0443 \u043d\u0430 \u0448\u0430\u0433\u0435 9 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, <code>api/apidata/upd/1.json</code>).</li> <li><code>&lt;collection-owner&gt;</code>: \u0410\u0434\u0440\u0435\u0441 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430 NFT-\u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438.</li> <li><code>&lt;collection-meta&gt;</code>: \u041f\u043e\u043b\u043d\u044b\u0439 URL \u043a \u0444\u0430\u0439\u043b\u0443 \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0445 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, <code>https://yourdomain.com/collection.json</code>).</li> <li><code>&lt;item-meta-prefix&gt;</code>: \u041e\u0431\u0449\u0438\u0439 \u043f\u0440\u0435\u0444\u0438\u043a\u0441 \u0434\u043b\u044f \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0435\u0441\u043b\u0438 \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 0 \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u044b \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 <code>https://yourdomain.com/0.json</code>, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 <code>https://yourdomain.com/</code>).</li> <li><code>&lt;royalty-base&gt;</code>: \u0427\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0451\u0442\u0430 \u0440\u043e\u044f\u043b\u0442\u0438 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, 10 \u0434\u043b\u044f 10%, \u0435\u0441\u043b\u0438 \u0444\u0430\u043a\u0442\u043e\u0440-\u0440\u043e\u044f\u043b\u0442\u0438 \u0440\u0430\u0432\u0435\u043d 100).</li> <li><code>&lt;royalty-factor&gt;</code>: \u0417\u043d\u0430\u043c\u0435\u043d\u0430\u0442\u0435\u043b\u044c \u0434\u043b\u044f \u0440\u043e\u044f\u043b\u0442\u0438 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, 100).</li> <li><code>&lt;royalty-recipient&gt;</code>: \u0410\u0434\u0440\u0435\u0441, \u043f\u043e\u043b\u0443\u0447\u0430\u044e\u0449\u0438\u0439 \u0440\u043e\u044f\u043b\u0442\u0438 (\u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u0442\u044c \u0441 <code>&lt;collection-owner&gt;</code>).</li> <li><code>&lt;api-uri-including-v1&gt;</code>: \u041f\u0443\u0431\u043b\u0438\u0447\u043d\u044b\u0439 URL \u0432\u0430\u0448\u0435\u0433\u043e API \u0441 \u043f\u043e\u0441\u0442\u0444\u0438\u043a\u0441\u043e\u043c <code>/v1</code> (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0435\u0441\u043b\u0438 \u0432\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u0438 <code>https://yourapi.com/admin/rediscover</code> \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u0444\u0430\u0439\u043b\u0430 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f, \u0437\u0434\u0435\u0441\u044c \u0443\u043a\u0430\u0436\u0438\u0442\u0435 <code>https://yourapi.com/v1</code>).</li> </ul> </li> <li> <p>\u0412\u044b\u0437\u043e\u0432\u0438\u0442\u0435 \u0441\u0441\u044b\u043b\u043a\u0443 <code>ton://</code>     \u041f\u043e\u0441\u043b\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u0438 \u043f\u043e\u044f\u0432\u0438\u0442\u0441\u044f \u0441\u0441\u044b\u043b\u043a\u0430 \u0444\u043e\u0440\u043c\u0430\u0442\u0430 <code>ton://</code>. \u041f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u043f\u043e \u044d\u0442\u043e\u0439 \u0441\u0441\u044b\u043b\u043a\u0435 \u0438 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e. \u0414\u043b\u044f \u0443\u0434\u043e\u0431\u0441\u0442\u0432\u0430 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u044d\u0442\u0443 \u0441\u0441\u044b\u043b\u043a\u0443 \u0432 \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440 QR-\u043a\u043e\u0434\u043e\u0432 \u0438 \u043e\u0442\u0441\u043a\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0435\u0451 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 Tonhub (\u0432 testnet \u0438\u043b\u0438 mainnet).</p> </li> <li> <p>\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438     \u0412 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0435 \u043f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 <code>&lt;API_URI&gt;/admin/setaddr/&lt;collection-address&gt;</code>, \u0437\u0430\u043c\u0435\u043d\u0438\u0432 <code>&lt;collection-address&gt;</code> \u043d\u0430 \u0430\u0434\u0440\u0435\u0441, \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u043f\u0440\u0438 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0438 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438.</p> </li> <li> <p>\u041e\u0436\u0438\u0434\u0430\u0439\u0442\u0435 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f     \u0421\u043b\u0435\u0434\u0438\u0442\u0435 \u0437\u0430 \u043b\u043e\u0433\u0430\u043c\u0438 \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u0430 API \u0434\u043e \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e <code>committed state</code> (\u0437\u0430\u0444\u0438\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u043c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0438).</p> <pre><code>docker-compose logs api \n</code></pre> </li> <li> <p>\u0420\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u043e!</p> </li> </ol>"},{"location":"ru/cookbook/cnft/#nft_1","title":"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u043e\u0442\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430 NFT","text":"<ol> <li> <p>\u041e\u0431\u043d\u043e\u0432\u0438\u0442\u0435 \u0444\u0430\u0439\u043b <code>.env</code>    \u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u0432 <code>.env</code> \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e <code>COLLECTION_ADDRESS</code>, \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u0443\u044e \u043f\u0440\u0438 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0438 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438.</p> </li> <li> <p>\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 Telegram-\u0431\u043e\u0442\u0430    \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e \u043a\u043e\u043c\u0430\u043d\u0434\u0443 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u0431\u043e\u0442\u0430:</p> <pre><code>docker-compose up -d redis bot \n</code></pre> </li> <li> <p>\u0412\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0443\u0439\u0442\u0435 \u0441 \u0431\u043e\u0442\u043e\u043c    \u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435 Telegram, \u043f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u043a \u0441\u0432\u043e\u0435\u043c\u0443 \u0431\u043e\u0442\u0443 \u0438 \u0441\u043b\u0435\u0434\u0443\u0439\u0442\u0435 \u0435\u0433\u043e \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f\u043c \u0434\u043b\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430 NFT.</p> </li> <li> <p>\u0413\u043e\u0442\u043e\u0432\u043e!</p> </li> </ol>"},{"location":"ru/cookbook/cnft/#_9","title":"\u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u0441\u043f\u0438\u0441\u043a\u0430 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0435\u0432","text":"<p>\u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0448\u0430\u0433\u0438, \u0447\u0442\u043e\u0431\u044b \u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u0441\u043f\u0438\u0441\u043e\u043a \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0435\u0432 \u0438 \u043f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u044c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0432 \u0432\u0430\u0448\u0435\u0439 NFT-\u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438:</p> <ol> <li> <p>\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u044c\u0442\u0435 \u043d\u043e\u0432\u044b\u0439 \u0444\u0430\u0439\u043b \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0435\u0432    \u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0430\u0439\u043b <code>new-owners.txt</code> \u0441 \u043d\u043e\u0432\u044b\u043c\u0438 \u0430\u0434\u0440\u0435\u0441\u0430\u043c\u0438 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0435\u0432 \u0438 \u043f\u043e\u043c\u0435\u0441\u0442\u0438\u0442\u0435 \u0435\u0433\u043e \u0432 \u043f\u0430\u043f\u043a\u0443 <code>api</code>.</p> </li> <li> <p>\u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u043d\u043e\u0432\u044b\u0445 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0435\u0432    \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443:</p> <pre><code>docker-compose exec api /ctl add /api/new-owners.txt \n</code></pre> </li> <li> <p>\u041f\u0435\u0440\u0435\u043e\u0431\u043d\u0430\u0440\u0443\u0436\u044c\u0442\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b    \u0412 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0435 \u043f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 <code>&lt;API_URI&gt;/admin/rediscover</code> \u0438 \u0432\u043e\u0439\u0434\u0438\u0442\u0435 \u043f\u043e\u0434 \u0441\u0432\u043e\u0438\u043c\u0438 <code>ADMIN_USERNAME</code> \u0438 <code>ADMIN_PASSWORD</code>.</p> </li> <li> <p>\u041d\u0430\u0439\u0434\u0438\u0442\u0435 \u0444\u0430\u0439\u043b \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f    \u041f\u043e\u0441\u043b\u0435 \u043f\u0435\u0440\u0435\u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0435\u043d\u0438\u044f \u043d\u0430\u0439\u0434\u0438\u0442\u0435 \u043d\u043e\u0432\u044b\u0439 \u0444\u0430\u0439\u043b \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0432 \u043f\u0430\u043f\u043a\u0435 <code>api/apidata/upd</code> (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, <code>2.json</code>, \u0435\u0441\u043b\u0438 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0439 \u0431\u044b\u043b <code>1.json</code>).</p> </li> <li> <p>\u0421\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0439\u0442\u0435 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435    \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443:</p> <pre><code>docker-compose exec api /ctl genupd &lt;path-to-update-file&gt; &lt;collection-address&gt; \n</code></pre> <p>\u0417\u0430\u043c\u0435\u043d\u0438\u0442\u0435 <code>&lt;path-to-update-file&gt;</code> \u043d\u0430 \u043f\u0443\u0442\u044c \u043a \u043d\u043e\u0432\u043e\u043c\u0443 \u0444\u0430\u0439\u043b\u0443 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, <code>api/apidata/upd/2.json</code>), \u0430 <code>&lt;collection-address&gt;</code> \u2014 \u043d\u0430 \u0430\u0434\u0440\u0435\u0441 \u0432\u0430\u0448\u0435\u0439 NFT-\u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438.</p> </li> <li> <p>\u041f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u043f\u043e <code>ton://</code> \u0441\u0441\u044b\u043b\u043a\u0435    \u041f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u043f\u043e \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0439 \u0441\u0441\u044b\u043b\u043a\u0435 <code>ton://</code> \u0438 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e. \u0412\u044b \u0442\u0430\u043a\u0436\u0435 \u043c\u043e\u0436\u0435\u0442\u0435 \u0441\u043e\u0437\u0434\u0430\u0442\u044c QR-\u043a\u043e\u0434 \u043f\u043e \u044d\u0442\u043e\u0439 \u0441\u0441\u044b\u043b\u043a\u0435 \u0438 \u043e\u0442\u0441\u043a\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0435\u0433\u043e \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 Tonhub.</p> </li> <li> <p>\u041e\u0436\u0438\u0434\u0430\u0439\u0442\u0435 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f    \u0421\u043b\u0435\u0434\u0438\u0442\u0435 \u0437\u0430 \u043b\u043e\u0433\u0430\u043c\u0438 \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u0430 API \u0434\u043e \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e <code>committed state</code> (\u0437\u0430\u0444\u0438\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u043c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0438):</p> <pre><code>docker-compose logs api \n</code></pre> </li> <li> <p>\u0413\u043e\u0442\u043e\u0432\u043e!</p> </li> </ol>"},{"location":"ru/cookbook/cnft/#_10","title":"\u0417\u0430\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435","text":"<p>\u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442 \u0441\u0436\u0430\u0442\u044b\u0445 NFT \u043a\u0430\u0440\u0434\u0438\u043d\u0430\u043b\u044c\u043d\u043e \u043c\u0435\u043d\u044f\u0435\u0442 \u043f\u043e\u0434\u0445\u043e\u0434 \u043a \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044e \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044e NFT \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f\u043c\u0438, \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u044f \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u0438\u0440\u0443\u0435\u043c\u043e\u0435 \u0438 \u044d\u043a\u043e\u043d\u043e\u043c\u0438\u0447\u0435\u0441\u043a\u0438 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0435 \u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043c\u0430\u0441\u0441\u043e\u0432\u043e\u0433\u043e \u0432\u044b\u043f\u0443\u0441\u043a\u0430 NFT. \u0423\u0441\u0442\u0440\u0430\u043d\u044f\u044f \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0445 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043e\u0432, \u0434\u0430\u043d\u043d\u044b\u0439 \u043f\u043e\u0434\u0445\u043e\u0434 \u043e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u0442 \u043f\u0443\u0442\u044c \u043a \u0431\u043e\u043b\u0435\u0435 \u0448\u0438\u0440\u043e\u043a\u043e\u043c\u0443 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044e NFT \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0432 \u0440\u0430\u0437\u0432\u0438\u0442\u0438\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u0441\u0442\u0432 \u0438 \u043c\u0430\u0440\u043a\u0435\u0442\u0438\u043d\u0433\u043e\u0432\u044b\u0445 \u043a\u0430\u043c\u043f\u0430\u043d\u0438\u044f\u0445.</p>"},{"location":"ru/cookbook/cnft/#_11","title":"\u0421\u043c. \u0422\u0430\u043a\u0436\u0435","text":"<ul> <li>Compressed NFT standard implementation</li> <li>Reference augmenting API implementation</li> <li>Compressed NFT toolbox</li> </ul>"},{"location":"ru/cookbook/subdomains/","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 TON","text":""},{"location":"ru/cookbook/subdomains/#_1","title":"\u0412\u0432\u0435\u0434\u0435\u043d\u0438\u0435","text":"<p>\u042d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043f\u0440\u043e\u0432\u0435\u0434\u0451\u0442 \u0432\u0430\u0441 \u0447\u0435\u0440\u0435\u0437 \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430\u043c\u0438 \u0432 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u0435 TON \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0441 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u043c \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u043c \u043a\u043e\u0434\u043e\u043c. \u041e\u043d\u043e \u043e\u0445\u0432\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u043e\u0432 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430\u043c\u0438, \u0432\u044b\u043f\u0443\u0441\u043a \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 DNS-\u0437\u0430\u043f\u0438\u0441\u044f\u043c\u0438 \u0441 \u043f\u0440\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u043c\u0438 \u043f\u0440\u0438\u043c\u0435\u0440\u0430\u043c\u0438.</p>"},{"location":"ru/cookbook/subdomains/#_2","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f","text":"<p>\u0421\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0434\u0432\u0435 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0441 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u043c \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u043c \u043a\u043e\u0434\u043e\u043c \u0434\u043b\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430\u043c\u0438 \u0432 TON, \u0432\u044b\u0431\u043e\u0440 \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u0442\u0440\u0435\u0431\u0443\u0435\u043c\u043e\u0433\u043e \u0443\u0440\u043e\u0432\u043d\u044f \u0441\u043b\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0438 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f:</p>"},{"location":"ru/cookbook/subdomains/#_3","title":"\u041a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432","text":"<p>GitHub \u2197</p> <p>\u042d\u0442\u043e \u0431\u043e\u043b\u0435\u0435 \u043f\u0440\u043e\u0434\u0432\u0438\u043d\u0443\u0442\u043e\u0435 \u0440\u0435\u0448\u0435\u043d\u0438\u0435, \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043a\u0430\u0436\u0434\u044b\u0439 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d \u0432 \u0432\u0438\u0434\u0435 NFT. \u0412\u043b\u0430\u0434\u0435\u043b\u0435\u0446 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 \u0432\u044b\u043f\u0443\u0441\u043a \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432, \u0430 \u043a\u0430\u0436\u0434\u044b\u0439 \u0432\u043b\u0430\u0434\u0435\u043b\u0435\u0446 NFT \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u043f\u043e\u043b\u043d\u044b\u0439 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c \u043d\u0430\u0434 \u0441\u0432\u043e\u0438\u043c \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u043c.</p> <p>\u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438:</p> <ul> <li>\u041f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u044b \u043c\u043e\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c \u0438 \u043f\u0440\u043e\u0434\u0430\u0432\u0430\u0442\u044c</li> <li>\u0414\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u044f\u043c\u0438 \u2014 \u0443 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430 \u0441\u0432\u043e\u0439 \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442</li> <li>\u0422\u0440\u0435\u0431\u0443\u0435\u0442 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u0440\u0430\u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, API \u0434\u043b\u044f \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0445)</li> </ul>"},{"location":"ru/cookbook/subdomains/#_4","title":"\u041c\u0435\u043d\u0435\u0434\u0436\u0435\u0440 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432","text":"<p>GitHub \u2197</p> <p>\u042d\u0442\u043e \u0431\u0430\u0437\u043e\u0432\u0430\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f, \u0433\u0434\u0435 \u043e\u0434\u0438\u043d \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442 \u0440\u043e\u043b\u044c \u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u0430 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432. \u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440 \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 \u0432\u044b\u043f\u0443\u0441\u043a \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 \u0438 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0443 \u0438\u0445 DNS-\u0437\u0430\u043f\u0438\u0441\u0435\u0439.</p> <p>\u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438:</p> <ul> <li>\u041f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u0434\u043b\u044f \u043f\u0440\u043e\u0441\u0442\u044b\u0445 \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0435\u0432</li> <li>\u0411\u044b\u0441\u0442\u0440\u0430\u044f \u0438 \u043b\u0451\u0433\u043a\u0430\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430</li> <li>\u0426\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0447\u0435\u0440\u0435\u0437 \u043e\u0434\u0438\u043d \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442</li> </ul>"},{"location":"ru/cookbook/subdomains/#_5","title":"\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043e\u043a\u0440\u0443\u0436\u0435\u043d\u0438\u044f","text":"<p>\u0412 \u044d\u0442\u043e\u043c \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f Python \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u043d\u043e \u0441 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u043e\u0439 \u0441 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u043c \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u043c \u043a\u043e\u0434\u043e\u043c tonutils, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u043e\u0431\u0435 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430\u043c\u0438.</p>"},{"location":"ru/cookbook/subdomains/#_6","title":"\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442\u044b","text":"<ul> <li>Python 3.10+</li> <li>\u0417\u0430\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0434\u043e\u043c\u0435\u043d .ton:  <ul> <li>Mainnet: dns.ton.org</li> <li>Testnet: dns.ton.org?testnet=true</li> </ul> </li> </ul>"},{"location":"ru/cookbook/subdomains/#_7","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0435\u0439","text":"<p>\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u0443\u044e Python-\u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443:</p> <pre><code>pip install tonutils\n</code></pre>"},{"location":"ru/cookbook/subdomains/#_8","title":"\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0442\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f \u0434\u043b\u044f \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432","text":"<p>\u0415\u0441\u043b\u0438 \u0432\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u043f\u043e\u0434\u0445\u043e\u0434 \u0441 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0435\u0439 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432, \u0432\u0430\u043c \u0442\u0430\u043a\u0436\u0435 \u043f\u043e\u043d\u0430\u0434\u043e\u0431\u044f\u0442\u0441\u044f:</p> <ul> <li>\u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u0440\u0430\u0437\u043c\u0435\u0449\u0435\u043d\u0438\u044f API \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0445</li> <li>\u0414\u043e\u043c\u0435\u043d\u043d\u043e\u0435 \u0438\u043c\u044f, \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0435 \u043d\u0430 \u044d\u0442\u043e\u0442 \u0441\u0435\u0440\u0432\u0435\u0440, \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u043c</li> <li>\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044b\u0435 Docker \u0438 Docker Compose \u0434\u043b\u044f \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u044f API</li> </ul>"},{"location":"ru/cookbook/subdomains/#_9","title":"\u041a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432","text":""},{"location":"ru/cookbook/subdomains/#_10","title":"\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0445","text":"<p>\u041f\u0435\u0440\u0435\u0434 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435\u043c \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c API \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0445. \u042d\u0442\u043e\u0442 \u0441\u0435\u0440\u0432\u0438\u0441 \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0439 \u0438 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432 \u0434\u043b\u044f \u0432\u0430\u0448\u0438\u0445 NFT-\u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432, \u0434\u0435\u043b\u0430\u044f \u0438\u0445 \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e \u0440\u0430\u0441\u043f\u043e\u0437\u043d\u0430\u0432\u0430\u0435\u043c\u044b\u043c\u0438.</p> <ol> <li> <p>\u041a\u043b\u043e\u043d\u0438\u0440\u0443\u0439\u0442\u0435 \u0440\u0435\u043f\u043e\u0437\u0438\u0442\u043e\u0440\u0438\u0439:  </p> <pre><code>git clone https://github.com/nessshon/subdomains-toolbox\ncd metadata-api\n</code></pre> </li> <li> <p>\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 API \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e Docker:    API \u0431\u0443\u0434\u0435\u0442 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043d\u0430 \u043f\u043e\u0440\u0442\u0443 <code>8001</code>. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043d\u0430\u0441\u0442\u0440\u043e\u0438\u0442\u044c SSL \u0438 \u043e\u0431\u0440\u0430\u0442\u043d\u044b\u0439 \u043f\u0440\u043e\u043a\u0441\u0438 \u0434\u043b\u044f \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0433\u043e \u0434\u043e\u0441\u0442\u0443\u043f\u0430.</p> <pre><code>docker-compose up -d\n</code></pre> </li> <li> <p>\u041f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u0440\u0430\u0431\u043e\u0442\u0443 API:    \u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435 \u0432 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0435 <code>https://your-domain.com/api/ton/example.png</code>. \u041f\u0440\u0438 \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0439 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0435 \u0432\u044b \u0443\u0432\u0438\u0434\u0438\u0442\u0435 \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430 <code>example</code>.</p> </li> </ol>"},{"location":"ru/cookbook/subdomains/#_11","title":"\u0420\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438","text":"<p>\u041f\u043e\u0441\u043b\u0435 \u0437\u0430\u043f\u0443\u0441\u043a\u0430 API \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0440\u0430\u0437\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 NFT \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0432\u0430\u0448\u0438\u0445 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432.</p> <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_collection import SubdomainCollection\nfrom tonutils.dns.subdomain_collection.content import SubdomainCollectionContent\nfrom tonutils.dns.subdomain_collection.data import FullDomain\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# NFT domain name and address from TON DNS Domains\n# Obtainable from https://dns.ton.org/ or https://dns.ton.org/?testnet=true\nDOMAIN_NAME = \"ghost\"  # ghost \u2192 ghost.ton\nDOMAIN_ADDRESS = \"EQ...\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n# Base URL of the API for generating metadata for NFTs\n# API source code: https://github.com/nessshon/subdomains-toolbox\nAPI_BASE_URL = \"https://your-domain.com/api/ton/\"\n\n# Metadata for the NFT collection\nCOLLECTION_METADATA = {\n    \"name\": f\"{DOMAIN_NAME.title()} DNS Domains\",\n    \"image\": f\"{API_BASE_URL}{DOMAIN_NAME}.png\",\n    \"description\": f\"*.{DOMAIN_NAME}.ton domains\",\n    \"prefix_uri\": API_BASE_URL,\n}\n\"\"\"\nExample of the metadata for the NFT collection (JSON format):\n{\n    \"name\": \"Ghost DNS Domains\",\n    \"image\": \"https://your-domain.com/api/ton/ghost.png\",\n    \"description\": \"*.ghost.ton domains\",\n    \"prefix_uri\": \"https://your-domain.com/api/ton/\"\n}\n\"\"\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = SubdomainCollection(\n        owner_address=wallet.address,\n        content=SubdomainCollectionContent(**COLLECTION_METADATA),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=wallet.address,\n        ),\n        full_domain=FullDomain(DOMAIN_NAME, \"ton\"),\n    )\n\n    tx_hash = await wallet.batch_transfer(\n        [\n            # Deploy collection\n            TransferData(\n                destination=collection.address,\n                amount=0.05,\n                body=collection.build_deploy_body(),\n                state_init=collection.state_init,\n            ),\n            # Bind Subdomain Collection to the main domain\n            TransferData(\n                destination=DOMAIN_ADDRESS,\n                amount=0.05,\n                body=Domain.build_set_next_resolver_record_body(collection.address),\n            ),\n        ]\n    )\n\n    print(f\"Successfully deployed Subdomain Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/cookbook/subdomains/#_12","title":"\u0412\u044b\u043f\u0443\u0441\u043a \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432","text":"<p>\u0427\u0442\u043e\u0431\u044b \u0432\u044b\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d \u0432 \u0432\u0438\u0434\u0435 NFT:</p> <ol> <li>\u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435 \u0441\u0432\u043e\u0439 TON-\u043a\u043e\u0448\u0435\u043b\u0451\u043a (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, Tonkeeper).</li> <li>\u041e\u0442\u043f\u0440\u0430\u0432\u044c\u0442\u0435 0.1 TON \u043d\u0430 \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 (\u043e\u043d \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0438 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0438).</li> <li>\u0412 \u043f\u043e\u043b\u0435 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u044f \u043a \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438 \u0443\u043a\u0430\u0436\u0438\u0442\u0435 \u0436\u0435\u043b\u0430\u0435\u043c\u043e\u0435 \u0438\u043c\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, <code>alice</code> \u0434\u043b\u044f <code>alice.ghost.ton</code>).</li> <li>\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u0438\u043c\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430 \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e (\u0442\u043e\u043b\u044c\u043a\u043e \u043b\u0430\u0442\u0438\u043d\u0441\u043a\u0438\u0435 \u0431\u0443\u043a\u0432\u044b \u0438 \u0446\u0438\u0444\u0440\u044b, \u0431\u0435\u0437 \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0445 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432) \u0438 \u0435\u0449\u0451 \u043d\u0435 \u0437\u0430\u043d\u044f\u0442\u043e.</li> <li>\u041f\u043e\u0441\u043b\u0435 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438 NFT \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d \u0432 \u0432\u0430\u0448 \u043a\u043e\u0448\u0435\u043b\u0451\u043a.</li> </ol>"},{"location":"ru/cookbook/subdomains/#_13","title":"\u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u044f\u043c\u0438","text":""},{"location":"ru/cookbook/subdomains/#_14","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0437\u0430\u043f\u0438\u0441\u0435\u0439","text":"<p>\u041c\u0435\u0445\u0430\u043d\u0438\u0437\u043c \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0437\u0430\u043f\u0438\u0441\u0435\u0439 \u0434\u043b\u044f NFT \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u0435\u043d \u0442\u043e\u043c\u0443, \u0447\u0442\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 TON DNS Domains. \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043d\u0430\u0437\u043d\u0430\u0447\u0438\u0442\u044c \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0443 \u043e\u0434\u043d\u0443 \u0438\u0437 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0442\u0438\u043f\u043e\u0432 \u0437\u0430\u043f\u0438\u0441\u0435\u0439 \u2014 \u043d\u0438\u0436\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u044b \u043f\u0440\u0438\u043c\u0435\u0440\u044b \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0441\u043b\u0443\u0447\u0430\u044f.</p> \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c Wallet \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Address of the wallet to be set (e.g., UQ...)\nWALLET_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_wallet_record_body(Address(WALLET_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c Site \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# ADNL address (e.g., \"a1b2c3...\")\nADNL_ADDRESS = \"a1b2c3...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_site_record_body(ADNL_ADDRESS)\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c Storage \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Hex-encoded BAG ID (e.g., \"1234567890abcdef...\")\nBAG_ID = \"1234567890abcdef...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_storage_record_body(BAG_ID)\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c Next Resolver \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom pytoniq_core import Address\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Address of the next resolver contract (e.g., EQ...)\nCONTRACT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_next_resolver_record_body(Address(CONTRACT_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/cookbook/subdomains/#_15","title":"\u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u0435\u0439","text":"<p>\u0410\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e, \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0434\u0430\u043b\u044f\u0442\u044c \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u0438. \u041d\u0438\u0436\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u044b \u043f\u0440\u0438\u043c\u0435\u0440\u044b \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0442\u0438\u043f\u0430.</p> \u0423\u0434\u0430\u043b\u0438\u0442\u044c Wallet \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_delete_wallet_record_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0434\u0430\u043b\u0438\u0442\u044c Site \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_delete_site_record_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0434\u0430\u043b\u0438\u0442\u044c Storage \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_delete_storage_record_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0434\u0430\u043b\u0438\u0442\u044c Next Resolver \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_delete_next_resolver_record_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/cookbook/subdomains/#_16","title":"\u041c\u0435\u043d\u0435\u0434\u0436\u0435\u0440 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432","text":""},{"location":"ru/cookbook/subdomains/#_17","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u0430","text":"<p>\u041d\u0438\u0436\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0451\u043d \u043f\u0440\u0438\u043c\u0435\u0440 \u0442\u043e\u0433\u043e, \u043a\u0430\u043a \u0440\u0430\u0437\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u041c\u0435\u043d\u0435\u0434\u0436\u0435\u0440 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 tonutils \u043d\u0430 Python. \u042d\u0442\u043e\u0442 \u0441\u043a\u0440\u0438\u043f\u0442 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442 \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442, \u043f\u0440\u0438\u0432\u044f\u0437\u044b\u0432\u0430\u0435\u0442 \u0435\u0433\u043e \u043a \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u043c\u0443 \u0434\u043e\u043c\u0435\u043d\u0443 \u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438 \u043e\u0442 \u0432\u0430\u0448\u0435\u0433\u043e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</p> <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Administrator address for managing the Subdomain Manager (e.g., UQ...)\nADMIN_ADDRESS = \"UQ...\"\n\n# NFT address of the main domain from TON DNS Domains collection (e.g., EQ...)\nDOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    subdomain_manager = SubdomainManager(Address(ADMIN_ADDRESS))\n\n    tx_hash = await wallet.batch_transfer(\n        [\n            # Deploy Subdomain Manager\n            TransferData(\n                destination=subdomain_manager.address,\n                amount=0.05,\n                state_init=subdomain_manager.state_init,\n            ),\n            # Bind Subdomain Manager to the main domain as a next resolver\n            TransferData(\n                destination=DOMAIN_ADDRESS,\n                amount=0.05,\n                body=Domain.build_set_next_resolver_record_body(subdomain_manager.address),\n            ),\n        ]\n    )\n\n    print(f\"Successfully deployed Subdomain Manager at address: {subdomain_manager.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/cookbook/subdomains/#_18","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0437\u0430\u043f\u0438\u0441\u0435\u0439","text":"<p>\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043e\u0434\u0438\u043d \u0438\u0437 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0442\u0438\u043f\u043e\u0432 \u0437\u0430\u043f\u0438\u0441\u0435\u0439 \u0434\u043b\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430. \u041d\u0438\u0436\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u044b \u043f\u0440\u0438\u043c\u0435\u0440\u044b \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0441\u043b\u0443\u0447\u0430\u044f.</p> \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c Wallet \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Address of the wallet to be set for the subdomain (e.g., UQ...)\nWALLET_ADDRESS = \"UQ...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_wallet_record_body(SUBDOMAIN, Address(WALLET_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c Site \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# ADNL address for the subdomain (e.g., \"a1b2c3...\")\nADNL_ADDRESS = \"a1b2c3...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_site_record_body(SUBDOMAIN, ADNL_ADDRESS)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c Storage \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# ID of the storage bag (hex string, e.g., \"1234567890abcdef...\")\nBAG_ID = \"1234567890abcdef...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_storage_record_body(SUBDOMAIN, BAG_ID)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c Next Resolver \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom pytoniq_core import Address\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Address of the next resolver contract (e.g., EQ...)\nCONTRACT_ADDRESS = \"EQ...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_next_resolver_record_body(SUBDOMAIN, Address(CONTRACT_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/cookbook/subdomains/#_19","title":"\u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u0435\u0439","text":"<p>\u0410\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e, \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0434\u0430\u043b\u044f\u0442\u044c \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u0438. \u041d\u0438\u0436\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u044b \u043f\u0440\u0438\u043c\u0435\u0440\u044b \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0442\u0438\u043f\u0430.</p> \u0423\u0434\u0430\u043b\u0438\u0442\u044c Wallet \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_delete_wallet_record_body(SUBDOMAIN)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0434\u0430\u043b\u0438\u0442\u044c Site \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_delete_site_record_body(SUBDOMAIN, False)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0434\u0430\u043b\u0438\u0442\u044c Storage \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_delete_storage_record_body(SUBDOMAIN, True)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> \u0423\u0434\u0430\u043b\u0438\u0442\u044c Next Resolver \u0437\u0430\u043f\u0438\u0441\u044c <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_delete_next_resolver_record_body(SUBDOMAIN)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/cookbook/subdomains/#_20","title":"\u0417\u0430\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435","text":"<p>\u0411\u043b\u043e\u043a\u0447\u0435\u0439\u043d TON \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442 \u0433\u0438\u0431\u043a\u0438\u0435 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u044b \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430\u043c\u0438 \u2014 \u0431\u0443\u0434\u044c \u0442\u043e \u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043f\u043e\u0434\u0445\u043e\u0434 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u041c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u0430 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 \u0438\u043b\u0438 \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 NFT \u0441 \u041a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0435\u0439 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432. \u041e\u0431\u0435 \u0441\u0445\u0435\u043c\u044b \u043b\u0435\u0433\u043a\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u044e\u0442\u0441\u044f \u0438 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0442 \u043c\u043e\u0449\u043d\u044b\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b \u0434\u043b\u044f \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0433\u043e \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430\u043c\u0438 \u0438 DNS-\u0437\u0430\u043f\u0438\u0441\u044f\u043c\u0438. \u042d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0432\u0441\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0448\u0430\u0433\u0438 \u0434\u043b\u044f \u043d\u0430\u0447\u0430\u043b\u0430 \u0440\u0430\u0431\u043e\u0442\u044b \u0438 \u043f\u043e\u043b\u043d\u043e\u0433\u043e \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f \u043d\u0430\u0434 \u0432\u0430\u0448\u0438\u043c\u0438 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430\u043c\u0438 \u0432 TON.</p>"},{"location":"ru/cookbook/subdomains/#_21","title":"\u0421\u043c. \u0422\u0430\u043a\u0436\u0435","text":"<ul> <li>TON Subdomains Toolbox</li> <li>Subdomain Manager Contract</li> <li>Subdomain Collection Contract</li> </ul>"},{"location":"ru/cookbook/vanity/","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043a\u0440\u0430\u0441\u0438\u0432\u043e\u0433\u043e \u0430\u0434\u0440\u0435\u0441\u0430","text":""},{"location":"ru/cookbook/vanity/#_1","title":"\u0412\u0432\u0435\u0434\u0435\u043d\u0438\u0435","text":"<p>\u042d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043e\u0431\u044a\u044f\u0441\u043d\u044f\u0435\u0442, \u043a\u0430\u043a \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043a\u0440\u0430\u0441\u0438\u0432\u044b\u0435 (vanity) \u0430\u0434\u0440\u0435\u0441\u0430 \u0432 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u0435 TON \u2014 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u044b \u0438\u043b\u0438 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0438 \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u043c \u0448\u0430\u0431\u043b\u043e\u043d\u043e\u043c (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u043c\u0438 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u043c\u0438 \u0438\u043b\u0438 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u043c\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438), \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0434\u0435\u043b\u0430\u044e\u0442 \u0430\u0434\u0440\u0435\u0441 \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e \u0443\u0437\u043d\u0430\u0432\u0430\u0435\u043c\u044b\u043c. \u0422\u0430\u043a\u0438\u0435 \u0430\u0434\u0440\u0435\u0441\u0430 \u0447\u0430\u0441\u0442\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u0431\u0440\u0435\u043d\u0434\u0438\u043d\u0433\u0430, \u043b\u0443\u0447\u0448\u0435\u0439 \u0447\u0438\u0442\u0430\u0435\u043c\u043e\u0441\u0442\u0438 \u0438\u043b\u0438 \u043f\u0440\u043e\u0441\u0442\u043e \u044d\u0441\u0442\u0435\u0442\u0438\u043a\u0438.</p>"},{"location":"ru/cookbook/vanity/#_2","title":"\u041a\u0440\u0430\u0441\u0438\u0432\u044b\u0439 \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430","text":"<p>\u0427\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043a\u0440\u0430\u0441\u0438\u0432\u044b\u0439 \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0434\u043b\u044f Jetton Master-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430), \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0448\u0430\u0433\u0438.</p>"},{"location":"ru/cookbook/vanity/#_3","title":"\u041a\u043b\u043e\u043d\u0438\u0440\u0443\u0439\u0442\u0435 \u0440\u0435\u043f\u043e\u0437\u0438\u0442\u043e\u0440\u0438\u0439","text":"<pre><code>git clone https://github.com/ton-community/vanity-contract\n</code></pre>"},{"location":"ru/cookbook/vanity/#_4","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"ru/cookbook/vanity/#_5","title":"\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440","text":"<pre><code>python src/generator/run.py --end {suffix} -w -0 --case-sensitive {owner_address}\n</code></pre> <ul> <li>\u0417\u0430\u043c\u0435\u043d\u0438\u0442\u0435 <code>{suffix}</code> \u043d\u0430 \u0436\u0435\u043b\u0430\u0435\u043c\u043e\u0435 \u043e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u0435 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u043c\u043e\u0433\u043e \u0430\u0434\u0440\u0435\u0441\u0430.</li> <li>\u0417\u0430\u043c\u0435\u043d\u0438\u0442\u0435 <code>{owner_address}</code> \u043d\u0430 \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c\u0441\u044f \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435.</li> </ul> <p>\u041f\u0440\u0438\u043c\u0435\u0440:</p> <pre><code>python src/generator/run.py --end NESS -w -0 --case-sensitive UQCZq3_Vd21-4y4m7Wc-ej9NFOhh_qvdfAkAYAOHoQ__Ness\n</code></pre> <p>\u0415\u0441\u043b\u0438 \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0435 \u0431\u0443\u0434\u0435\u0442 \u043d\u0430\u0439\u0434\u0435\u043d\u043e, \u0432\u044b \u0443\u0432\u0438\u0434\u0438\u0442\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0432\u0440\u043e\u0434\u0435:</p> <pre><code>Found: EQC7PA9iWnUVWv001Drj3vTu-pmAkTc30OarHy5iDJ1uNESS salt: 7c9398f0999a96fe5480b5d573817255d53377a000be18d0fb47d090a5606dfe\n</code></pre>"},{"location":"ru/cookbook/vanity/#_6","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430","text":"<p>\u0421\u043a\u043e\u043f\u0438\u0440\u0443\u0439\u0442\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 <code>salt</code> \u0438 \u0432\u0441\u0442\u0430\u0432\u044c\u0442\u0435 \u0435\u0433\u043e \u0432 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443 <code>SALT</code> \u0432 \u0441\u043a\u0440\u0438\u043f\u0442\u0435 \u0440\u0430\u0437\u0432\u0435\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u044f:</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.jetton.content import JettonOnchainContent\nfrom tonutils.vanity import Vanity\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The salt for the vanity address\nSALT = \"\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_master = JettonMasterStandard(\n        content=JettonOnchainContent(\n            name=\"Ness Jetton\",\n            symbol=\"NESS\",\n            description=\"Probably nothing\",\n            decimals=9,\n            image=\"https://ton.org/download/ton_symbol.png\",\n        ),\n        admin_address=wallet.address,\n    )\n    vanity = Vanity(\n        owner_address=wallet.address,\n        salt=SALT,\n    )\n    body = vanity.build_deploy_body(jetton_master)\n\n    tx_hash = await wallet.transfer(\n        destination=vanity.address,\n        amount=0.05,\n        body=body,\n        state_init=vanity.state_init,\n    )\n\n    print(f\"Successfully deployed contract at address: {vanity.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/cookbook/vanity/#_7","title":"\u041a\u0440\u0430\u0441\u0438\u0432\u044b\u0439 \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u0427\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043a\u0440\u0430\u0441\u0438\u0432\u044b\u0439 \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0443\u0441\u043a\u043e\u0440\u0435\u043d\u0438\u044f \u043d\u0430 GPU, \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0448\u0430\u0433\u0438.</p>"},{"location":"ru/cookbook/vanity/#_8","title":"\u041f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u0442\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f","text":"<p>\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0432\u0438\u0434\u0435\u043e\u043a\u0430\u0440\u0442\u0430 NVIDIA \u0441 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044b\u043c \u0434\u0440\u0430\u0439\u0432\u0435\u0440\u043e\u043c \u0432\u0435\u0440\u0441\u0438\u0438 555.* \u0438\u043b\u0438 \u0432\u044b\u0448\u0435.</p>"},{"location":"ru/cookbook/vanity/#_9","title":"\u0421\u043a\u0430\u0447\u0430\u0439\u0442\u0435 \u0431\u0438\u043d\u0430\u0440\u043d\u0438\u043a","text":"<p>\u0421\u043a\u0430\u0447\u0430\u0439\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u044b\u0439 \u0444\u0430\u0439\u043b <code>gpu-generator-linux</code> \u0441 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0440\u0435\u043b\u0438\u0437\u0430.</p>"},{"location":"ru/cookbook/vanity/#_10","title":"\u0417\u0430\u043f\u0443\u0441\u043a \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440\u0430","text":"<p>\u0427\u0442\u043e\u0431\u044b \u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440 \u0432 \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0435:</p> <pre><code>./gpu-generator-linux\n</code></pre> <p>\u0427\u0442\u043e\u0431\u044b \u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044e \u0441 \u0437\u0430\u0440\u0430\u043d\u0435\u0435 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u043c\u0438 \u0443\u0441\u043b\u043e\u0432\u0438\u044f\u043c\u0438 \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u0438\u0437 \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438:</p> <pre><code>./gpu-generator-linux -q \"start[*][T][O][N] | end[1][2][3]\"\n</code></pre> <p>\u0421\u043b\u0435\u0434\u0443\u0439\u0442\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f\u043c \u043d\u0430 \u044d\u043a\u0440\u0430\u043d\u0435, \u0447\u0442\u043e\u0431\u044b \u043e\u0442\u0441\u043b\u0435\u0436\u0438\u0432\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441 \u0438 \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b.</p> <p>\u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u044f \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u0432\u044b\u0432\u0435\u0434\u0435\u0442 \u043c\u043d\u0435\u043c\u043e\u043d\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u0444\u0440\u0430\u0437\u0443 \u0438 ID \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0441 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u043c \u0442\u0438\u043f\u0430 <code>WalletV3R2</code>.</p> <p>\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441 \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0439</p> <ul> <li> <p>\u0414\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b: <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>_</code>, <code>-</code></p> </li> <li> <p>\u041e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u043d\u0430\u0447\u0430\u043b\u0443 (\u043f\u043e\u0441\u043b\u0435 \u043f\u0440\u0435\u0444\u0438\u043a\u0441\u0430 <code>UQ</code>, \u0442\u0440\u0435\u0442\u0438\u0439 \u0441\u0438\u043c\u0432\u043e\u043b):</p> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u2192 <code>start[A][P][P][L][E]</code> \u0438\u043b\u0438 <code>start[*][T][O][N]</code></p> </li> <li> <p>\u041e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u043e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u044e:</p> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u2192 <code>end[T][O][N]</code> \u0438\u043b\u0438 <code>end[Tt][Oo][Nn]</code></p> </li> <li> <p>\u041a\u043e\u043c\u0431\u0438\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f:</p> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u2192 <code>start[*][T][O][N] &amp; end[T][O][N]</code></p> </li> <li> <p>\u041d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432 (\u0418\u041b\u0418):</p> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u2192 <code>start[*][T][O][N] &amp; end[T][O][N] | start[D][D][D] | end[0][0][0]</code></p> </li> </ul> <p>\u041e\u0440\u0438\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u043e\u0447\u043d\u0430\u044f \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c</p> Hardware 5 chars 6 chars 7 chars 8 chars Intel i5-8350U 4 min 4 h 40 m 12.5 days &gt; 2 years AMD Ryzen 5 3600 26 sec 30 min 31.5 h 84 days NVIDIA GTX 1650 SUPER 2 sec 2 min 2 h 5.5 days NVIDIA RTX 4090 &lt;1 sec 13 sec 13.5 min 14.5 h"},{"location":"ru/cookbook/vanity/#_11","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u041f\u043e\u0441\u043b\u0435 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043c\u043d\u0435\u043c\u043e\u043d\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0444\u0440\u0430\u0437\u044b \u0438 ID \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u043a\u043e\u0434:</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Wallet ID\nWALLET_ID = 0\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC, WALLET_ID)\n\n    print(f\"Address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/cookbook/vanity/#_12","title":"\u0417\u0430\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435","text":"<p>\u041a\u0440\u0430\u0441\u0438\u0432\u044b\u0435 (vanity) \u0430\u0434\u0440\u0435\u0441\u0430 \u2014 \u044d\u0442\u043e \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u0430\u044f \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u044c, \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044e\u0449\u0430\u044f \u0432\u044b\u0434\u0435\u043b\u0438\u0442\u044c \u0432\u0430\u0448 \u043a\u043e\u0448\u0435\u043b\u0451\u043a \u0438\u043b\u0438 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u0432 \u0441\u0435\u0442\u0438 TON. \u0425\u043e\u0442\u044f \u043e\u043d\u0438 \u043d\u0435 \u0434\u0430\u044e\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0445 \u043f\u0440\u0435\u0438\u043c\u0443\u0449\u0435\u0441\u0442\u0432, \u0442\u0430\u043a\u0438\u0435 \u0430\u0434\u0440\u0435\u0441\u0430 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043f\u043e\u043b\u0435\u0437\u043d\u044b \u0434\u043b\u044f \u0431\u0440\u0435\u043d\u0434\u0438\u043d\u0433\u0430, \u043c\u0430\u0440\u043a\u0435\u0442\u0438\u043d\u0433\u0430 \u0438\u043b\u0438 \u043b\u0438\u0447\u043d\u043e\u0439 \u044d\u0441\u0442\u0435\u0442\u0438\u043a\u0438.</p>"},{"location":"ru/cookbook/vanity/#_13","title":"\u0421\u043c. \u0422\u0430\u043a\u0436\u0435","text":"<ul> <li>Vanity Contract Generator</li> <li>Vanity Wallet Generator</li> </ul>"},{"location":"ru/guide/dns-operations/","title":"\u041e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u0441 DNS","text":"<p>\u042d\u0442\u043e\u0442 \u0440\u0430\u0437\u0434\u0435\u043b \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u043d\u043e\u0435 \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043f\u043e \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044e DNS-\u0437\u0430\u043f\u0438\u0441\u044f\u043c\u0438 \u0438 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430\u043c\u0438 TON \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 <code>tonutils</code>. \u041e\u043f\u0438\u0441\u0430\u043d\u044b \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u043f\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0435 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 DNS-\u0437\u0430\u043f\u0438\u0441\u0435\u0439, \u0440\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u044e \u0438 \u0432\u044b\u043f\u0443\u0441\u043a \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 \u043a\u0430\u043a NFT, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0440\u0430\u0431\u043e\u0442\u0435 \u0441 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f\u043c\u0438 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432 \u0438 \u043f\u0440\u043e\u0441\u0442\u044b\u043c\u0438 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u0430\u043c\u0438 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432.</p>"},{"location":"ru/guide/dns-operations/#_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0437\u0430\u043f\u0438\u0441\u0435\u0439","text":""},{"location":"ru/guide/dns-operations/#site","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 Site \u0437\u0430\u043f\u0438\u0441\u0438","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the NFT domain where the site record will be set\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# The ADNL address that will be set in the DNS record\nADNL_ADDRESS = \"{hex}\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_site_record_body(ADNL_ADDRESS)\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Site record set successfully!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#wallet","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 Wallet \u0437\u0430\u043f\u0438\u0441\u0438","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the NFT domain where the wallet record will be set\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# The address of the wallet that will be set in the DNS record\nWALLET_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_wallet_record_body(Address(WALLET_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Wallet record set successfully!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#storage","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 Storage \u0437\u0430\u043f\u0438\u0441\u0438","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the NFT domain where the storage record will be set\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# The hex-encoded BAG ID for the storage record\nBAG_ID = \"{hex}\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_storage_record_body(BAG_ID)\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Storage record set successfully!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#next-resolver","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 Next Resolver \u0437\u0430\u043f\u0438\u0441\u0438","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the NFT domain where the next resolver record will be set\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# The address of the contract to be set as the next resolver\nCONTRACT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = Domain.build_set_next_resolver_record_body(Address(CONTRACT_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_DOMAIN_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Next resolver record set successfully!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#_2","title":"\u041a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432","text":""},{"location":"ru/guide/dns-operations/#_3","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_collection import SubdomainCollection\nfrom tonutils.dns.subdomain_collection.content import SubdomainCollectionContent\nfrom tonutils.dns.subdomain_collection.data import FullDomain\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# NFT domain name and address from TON DNS Domains\n# Obtainable from https://dns.ton.org/ or https://dns.ton.org/?testnet=true\nDOMAIN_NAME = \"ghost\"  # ghost \u2192 ghost.ton\nDOMAIN_ADDRESS = \"EQ...\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n# The base URL of the API for generating metadata for NFTs.\n# API source code: https://github.com/nessshon/subdomains-toolbox\nAPI_BASE_URL = \"https://dns.ness.su/api/ton/\"\n\n# Metadata for the NFT collection\nCOLLECTION_METADATA = {\n    \"name\": f\"{DOMAIN_NAME.title()} DNS Domains\",\n    \"image\": f\"{API_BASE_URL}{DOMAIN_NAME}.png\",\n    \"description\": f\"*.{DOMAIN_NAME}.ton domains\",\n    \"prefix_uri\": API_BASE_URL,\n}\n\"\"\"\n{\n    \"name\": \"Ghost DNS Domains\",\n    \"image\": \"https://dns.ness.su/api/ton/ghost.png\",\n    \"description\": \"*.ghost.ton domains\",\n    \"prefix_uri\": \"https://dns.ness.su/api/ton/\"\n}\n\"\"\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = SubdomainCollection(\n        owner_address=wallet.address,\n        content=SubdomainCollectionContent(**COLLECTION_METADATA),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=wallet.address,\n        ),\n        full_domain=FullDomain(DOMAIN_NAME, \"ton\"),\n    )\n\n    tx_hash = await wallet.batch_transfer(\n        [\n            # Deploy collection\n            TransferData(\n                destination=collection.address,\n                amount=0.05,\n                body=collection.build_deploy_body(),\n                state_init=collection.state_init,\n            ),\n            # Binding a Subdomain Collection to the main domain\n            TransferData(\n                destination=DOMAIN_ADDRESS,\n                amount=0.05,\n                body=Domain.build_set_next_resolver_record_body(collection.address),\n            ),\n        ]\n    )\n\n    print(f\"Successfully deployed Subdomain Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#nft","title":"\u0412\u044b\u043f\u0443\u0441\u043a NFT \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u0430","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Subdomain Collection contract\nSUBDOMAIN_COLLECTION_ADDRESS = \"EQ...\"\n\n# The name of the subdomain to be minted\nSUBDOMAIN_NAME = \"alice\"  # alice \u2192 alice.ghost.ton\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_COLLECTION_ADDRESS,\n        amount=0.1,\n        body=SUBDOMAIN_NAME,\n    )\n\n    print(f\"Successfully minted subdomain {SUBDOMAIN_NAME}!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#_4","title":"\u041c\u0435\u043d\u0435\u0434\u0436\u0435\u0440 \u043f\u043e\u0434\u0434\u043e\u043c\u0435\u043d\u043e\u0432","text":""},{"location":"ru/guide/dns-operations/#_5","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u0430","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network, False for main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the administrator for managing the Subdomain Manager\nADMIN_ADDRESS = \"UQ...\"\n\n# NFT domain address from TON DNS Domains\n# Obtainable from https://dns.ton.org/ or https://dns.ton.org/?testnet=true\nDOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    subdomain_manager = SubdomainManager(Address(ADMIN_ADDRESS))\n\n    tx_hash = await wallet.batch_transfer(\n        [\n            # Deploy collection\n            TransferData(\n                destination=subdomain_manager.address,\n                amount=0.05,\n                state_init=subdomain_manager.state_init,\n            ),\n            # Binding a Subdomain Manager to the main domain\n            TransferData(\n                destination=DOMAIN_ADDRESS,\n                amount=0.05,\n                body=Domain.build_set_next_resolver_record_body(subdomain_manager.address),\n            ),\n        ]\n    )\n\n    print(f\"Successfully deployed Subdomain Manager at address: {subdomain_manager.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#site_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 Site \u0437\u0430\u043f\u0438\u0441\u0438","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the subdomain manager contract\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# The ADNL address to be set for the subdomain\nADNL_ADDRESS = \"{hex}\"\n\n# The subdomain to be registered\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_site_record_body(SUBDOMAIN, ADNL_ADDRESS)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Subdomain successfully registered and site record set!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#wallet_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 Wallet \u0437\u0430\u043f\u0438\u0441\u0438","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the subdomain manager contract\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# The address of the wallet to be set for the subdomain\nWALLET_ADDRESS = \"UQ...\"\n\n# The subdomain to be registered\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_wallet_record_body(SUBDOMAIN, Address(WALLET_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Subdomain successfully registered and wallet set!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#storage_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 Storage \u0437\u0430\u043f\u0438\u0441\u0438","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the subdomain manager contract\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# The ID of the storage bag to be set for the subdomain\nBAG_ID = \"{hex}\"\n\n# The subdomain to be registered\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_storage_record_body(SUBDOMAIN, BAG_ID)\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(\"Subdomain successfully registered and storage record set!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/dns-operations/#next-resolver_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 Next Resolver \u0437\u0430\u043f\u0438\u0441\u0438","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the subdomain manager contract\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# The address of the next resolver contract\nCONTRACT_ADDRESS = \"EQ...\"\n\n# The subdomain to be registered\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SubdomainManager.build_set_next_resolver_record_body(SUBDOMAIN, Address(CONTRACT_ADDRESS))\n\n    tx_hash = await wallet.transfer(\n        destination=SUBDOMAIN_MANAGER_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully registered subdomain and set the next resolver!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/getting-testnet-assets/","title":"\u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0442\u0435\u0441\u0442\u043e\u0432\u044b\u0435 \u0442\u043e\u043a\u0435\u043d\u044b","text":"<p>\u042d\u0442\u043e\u0442 \u0440\u0430\u0437\u0434\u0435\u043b \u043e\u0431\u044a\u044f\u0441\u043d\u044f\u0435\u0442, \u043a\u0430\u043a \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0442\u043e\u043a\u0435\u043d\u044b \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438.</p>"},{"location":"ru/guide/getting-testnet-assets/#ton","title":"TON","text":"TON \u0427\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c TON, \u043f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u0432 Telegram-\u0431\u043e\u0442\u0430 \u0438 \u0441\u043b\u0435\u0434\u0443\u0439\u0442\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f\u043c. \u041e\u0442\u043a\u0440\u044b\u0442\u044c Telegram-\u0431\u043e\u0442\u0430"},{"location":"ru/guide/getting-testnet-assets/#not-jetton-9-decimals","title":"NOT Jetton (9 decimals)","text":"NOT Jetton \u0427\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c NOT jetton, \u043e\u0442\u0441\u043a\u0430\u043d\u0438\u0440\u0443\u0439\u0442\u0435 \u044d\u0442\u043e\u0442 QR-\u043a\u043e\u0434 \u0432 \u0441\u0432\u043e\u0451\u043c TON-\u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435. \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c Testnet NOT"},{"location":"ru/guide/getting-testnet-assets/#usd-jetton-6-decimals","title":"USD\u20ae Jetton (6 decimals)","text":"USD\u20ae Jetton \u0427\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c USD\u20ae jetton, \u043e\u0442\u0441\u043a\u0430\u043d\u0438\u0440\u0443\u0439\u0442\u0435 \u044d\u0442\u043e\u0442 QR-\u043a\u043e\u0434 \u0432 \u0441\u0432\u043e\u0451\u043c TON-\u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435. \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c Testnet USD\u20ae"},{"location":"ru/guide/installation-and-initialization/","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0438 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f","text":"<p>\u042d\u0442\u043e\u0442 \u0440\u0430\u0437\u0434\u0435\u043b \u043e\u0431\u044a\u044f\u0441\u043d\u044f\u0435\u0442, \u043a\u0430\u043a \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 <code>tonutils</code> \u0438 \u0432\u044b\u0431\u0440\u0430\u0442\u044c \u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0438\u0439 \u043a\u043b\u0438\u0435\u043d\u0442 \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0432\u0430\u0448\u0438\u0445 \u043f\u043e\u0442\u0440\u0435\u0431\u043d\u043e\u0441\u0442\u0435\u0439.</p>"},{"location":"ru/guide/installation-and-initialization/#_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430","text":"<p>\u0427\u0442\u043e\u0431\u044b \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0431\u0430\u0437\u043e\u0432\u044b\u0439 \u043f\u0430\u043a\u0435\u0442 <code>tonutils</code>:</p> <pre><code>pip install tonutils\n</code></pre> <p>\u0415\u0441\u043b\u0438 \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0447\u0435\u0440\u0435\u0437 \u041d\u0430\u0442\u0438\u0432\u043d\u044b\u0439 ADNL, \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u0441 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u043c\u0438 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u044f\u043c\u0438:</p> <pre><code>pip install 'tonutils[pytoniq]'\n</code></pre>"},{"location":"ru/guide/installation-and-initialization/#_2","title":"\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u044b","text":""},{"location":"ru/guide/installation-and-initialization/#toncenter","title":"toncenter","text":"<p>toncenter.com \u2014 \u0431\u044b\u0441\u0442\u0440\u044b\u0439 \u0438 \u043d\u0430\u0434\u0451\u0436\u043d\u044b\u0439 HTTP API \u0434\u043b\u044f The Open Network.  </p> <p>Note</p> <p>API-\u043a\u043b\u044e\u0447 \u043d\u0435 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u0435\u043d, \u043d\u043e \u0434\u043b\u044f \u043b\u0443\u0447\u0448\u0435\u0439 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0435\u0433\u043e \u0447\u0435\u0440\u0435\u0437 @tonapibot.</p> <pre><code>from tonutils.client import ToncenterV2Client\nfrom tonutils.client import ToncenterV3Client\n\nAPI_KEY = \"your api key\"  # Optional\nIS_TESTNET = True\n\n# Using Toncenter V3 client\nclient_v3 = ToncenterV3Client(api_key=API_KEY, is_testnet=IS_TESTNET)\n\n# Using Toncenter V2 client (if needed)\n# client_v2 = ToncenterV2Client(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"ru/guide/installation-and-initialization/#tonapi","title":"tonapi","text":"<p>tonapi.io \u2014 REST API \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u0435\u043c \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u0430 TON.  </p> <p>Note</p> <p>\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f API-\u043a\u043b\u044e\u0447 \u0441 \u0441\u0430\u0439\u0442\u0430 tonconsole.com.</p> <pre><code>from tonutils.client import TonapiClient\n\nAPI_KEY = \"your api key\"\nIS_TESTNET = True\nclient = TonapiClient(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"ru/guide/installation-and-initialization/#quicknode","title":"quicknode","text":"<p>quicknode.com \u2014 HTTP API \u0441 \u043d\u0438\u0437\u043a\u043e\u0439 \u0437\u0430\u0434\u0435\u0440\u0436\u043a\u043e\u0439 \u043a TON \u0447\u0435\u0440\u0435\u0437 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u0440\u0430\u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443.  </p> <p>Note</p> <p>\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f URL API \u0441 \u0441\u0430\u0439\u0442\u0430 quicknode.com.</p> <p>Quicknode \u043d\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0442\u0435\u0441\u0442\u043e\u0432\u0443\u044e \u0441\u0435\u0442\u044c!</p> <pre><code>from tonutils.client import QuicknodeClient\n\nHTTP_PROVIDER_URL = \"https://blissful-withered-surf.ton-mainnet.quiknode.pro/d6e8...1964\"\nclient = QuicknodeClient(HTTP_PROVIDER_URL)\n</code></pre>"},{"location":"ru/guide/installation-and-initialization/#tatum","title":"tatum","text":"<p>tatum.io \u2014 RPC \u0438 API \u0434\u043b\u044f Web3.  </p> <p>Note</p> <p>\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f API-\u043a\u043b\u044e\u0447 \u0441 \u0441\u0430\u0439\u0442\u0430 tatum.io.</p> <pre><code>from tonutils.client import TatumClient\n\nAPI_KEY = \"your api key\"\nIS_TESTNET = True\nclient = TatumClient(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"ru/guide/installation-and-initialization/#adnl","title":"\u041d\u0430\u0442\u0438\u0432\u043d\u044b\u0439 ADNL","text":""},{"location":"ru/guide/installation-and-initialization/#pytoniq","title":"pytoniq","text":"<p>pytoniq \u2014 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u043f\u0440\u044f\u043c\u043e\u0433\u043e \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0441 \u043b\u0430\u0439\u0442-\u0441\u0435\u0440\u0432\u0435\u0440\u0430\u043c\u0438.  </p> <p>Note</p> <p>\u0414\u043b\u044f \u043b\u0443\u0447\u0448\u0435\u0439 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u0442\u0441\u044f \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u0443\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0447\u0435\u0440\u0435\u0437 \u0431\u043e\u0442\u0430 liteserver.</p> <pre><code>from tonutils.client import LiteserverClient\n\nIS_TESTNET = True\nclient = LiteserverClient(is_testnet=IS_TESTNET)\n\n# Using custom configuration\n# config = {}  # Your LiteServer config here \n# client = LiteserverClient(config=config)\n</code></pre>"},{"location":"ru/guide/jetton-operations/","title":"\u041e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u0441 Jetton","text":"<p>\u042d\u0442\u043e\u0442 \u0440\u0430\u0437\u0434\u0435\u043b \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u043d\u043e\u0435 \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043f\u043e \u0440\u0430\u0431\u043e\u0442\u0435 \u0441 Jetton \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 <code>tonutils</code>. \u041e\u043f\u0438\u0441\u0430\u043d\u044b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u0430\u043a \u0441 Stablecoin Jetton (by Notcoin), \u0442\u0430\u043a \u0438 \u0441\u043e Standard Jetton, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u0440\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435, \u0432\u044b\u043f\u0443\u0441\u043a, \u0441\u0436\u0438\u0433\u0430\u043d\u0438\u0435, \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0438 \u043e\u0431\u043c\u0435\u043d \u0447\u0435\u0440\u0435\u0437 \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0431\u0438\u0440\u0436\u0438, \u0442\u0430\u043a\u0438\u0435 \u043a\u0430\u043a STON.fi \u0438 DeDust.io.</p>"},{"location":"ru/guide/jetton-operations/#jetton-master","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 Jetton Master","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.jetton.content import JettonStablecoinContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the administrator for managing the Jetton Master\nADMIN_ADDRESS = \"UQ...\"\n\n# URI for the off-chain content of the Jetton\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-example-offchain\nURI = \"https://example.com/jetton.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_master = JettonMasterStablecoin(\n        content=JettonStablecoinContent(URI),\n        admin_address=ADMIN_ADDRESS,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_master.address,\n        amount=0.05,\n        state_init=jetton_master.state_init,\n    )\n\n    print(f\"Successfully deployed Jetton Master at address: {jetton_master.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#_1","title":"\u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430","text":"<pre><code>from pytoniq_core import Cell\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Cell containing the updated contract code\nNEW_CODE_CELL = Cell.one_from_boc(\"code hex\")\n\n# Cell containing the updated contract data\nNEW_DATA_CELL = Cell.one_from_boc(\"data hex\")\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_upgrade_message_body(\n        new_code=NEW_CODE_CELL,\n        new_data=NEW_DATA_CELL,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully upgraded the contract!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton","title":"\u0412\u044b\u043f\u0443\u0441\u043a Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The amount of Jettons to mint (in base units, considering decimals)\nJETTON_AMOUNT = 1000000\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_mint_body(\n        destination=wallet.address,\n        jetton_amount=int(JETTON_AMOUNT * (10 ** 9)),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.1,\n        body=body,\n    )\n\n    print(f\"Successfully minted {JETTON_AMOUNT} Jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton_1","title":"\u0421\u0436\u0438\u0433\u0430\u043d\u0438\u0435 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin, JettonWalletStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The amount of Jettons to burn (in base units, considering decimals)\nJETTON_AMOUNT = 0.01\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_wallet_address = await JettonMasterStablecoin.get_wallet_address(\n        client=client,\n        owner_address=wallet.address.to_str(),\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n    )\n    body = JettonWalletStablecoin.build_burn_body(\n        jetton_amount=int(JETTON_AMOUNT * (10 ** 9)),\n        response_address=wallet.address,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_wallet_address,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully burned {JETTON_AMOUNT} Jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#_2","title":"\u0421\u043c\u0435\u043d\u0430 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract where the admin will be changed\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The new administrator address to be set for the Jetton Master contract\nNEW_ADMIN_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_change_admin_body(\n        new_admin_address=Address(NEW_ADMIN_ADDRESS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully changed the admin of the Jetton Master!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#_3","title":"\u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract where the admin will be changed\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_drop_admin_body()\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Jetton Master admin has been successfully dropped!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#_4","title":"\u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043d\u0442\u0430","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\nfrom tonutils.jetton.content import JettonStablecoinContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# New URI for the Jetton offchain content\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-example-offchain\nNEW_URI = \"https://example.com/new-jetton.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStablecoin.build_change_content_body(\n        new_content=JettonStablecoinContent(NEW_URI),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully updated Jetton content!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton-master_1","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 Jetton Master (\u043e\u043d\u0447\u0435\u0439\u043d)","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.jetton.content import JettonOnchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the administrator for managing the Jetton Master\nADMIN_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_master = JettonMasterStandard(\n        content=JettonOnchainContent(\n            name=\"Ness Jetton\",\n            symbol=\"NESS\",\n            description=\"Probably nothing\",\n            decimals=9,\n            image=\"https://example.com/image.png\",\n        ),\n        admin_address=ADMIN_ADDRESS,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_master.address,\n        amount=0.05,\n        state_init=jetton_master.state_init,\n    )\n\n    print(f\"Successfully deployed Jetton Master at address: {jetton_master.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton-master_2","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 Jetton Master (\u043e\u0444\u0444\u0447\u0435\u0439\u043d)","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.jetton.content import JettonOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the administrator for managing the Jetton Master\nADMIN_ADDRESS = \"UQ...\"\n\n# URI for the off-chain content of the Jetton\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-example-offchain\nURI = \"https://example.com/jetton.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_master = JettonMasterStandard(\n        content=JettonOffchainContent(URI),\n        admin_address=ADMIN_ADDRESS,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_master.address,\n        amount=0.05,\n        state_init=jetton_master.state_init,\n    )\n\n    print(f\"Successfully deployed Jetton Master at address: {jetton_master.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton_2","title":"\u0412\u044b\u043f\u0443\u0441\u043a Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The amount of Jettons to mint (in base units, considering decimals)\nJETTON_AMOUNT = 1000000\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStandard.build_mint_body(\n        destination=wallet.address,\n        jetton_amount=int(JETTON_AMOUNT * (10 ** JETTON_DECIMALS)),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully minted {JETTON_AMOUNT} Jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton_3","title":"\u0421\u0436\u0438\u0433\u0430\u043d\u0438\u0435 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard, JettonWalletStandard\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# The amount of Jettons to burn (in base units, considering decimals)\nJETTON_AMOUNT = 0.01\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_wallet_address = await JettonMasterStandard.get_wallet_address(\n        client=client,\n        owner_address=wallet.address.to_str(),\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n    )\n    body = JettonWalletStandard.build_burn_body(\n        jetton_amount=int(JETTON_AMOUNT * (10 ** JETTON_DECIMALS)),\n        response_address=wallet.address,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_wallet_address,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully burned {JETTON_AMOUNT} Jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#_5","title":"\u0421\u043c\u0435\u043d\u0430 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract where the admin will be changed\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The new administrator address to be set for the Jetton Master contract\nNEW_ADMIN_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStandard.build_change_admin_body(\n        new_admin_address=Address(NEW_ADMIN_ADDRESS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully changed the admin of the Jetton Master!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#_6","title":"\u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043d\u0442\u0430","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\nfrom tonutils.jetton.content import JettonOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# New URI for the Jetton offchain content\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-example-offchain\nNEW_URI = \"https://example.com/new-jetton.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = JettonMasterStandard.build_change_content_body(\n        new_content=JettonOffchainContent(NEW_URI),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=JETTON_MASTER_ADDRESS,\n        amount=0.05,\n        body=body,\n    )\n\n    print(f\"Successfully updated Jetton content!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton_4","title":"\u041e\u0431\u043c\u0435\u043d Jetton","text":""},{"location":"ru/guide/jetton-operations/#stonfi","title":"\u0427\u0435\u0440\u0435\u0437 STON.fi","text":""},{"location":"ru/guide/jetton-operations/#ton-jetton","title":"\u041e\u0431\u043c\u0435\u043d TON \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 STON.fi. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.stonfi import StonfiRouterV2, StonfiRouterV1\nfrom tonutils.jetton.dex.stonfi.utils import get_stonfi_router_details\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master for swapping (TON &gt; USD\u20ae)\nTO_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap (in base units, considering decimals)\nTON_AMOUNT = 1\n\n# Minimum amount of Jettons to receive (in base units, considering decimals)\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    version, router_address, pton_address = await get_stonfi_router_details(\n        offer_address=\"ton\",\n        ask_address=TO_JETTON_MASTER_ADDRESS,\n        amount=TON_AMOUNT,\n        decimals=9,\n        is_testnet=client.is_testnet,\n    )\n\n    if version == 1:\n        router_v1 = StonfiRouterV1(client, router_address, pton_address)\n\n        to, value, body = await router_v1.get_swap_ton_to_jetton_tx_params(\n            user_wallet_address=wallet.address,\n            ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n            offer_amount=to_nano(TON_AMOUNT),\n            min_ask_amount=to_nano(MIN_AMOUNT, JETTON_DECIMALS),\n        )\n    else:\n        router_v2 = StonfiRouterV2(client, router_address, pton_address)\n\n        to, value, body = await router_v2.get_swap_ton_to_jetton_tx_params(\n            user_wallet_address=wallet.address,\n            receiver_address=wallet.address,\n            ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n            offer_amount=to_nano(TON_AMOUNT),\n            min_ask_amount=to_nano(MIN_AMOUNT, JETTON_DECIMALS),\n            refund_address=wallet.address,\n        )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton-ton","title":"\u041e\u0431\u043c\u0435\u043d Jetton \u2192 TON","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 STON.fi. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.stonfi import StonfiRouterV2, StonfiRouterV1\nfrom tonutils.jetton.dex.stonfi.utils import get_stonfi_router_details\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n# Minimum amount of TON to receive\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    version, router_address, pton_address = await get_stonfi_router_details(\n        offer_address=FROM_JETTON_MASTER_ADDRESS,\n        ask_address=\"ton\",\n        amount=JETTON_AMOUNT,\n        decimals=JETTON_DECIMALS,\n        is_testnet=client.is_testnet,\n    )\n\n    if version == 1:\n        router_v1 = StonfiRouterV1(client, router_address, pton_address)\n\n        to, value, body = await router_v1.get_swap_jetton_to_ton_tx_params(\n            offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n            user_wallet_address=wallet.address,\n            offer_amount=to_nano(JETTON_AMOUNT, JETTON_DECIMALS),\n            min_ask_amount=to_nano(MIN_AMOUNT),\n        )\n    else:\n        router_v2 = StonfiRouterV2(client, router_address, pton_address)\n\n        to, value, body = await router_v2.get_swap_jetton_to_ton_tx_params(\n            offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n            receiver_address=wallet.address,\n            user_wallet_address=wallet.address,\n            offer_amount=to_nano(JETTON_AMOUNT, JETTON_DECIMALS),\n            min_ask_amount=to_nano(MIN_AMOUNT),\n            refund_address=wallet.address,\n        )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton-jetton","title":"\u041e\u0431\u043c\u0435\u043d Jetton \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 STON.fi. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.stonfi import StonfiRouterV2, StonfiRouterV1\nfrom tonutils.jetton.dex.stonfi.utils import get_stonfi_router_details\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\nTO_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 6\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n# Minimum amount of Jettons to receive (in base units, considering decimals)\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    version, router_address, pton_address = await get_stonfi_router_details(\n        offer_address=FROM_JETTON_MASTER_ADDRESS,\n        ask_address=TO_JETTON_MASTER_ADDRESS,\n        amount=JETTON_AMOUNT,\n        decimals=FROM_JETTON_DECIMALS,\n        is_testnet=client.is_testnet,\n    )\n\n    if version == 1:\n        router_v1 = StonfiRouterV1(client, router_address, pton_address)\n        to, value, body = await router_v1.get_swap_jetton_to_jetton_tx_params(\n            user_wallet_address=wallet.address,\n            offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n            ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n            offer_amount=to_nano(JETTON_AMOUNT, FROM_JETTON_DECIMALS),\n            min_ask_amount=to_nano(MIN_AMOUNT, TO_JETTON_DECIMALS),\n        )\n    else:\n        router_v2 = StonfiRouterV2(client, router_address, pton_address)\n        to, value, body = await router_v2.get_swap_jetton_to_jetton_tx_params(\n            user_wallet_address=wallet.address,\n            receiver_address=wallet.address,\n            refund_address=wallet.address,\n            offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n            ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n            offer_amount=to_nano(JETTON_AMOUNT, FROM_JETTON_DECIMALS),\n            min_ask_amount=to_nano(MIN_AMOUNT, TO_JETTON_DECIMALS),\n        )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#dedustio","title":"\u0427\u0435\u0440\u0435\u0437 DeDust.io","text":""},{"location":"ru/guide/jetton-operations/#ton-jetton_1","title":"\u041e\u0431\u043c\u0435\u043d TON \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 DeDust.io. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.dedust import Factory\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap\nTON_AMOUNT = 1\n\n# Minimum amount of Jettons to receive (in base units, considering decimals)\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    to, value, body = await Factory(client).get_swap_ton_to_jetton_tx_params(\n        recipient_address=wallet.address,\n        offer_jetton_address=Address(JETTON_MASTER_ADDRESS),\n        offer_amount=to_nano(TON_AMOUNT),\n        min_ask_amount=to_nano(MIN_AMOUNT, JETTON_DECIMALS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton-ton_1","title":"\u041e\u0431\u043c\u0435\u043d Jetton \u2192 TON","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 DeDust.io. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.dedust import Factory\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n# Minimum amount of TON to receive\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    to, value, body = await Factory(client).get_swap_jetton_to_ton_tx_params(\n        recipient_address=wallet.address,\n        offer_jetton_address=Address(JETTON_MASTER_ADDRESS),\n        offer_amount=to_nano(JETTON_AMOUNT, JETTON_DECIMALS),\n        min_ask_amount=to_nano(MIN_AMOUNT),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/jetton-operations/#jetton-jetton_1","title":"\u041e\u0431\u043c\u0435\u043d Jetton \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 DeDust.io. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.jetton.dex.dedust import Factory\nfrom tonutils.utils import to_nano, to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\nTO_JETTON_MASTER_ADDRESS = \"EQ...\"  # noqa\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 6\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Minimum amount of Jettons to receive (in base units, considering decimals)\nMIN_AMOUNT = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    to, value, body = await Factory(client).get_swap_jetton_to_jetton_tx_params(\n        recipient_address=wallet.address,\n        offer_jetton_address=Address(FROM_JETTON_MASTER_ADDRESS),\n        ask_jetton_address=Address(TO_JETTON_MASTER_ADDRESS),\n        offer_amount=to_nano(JETTON_AMOUNT, FROM_JETTON_DECIMALS),\n        min_ask_amount=to_nano(MIN_AMOUNT, TO_JETTON_DECIMALS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=to,\n        amount=to_amount(value),\n        body=body,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/","title":"\u041e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u0441 NFT","text":"<p>\u042d\u0442\u043e\u0442 \u0440\u0430\u0437\u0434\u0435\u043b \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u043d\u043e\u0435 \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043f\u043e \u0440\u0430\u0431\u043e\u0442\u0435 \u0441 NFT-\u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f\u043c\u0438 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 <code>tonutils</code>. \u041e\u043f\u0438\u0441\u0430\u043d\u044b \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u0442\u0438\u043f\u043e\u0432 Standard, Soulbound, Editable \u0438 Editable Onchain, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u0440\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435, \u0432\u044b\u043f\u0443\u0441\u043a, \u043f\u0430\u043a\u0435\u0442\u043d\u044b\u0435 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0438 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u0438\u0432\u043d\u044b\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f.</p>"},{"location":"ru/guide/nft-operations/#standard","title":"Standard \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f","text":""},{"location":"ru/guide/nft-operations/#_1","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionStandard\nfrom tonutils.nft.content import CollectionOffchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT collection\nOWNER_ADDRESS = \"UQ...\"\n\n# URI of the collection's metadata\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-collection-metadata-example-offchain\nURI = \"https://example.com/nft/collection.json\"\nPREFIX_URI = \"https://example.com/nft/\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = CollectionStandard(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionOffchainContent(uri=URI, prefix_uri=PREFIX_URI),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n\n    \"\"\" If you want the option to withdraw extra balance in the future and store collection and NFT data on-chain,\n        you can use `CollectionStandardModified`. It removes the need for `prefix_uri` because NFTs minted in this\n        format include a direct link to the metadata for each item, rather than using a shared prefix for all items.\n\n    Example:\n\n    collection = CollectionStandardModified(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/collection.json`.\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=collection.address,\n        amount=0.05,\n        state_init=collection.state_init,\n    )\n\n    print(f\"Successfully deployed NFT Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft","title":"\u0412\u044b\u043f\u0443\u0441\u043a NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.nft.contract.standard.collection import CollectionStandard\nfrom tonutils.nft.contract.standard.nft import NFTStandard\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Index of the NFT to be minted\nNFT_INDEX = 0\n\n# Suffix URI of the NFT metadata\nSUFFIX_URI = f\"{NFT_INDEX}.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft = NFTStandard(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionStandard.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTOffchainContent(suffix_uri=SUFFIX_URI),\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionStandard` and `NFTStandard` with their modified versions,\n        and use `NFTModifiedOffchainContent` to specify the full `URI` for the NFT metadata.\n\n    Example:\n\n    nft = NFTStandardModified(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionStandardModified.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/0.json`.\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully minted NFT with index {NFT_INDEX}: {nft.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_1","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0439 \u0432\u044b\u043f\u0443\u0441\u043a NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionStandard\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Starting index for minting items\nFROM_INDEX = 0\n\n# Number of items to mint\nITEMS_COUNT = 100\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionStandard.build_batch_mint_body(\n        data=[\n            (\n                NFTOffchainContent(suffix_uri=f\"{index}.json\"),\n                Address(OWNER_ADDRESS),\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionStandard` with `CollectionStandardModified`, \n        and use `NFTModifiedOffchainContent` to specify the full `URI` for each NFT metadata.\n\n    Example:\n\n    body = CollectionStandardModified.build_batch_mint_body(\n        data=[\n            (\n                NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/{index}.json`.\n                Address(OWNER_ADDRESS),\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=ITEMS_COUNT * 0.05,\n        body=body,\n    )\n\n    print(f\"Successfully minted {ITEMS_COUNT} items in the collection at address: {COLLECTION_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#soulbound","title":"Soulbound \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f","text":""},{"location":"ru/guide/nft-operations/#_2","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionSoulbound\nfrom tonutils.nft.content import CollectionOffchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\n\n# URI of the collection's metadata\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-collection-metadata-example-offchain\nURI = \"https://example.com/nft/collection.json\"\nPREFIX_URI = \"https://example.com/nft/\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = CollectionSoulbound(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionOffchainContent(uri=URI, prefix_uri=PREFIX_URI),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n\n    \"\"\" If you want the option to withdraw extra balance in the future and store collection and NFT data on-chain,\n        you can use `CollectionSoulboundModified`. It removes the need for `prefix_uri` because NFTs minted in this\n        format include a direct link to the metadata for each item, rather than using a shared prefix for all items.\n\n    Example:\n\n    collection = CollectionSoulboundModified(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/collection.json`.\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=collection.address,\n        amount=0.05,\n        state_init=collection.state_init,\n    )\n\n    print(f\"Successfully deployed NFT Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_2","title":"\u0412\u044b\u043f\u0443\u0441\u043a NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionSoulbound, NFTSoulbound\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Index of the NFT to be minted\nNFT_INDEX = 0\n\n# Suffix URI of the NFT metadata\nSUFFIX_URI = f\"{NFT_INDEX}.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft = NFTSoulbound(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionSoulbound.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTOffchainContent(suffix_uri=SUFFIX_URI),\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionSoulbound` and `NFTSoulbound` with their modified versions, \n        and use `NFTModifiedOffchainContent` to specify the full `URI` for the NFT metadata.\n\n    Example:\n\n    nft = NFTSoulboundModified(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionSoulboundModified.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/0.json`.\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully minted NFT with index {NFT_INDEX}: {nft.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_3","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0439 \u0432\u044b\u043f\u0443\u0441\u043a NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionSoulbound\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner and editor of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nEDITOR_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Starting index for minting items\nFROM_INDEX = 0\n\n# Number of items to mint\nITEMS_COUNT = 100\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionSoulbound.build_batch_mint_body(\n        data=[\n            (\n                NFTOffchainContent(suffix_uri=f\"{index}.json\"),\n                Address(OWNER_ADDRESS),\n                Address(EDITOR_ADDRESS),\n                None,  # revoked at\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionSoulbound` with `CollectionSoulboundModified`, \n        and use `NFTModifiedOffchainContent` to specify the full `URI` for each NFT metadata.\n\n    Example:\n\n    body = CollectionSoulboundModified.build_batch_mint_body(\n        data=[\n            (\n                NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/{index}.json`.\n                Address(OWNER_ADDRESS),\n                Address(EDITOR_ADDRESS),\n                None,  # revoked at\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=ITEMS_COUNT * 0.05,\n        body=body,\n    )\n\n    print(f\"Minted {ITEMS_COUNT} items in collection {COLLECTION_ADDRESS}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_4","title":"\u041e\u0442\u0437\u044b\u0432 NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import NFTSoulbound\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be revoked\nNFT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    # Initialize TonapiClient and Wallet\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = NFTSoulbound.build_revoke_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully revoked NFT at address: {NFT_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_5","title":"\u0423\u043d\u0438\u0447\u0442\u043e\u0436\u0438\u0442\u044c NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import NFTSoulbound\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be destroyed\nNFT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = NFTSoulbound.build_destroy_body()\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully destroyed NFT at address: {NFT_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#editable","title":"Editable \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f","text":""},{"location":"ru/guide/nft-operations/#_3","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable\nfrom tonutils.nft.content import CollectionOffchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT collection\nOWNER_ADDRESS = \"UQ...\"\n\n# URI of the collection's metadata\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-collection-metadata-example-offchain\nURI = \"https://example.com/nft/collection.json\"\nPREFIX_URI = \"https://example.com/nft/\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = CollectionEditable(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionOffchainContent(uri=URI, prefix_uri=PREFIX_URI),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n\n    \"\"\" If you want the option to withdraw extra balance in the future and store collection and NFT data on-chain,\n        you can use `CollectionEditableModified`. It removes the need for `prefix_uri` because NFTs minted in this\n        format include a direct link to the metadata for each item, rather than using a shared prefix for all items.\n\n    Example:\n\n    collection = CollectionEditableModified(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/collection.json`.\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=collection.address,\n        amount=0.05,\n        state_init=collection.state_init,\n    )\n\n    print(f\"Successfully deployed NFT Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_6","title":"\u0412\u044b\u043f\u0443\u0441\u043a NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable, NFTEditable\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Index of the NFT to be minted\nNFT_INDEX = 0\n\n# Suffix URI of the NFT metadata\nSUFFIX_URI = f\"{NFT_INDEX}.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft = NFTEditable(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionEditable.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTOffchainContent(suffix_uri=SUFFIX_URI),\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionEditable` and `NFTEditable` with their modified versions,\n        and use `NFTModifiedOffchainContent` to specify the full `URI` for the NFT metadata.\n\n    Example:\n\n    nft = NFTEditableModified(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionEditableModified.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/0.json`.\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully minted NFT with index {NFT_INDEX}: {nft.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_7","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0439 \u0432\u044b\u043f\u0443\u0441\u043a NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner and editor of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nEDITOR_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Starting index for minting items\nFROM_INDEX = 0\n\n# Number of items to mint\nITEMS_COUNT = 100\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionEditable.build_batch_mint_body(\n        data=[\n            (\n                NFTOffchainContent(suffix_uri=f\"{index}.json\"),\n                Address(OWNER_ADDRESS),\n                Address(EDITOR_ADDRESS),\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n\n    \"\"\" If you deployed the collection using the Modified variant, replace the above code with:\n        Replace `CollectionEditable` with `CollectionEditableModified`, \n        and use `NFTModifiedOffchainContent` to specify the full `URI` for each NFT metadata.\n\n    Example:\n\n    body = CollectionEditableModified.build_batch_mint_body(\n        data=[\n            (\n                NFTModifiedOffchainContent(uri=URI),  # URI example: `https://example.com/nft/{index}.json`.\n                Address(OWNER_ADDRESS),\n                Address(EDITOR_ADDRESS),\n            )\n            for index in range(FROM_INDEX, FROM_INDEX + ITEMS_COUNT)\n        ],\n        from_index=FROM_INDEX,\n    )\n    \"\"\"\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=ITEMS_COUNT * 0.05,\n        body=body,\n    )\n\n    print(f\"Minted {ITEMS_COUNT} items in collection {COLLECTION_ADDRESS}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_8","title":"\u0420\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043d\u0442\u0430 NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import NFTEditable\nfrom tonutils.nft.content import NFTOffchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be edited\nNFT_ADDRESS = \"EQ...\"\n\n# Suffix URI of the NFT metadata\nSUFFIX_URI = f\"new-content.json\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = NFTEditable.build_edit_content_body(\n        content=NFTOffchainContent(suffix_uri=SUFFIX_URI),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully edited the content of NFT at address: {NFT_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_9","title":"\u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u043f\u0440\u0430\u0432 \u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import NFTEditable\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT whose editorship will be changed\nNFT_ADDRESS = \"EQ...\"\n\n# Address of the new editor to whom the editorship will be transferred\nNEW_EDITOR_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = NFTEditable.build_change_editorship_body(\n        editor_address=Address(NEW_EDITOR_ADDRESS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully changed the editorship of NFT {NFT_ADDRESS} to {NEW_EDITOR_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#_4","title":"\u0420\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043d\u0442\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable\nfrom tonutils.nft.content import CollectionOffchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the royalty receiver and the NFT collection contract\nROYALTY_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# URI of the collection's metadata\n# https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-collection-metadata-example-offchain\nURI = \"https://example.com/nft/collection.json\"\nPREFIX_URI = \"https://example.com/nft/\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 60  # 6% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionEditable.build_edit_content_body(\n        content=CollectionOffchainContent(uri=URI, prefix_uri=PREFIX_URI),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(ROYALTY_ADDRESS),\n        ),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully edited the collection at address: {COLLECTION_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#_5","title":"\u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u043f\u0440\u0430\u0432 \u043d\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044e","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditable\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the new owner to whom the collection ownership will be transferred\nNEW_OWNER_ADDRESS = \"UQ...\"\n\n# Address of the NFT collection whose ownership will be changed\nCOLLECTION_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionEditable.build_change_owner_body(\n        owner_address=Address(NEW_OWNER_ADDRESS),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully changed the owner of collection {COLLECTION_ADDRESS} to {NEW_OWNER_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#editable-onchain","title":"Editable-onchain \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f","text":""},{"location":"ru/guide/nft-operations/#_6","title":"\u0420\u0430\u0437\u0432\u0451\u0440\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditableModified\nfrom tonutils.nft.content import CollectionModifiedOnchainContent\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT collection\nOWNER_ADDRESS = \"UQ...\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    collection = CollectionEditableModified(\n        owner_address=Address(OWNER_ADDRESS),\n        next_item_index=0,\n        content=CollectionModifiedOnchainContent(\n            name=\"Welcome to TON\",\n            description=\"Each digital artwork represents a memorable token\",\n            image_data=b'image data',\n        ),\n        royalty_params=RoyaltyParams(\n            base=ROYALTY_BASE,\n            factor=ROYALTY_FACTOR,\n            address=Address(OWNER_ADDRESS),\n        ),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=collection.address,\n        amount=0.05,\n        state_init=collection.state_init,\n    )\n\n    print(f\"Successfully deployed NFT Collection at address: {collection.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_10","title":"\u0412\u044b\u043f\u0443\u0441\u043a NFT","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditableModified, NFTEditableModified\nfrom tonutils.nft.content import NFTModifiedOnchainContent\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the owner of the NFT and the NFT collection contract\nOWNER_ADDRESS = \"UQ...\"\nCOLLECTION_ADDRESS = \"EQ...\"\n\n# Index of the NFT to be minted\nNFT_INDEX = 0\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft = NFTEditableModified(\n        index=NFT_INDEX,\n        collection_address=Address(COLLECTION_ADDRESS),\n    )\n    body = CollectionEditableModified.build_mint_body(\n        index=NFT_INDEX,\n        owner_address=Address(OWNER_ADDRESS),\n        content=NFTModifiedOnchainContent(\n            name=\"TON Collectible #0\",\n            description=\"Memorable token for completing an onboarding quest about the TON ecosystem\",\n            image_data=b'image data',\n        ),\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully minted NFT with index {NFT_INDEX}: {nft.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#_7","title":"\u0412\u043e\u0437\u0432\u0440\u0430\u0442 \u0431\u0430\u043b\u0430\u043d\u0441\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import CollectionEditableModified\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT collection contract\nCOLLECTION_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = CollectionEditableModified.build_return_balance()\n\n    tx_hash = await wallet.transfer(\n        destination=COLLECTION_ADDRESS,\n        amount=0.02,\n        body=body,\n    )\n\n    print(f\"Successfully returned the balance of collection {COLLECTION_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft-getgemsio","title":"\u041f\u0440\u043e\u0434\u0430\u0436\u0430 NFT \u043d\u0430 Getgems.io","text":""},{"location":"ru/guide/nft-operations/#nft_11","title":"\u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c NFT \u043d\u0430 \u043f\u0440\u043e\u0434\u0430\u0436\u0443","text":"<pre><code>from pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection, NFT\nfrom tonutils.nft.marketplace.getgems.addresses import *\nfrom tonutils.nft.marketplace.getgems.contract.salev3r3 import SaleV3R3\nfrom tonutils.utils import to_nano\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be listed for sale\nNFT_ADDRESS = \"EQ..\"\n\n# Sale price for the NFT in TON\nPRICE = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft_data = await NFT.get_nft_data(client, NFT_ADDRESS)\n    royalty_params = await Collection.get_royalty_params(client, nft_data.collection_address)\n\n    price = to_nano(PRICE)\n    royalty_fee = int(price * (royalty_params.base / royalty_params.factor))\n    marketplace_fee = int(price * 0.05)\n\n    sale = SaleV3R3(\n        nft_address=NFT_ADDRESS,\n        owner_address=wallet.address,\n        marketplace_address=TESTNET_GETGEMS_ADDRESS if IS_TESTNET else GETGEMS_ADDRESS,\n        marketplace_fee_address=TESTNET_GETGEMS_FEE_ADDRESS if IS_TESTNET else GETGEMS_FEE_ADDRESS,\n        royalty_address=royalty_params.address,\n        marketplace_fee=marketplace_fee,\n        royalty_fee=royalty_fee,\n        price=price,\n    )\n    body = sale.build_transfer_nft_body(\n        destination=Address(TESTNET_GETGEMS_DEPLOYER_ADDRESS if IS_TESTNET else GETGEMS_DEPLOYER_ADDRESS),\n        owner_address=wallet.address,\n        state_init=sale.state_init,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=NFT_ADDRESS,\n        amount=0.25,\n        body=body,\n    )\n\n    # Print the result of the operation\n    print(f\"NFT {NFT_ADDRESS} successfully put on sale at price {PRICE} TON.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_12","title":"\u0418\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0446\u0435\u043d\u0443 NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection, NFT\nfrom tonutils.nft.marketplace.getgems.contract.salev3r3 import SaleV3R3\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT and sale contract\nNFT_ADDRESS = \"EQ...\"\nSALE_ADDRESS = \"EQ...\"\n\n# New sale price for the NFT in TON\nPRICE = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    nft_data = await NFT.get_nft_data(client, NFT_ADDRESS)\n    royalty_params = await Collection.get_royalty_params(client, nft_data.collection_address)\n\n    price = int(PRICE * 1e9)\n    royalty_fee = int(price * (royalty_params.base / royalty_params.factor))\n    marketplace_fee = int(price * 0.05)\n\n    body = SaleV3R3.build_change_price_body(\n        marketplace_fee=marketplace_fee,\n        royalty_fee=royalty_fee,\n        price=price,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=SALE_ADDRESS,\n        amount=0.005,\n        body=body,\n    )\n\n    print(f\"Successfully updated the price for NFT sale.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/nft-operations/#nft_13","title":"\u0421\u043d\u044f\u0442\u044c NFT \u0441 \u043f\u0440\u043e\u0434\u0430\u0436\u0438","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft.marketplace.getgems.contract.salev3r3 import SaleV3R3\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the sale contract\nSALE_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = SaleV3R3.build_cancel_sale_body()\n\n    tx_hash = await wallet.transfer(\n        destination=SALE_ADDRESS,\n        amount=0.2,\n        body=body,\n    )\n\n    print(\"Sale has been successfully canceled.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/","title":"\u041e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u0441 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u043c","text":"<p>\u042d\u0442\u043e\u0442 \u0440\u0430\u0437\u0434\u0435\u043b \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u043d\u043e\u0435 \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043f\u043e \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430\u043c\u0438 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 <code>tonutils</code>. \u041e\u043d \u043e\u0445\u0432\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u0442\u0430\u043a\u0438\u0435 \u043a\u0430\u043a:</p> <ul> <li>\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0438 \u0434\u0435\u043f\u043b\u043e\u0439 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432</li> <li>\u0418\u043c\u043f\u043e\u0440\u0442 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0438\u0437 \u043c\u043d\u0435\u043c\u043e\u043d\u0438\u043a\u0438 \u0438\u043b\u0438 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430</li> <li>\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439 (TON, NFT, Jetton)</li> <li>\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u044b</li> <li>\u041e\u0431\u043c\u0435\u043d Jetton (\u0447\u0435\u0440\u0435\u0437 STON.fi \u0438 DeDust.io)</li> </ul>"},{"location":"ru/guide/wallet-operations/#_1","title":"\u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0438","text":"<p>\u0411\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u0435\u0440\u0441\u0438\u0439 \u0438 \u0442\u0438\u043f\u043e\u0432 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432:</p> <ul> <li>\u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0438:   <code>WalletV2R1</code>, <code>WalletV2R2</code>, <code>WalletV3R1</code>, <code>WalletV3R2</code>, <code>WalletV4R1</code>, <code>WalletV4R2</code>, <code>WalletV5R1</code></li> <li>Highload-\u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0438 (\u0434\u043b\u044f \u0441\u0435\u0440\u0432\u0438\u0441\u043e\u0432 \u0438 \u0431\u0438\u0440\u0436):   <code>HighloadWalletV2</code>, <code>HighloadWalletV3</code></li> <li>Preprocessed \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0438 (\u0434\u043b\u044f \u044d\u043a\u043e\u043d\u043e\u043c\u0438\u0447\u043d\u044b\u0445 \u043f\u0430\u043a\u0435\u0442\u043d\u044b\u0445 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439):   <code>PreprocessedWalletV2</code>, <code>PreprocessedWalletV2R1</code></li> </ul>"},{"location":"ru/guide/wallet-operations/#_2","title":"\u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438","text":"<ul> <li>\u0414\u043b\u044f \u043e\u0431\u044b\u0447\u043d\u043e\u0433\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u0442\u0441\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0432\u0435\u0440\u0441\u0438\u0438 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 v3r2 \u0434\u043e v5r1, \u043f\u0440\u0435\u0434\u043f\u043e\u0447\u0442\u0438\u0442\u0435\u043b\u044c\u043d\u043e v5r1 \u0434\u043b\u044f \u043f\u043e\u043b\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u0438.</li> <li>\u0414\u043b\u044f \u0441\u0435\u0440\u0432\u0438\u0441\u043e\u0432 \u0438 \u0438\u043d\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u0438 \u0441 \u0431\u0438\u0440\u0436\u0430\u043c\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 HighloadWalletV3.</li> <li>\u0414\u043b\u044f \u043c\u0430\u0441\u0441\u043e\u0432\u044b\u0445 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u043e\u0432 \u0441 \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0446\u0438\u0435\u0439 \u0433\u0430\u0437\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0442\u0438\u043f\u044b PreprocessedWallet.</li> </ul>"},{"location":"ru/guide/wallet-operations/#_3","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u0414\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043c\u0435\u0442\u043e\u0434 <code>.create()</code> \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0433\u043e \u043a\u043b\u0430\u0441\u0441\u0430. \u041e\u043d \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u043e\u0431\u044a\u0435\u043a\u0442 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0441 \u043f\u0443\u0431\u043b\u0438\u0447\u043d\u044b\u043c \u043a\u043b\u044e\u0447\u043e\u043c, \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c \u043a\u043b\u044e\u0447\u043e\u043c \u0438 \u043c\u043d\u0435\u043c\u043e\u043d\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0444\u0440\u0430\u0437\u043e\u0439.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import (\n    # Uncomment the following lines to use different wallet versions:\n    # WalletV2R1,\n    # WalletV2R2,\n    # WalletV3R1,\n    # WalletV3R2,\n    # WalletV4R1,\n    WalletV4R2,\n    # WalletV5R1,\n    # HighloadWalletV2,\n    # HighloadWalletV3,\n    # PreprocessedWalletV2,\n    # PreprocessedWalletV2R1,\n)\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.create(client)\n\n    # Uncomment and use the following lines to create different wallet versions:\n    # wallet, public_key, private_key, mnemonic = WalletV3R2.create(client)\n    # wallet, public_key, private_key, mnemonic = WalletV4R1.create(client)\n    # wallet, public_key, private_key, mnemonic = WalletV4R2.create(client)\n    # wallet, public_key, private_key, mnemonic = WalletV5R1.create(client)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV2.create(client)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV3.create(client)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2.create(client)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2R1.create(client)\n\n    print(\"Wallet has been successfully created!\")\n    print(f\"Address: {wallet.address.to_str()}\")\n    print(f\"Mnemonic: {mnemonic}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/guide/wallet-operations/#_4","title":"\u0418\u043c\u043f\u043e\u0440\u0442 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u041a\u043e\u0448\u0435\u043b\u0451\u043a \u043c\u043e\u0436\u043d\u043e \u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438\u0437 \u043c\u043d\u0435\u043c\u043e\u043d\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0444\u0440\u0430\u0437\u044b \u0438\u043b\u0438 \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u0438\u0437 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430.</p>"},{"location":"ru/guide/wallet-operations/#_5","title":"\u0418\u0437 \u043c\u043d\u0435\u043c\u043e\u043d\u0438\u043a\u0438","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/guide/wallet-operations/#_6","title":"\u0418\u0437 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Private key (32 or 64 bytes)\nPRIVATE_KEY: bytes = b\"your_private_key_bytes\"\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet = WalletV4R2.from_private_key(client, PRIVATE_KEY)\n\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/guide/wallet-operations/#_7","title":"\u0414\u0435\u043f\u043b\u043e\u0439 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u0414\u043b\u044f \u0434\u0435\u043f\u043b\u043e\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u0435\u0433\u043e \u0438\u0437 \u043c\u043d\u0435\u043c\u043e\u043d\u0438\u043a\u0438 \u0438 \u0432\u044b\u0437\u043e\u0432\u0438\u0442\u0435 \u043c\u0435\u0442\u043e\u0434 <code>.deploy()</code>. \u042d\u0442\u043e \u043e\u043f\u0443\u0431\u043b\u0438\u043a\u0443\u0435\u0442 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0432 \u0441\u0435\u0442\u0438.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import (\n    # Uncomment the following lines to use different wallet versions:\n    # WalletV2R1,\n    # WalletV2R2,\n    # WalletV3R1,\n    # WalletV3R2,\n    # WalletV4R1,\n    WalletV4R2,\n    # WalletV5R1,\n    # HighloadWalletV2,\n    # HighloadWalletV3,\n    # PreprocessedWalletV2,\n    # PreprocessedWalletV2R1,\n)\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    # Uncomment and use the following lines to create different wallet versions from mnemonic:\n    # wallet, public_key, private_key, mnemonic = WalletV2R1.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV2R2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV3R2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV4R1.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV5R1.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV3.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2R1.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.deploy()\n\n    print(f\"Wallet deployed successfully!\")\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#_8","title":"\u041f\u0435\u0440\u0435\u0432\u043e\u0434\u044b","text":""},{"location":"ru/guide/wallet-operations/#ton","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Optional comment to include in the forward payload\nCOMMENT = \"Hello from tonutils!\"\n\n# Amount to transfer in TON\nAMOUNT = 0.01\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer(\n        destination=DESTINATION_ADDRESS,\n        amount=AMOUNT,\n        body=COMMENT,\n    )\n\n    print(f\"Successfully transferred {AMOUNT} TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#nft","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be transferred and the new owner address\nNFT_ADDRESS = \"EQ...\"\nNEW_OWNER_ADDRESS = \"UQ...\"\n\n# Optional comment to include in the forward payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer_nft(\n        destination=NEW_OWNER_ADDRESS,\n        nft_address=NFT_ADDRESS,\n        forward_payload=COMMENT,\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to transfer (in base units, considering decimals)\nJETTON_AMOUNT = 0.01\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Comment to include in the transfer payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer_jetton(\n        destination=DESTINATION_ADDRESS,\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n        forward_payload=COMMENT,\n    )\n\n    print(f\"Successfully transferred {JETTON_AMOUNT} jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#_9","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u044b","text":""},{"location":"ru/guide/wallet-operations/#ton_1","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u0430\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_transfer(\n        data_list=[\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n        ]\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#nft_1","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u0430\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferNFTData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_nft_transfer(\n        data_list=[\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            )\n        ]\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton_1","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u0430\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferJettonData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_jetton_transfer(\n        data_list=[\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n        ]\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton_2","title":"\u041e\u0431\u043c\u0435\u043d Jetton","text":""},{"location":"ru/guide/wallet-operations/#stonfi","title":"\u0427\u0435\u0440\u0435\u0437 STON.fi","text":""},{"location":"ru/guide/wallet-operations/#ton-jetton","title":"\u041e\u0431\u043c\u0435\u043d TON \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 STON.fi. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master for swapping (TON &gt; USD\u20ae)\nTO_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap (in TON)\nSWAP_TON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.stonfi_swap_ton_to_jetton(\n        jetton_master_address=TO_JETTON_MASTER_ADDRESS,\n        ton_amount=SWAP_TON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton-ton","title":"\u041e\u0431\u043c\u0435\u043d Jetton \u2192 TON","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 STON.fi. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master for swapping (TON &gt; USD\u20ae)\nTO_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.stonfi_swap_jetton_to_ton(\n        jetton_master_address=TO_JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton-jetton","title":"\u041e\u0431\u043c\u0435\u043d Jetton \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 STON.fi. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\nTO_JETTON_MASTER_ADDRESS = \"EQAvlWFDxGF2lXm67y4yzC17wYKD9A0guwPkMs1gOsM__NOT\"  # noqa\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 6\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.stonfi_swap_jetton_to_jetton(\n        from_jetton_master_address=FROM_JETTON_MASTER_ADDRESS,\n        to_jetton_master_address=TO_JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        from_jetton_decimals=FROM_JETTON_DECIMALS,\n        to_jetton_decimals=TO_JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#ton-jetton_1","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0439 \u043e\u0431\u043c\u0435\u043d TON \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 STON.fi. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import StonfiSwapTONToJettonData\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_stonfi_swap_ton_to_jetton(\n        data_list=[\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ],\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton-ton_1","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0439 \u043e\u0431\u043c\u0435\u043d Jetton \u2192 TON","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 STON.fi. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import StonfiSwapJettonToTONData\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_stonfi_swap_jetton_to_ton(\n        data_list=[\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ],\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton-jetton_1","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0439 \u043e\u0431\u043c\u0435\u043d Jetton \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 STON.fi. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import StonfiSwapJettonToJettonData\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_stonfi_swap_jetton_to_jetton(\n        data_list=[\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n        ],\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#dedustio","title":"\u0427\u0435\u0440\u0435\u0437 DeDust.io","text":""},{"location":"ru/guide/wallet-operations/#ton-jetton_2","title":"\u041e\u0431\u043c\u0435\u043d TON \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 DeDust.io. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap (in TON)\nSWAP_TON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.dedust_swap_ton_to_jetton(\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n        ton_amount=SWAP_TON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton-ton_2","title":"\u041e\u0431\u043c\u0435\u043d Jetton \u2192 TON","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 DeDust.io. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.dedust_swap_jetton_to_ton(\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton-jetton_2","title":"\u041e\u0431\u043c\u0435\u043d Jetton \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 DeDust.io. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQ...\"\nTO_JETTON_MASTER_B_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 9\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.dedust_swap_jetton_to_jetton(\n        from_jetton_master_address=FROM_JETTON_MASTER_ADDRESS,\n        to_jetton_master_address=TO_JETTON_MASTER_B_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        from_jetton_decimals=FROM_JETTON_DECIMALS,\n        to_jetton_decimals=TO_JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#ton-jetton_3","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0439 \u043e\u0431\u043c\u0435\u043d TON \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 DeDust.io. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import DedustSwapTONToJettonData\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_dedust_swap_ton_to_jetton(\n        data_list=[\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ]\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton-ton_3","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0439 \u043e\u0431\u043c\u0435\u043d Jetton \u2192 TON","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 DeDust.io. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import DedustSwapJettonToTONData\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_dedust_swap_jetton_to_ton(\n        data_list=[\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ]\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/wallet-operations/#jetton-jetton_3","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u044b\u0439 \u043e\u0431\u043c\u0435\u043d Jetton \u2192 Jetton","text":"<p>Note</p> <p>\u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 DeDust.io. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441 \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438. \u0410\u0432\u0442\u043e\u0440 \u043d\u0435 \u043d\u0435\u0441\u0451\u0442 \u043d\u0438\u043a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432. \u041d\u0430\u0448\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 \u0438\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u2014 \u0441\u043e\u0437\u0434\u0430\u0439\u0442\u0435 pull request.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import DedustSwapJettonToJettonData\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_dedust_swap_jetton_to_jetton(\n        data_list=[\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n        ]\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439","text":"<p>\u042d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u043e\u0448\u0430\u0433\u043e\u0432\u044b\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 \u043f\u043e \u0438\u043d\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u0438 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u043e\u0439 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c <code>TonConnect</code> \u0438\u0437 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 <code>tonutils</code>. \u041d\u0435\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e \u043e\u0442 \u0442\u043e\u0433\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0435\u0441\u044c \u043b\u0438 \u0432\u044b \u043d\u0430\u0447\u0438\u043d\u0430\u044e\u0449\u0438\u043c \u0438\u043b\u0438 \u043e\u043f\u044b\u0442\u043d\u044b\u043c \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c, \u044d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043f\u043e\u043c\u043e\u0436\u0435\u0442 \u0432\u0430\u043c \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439.</p>"},{"location":"ru/guide/ton-connect/sending-transactions/#_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430","text":"<p>\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 Python-\u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e <code>pip</code>:</p> <pre><code>pip install tonutils aiofiles\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/#_2","title":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f","text":""},{"location":"ru/guide/ton-connect/sending-transactions/#tonconnect","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442\u0430 TonConnect","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 JSON-\u0444\u0430\u0439\u043b, \u043e\u043f\u0438\u0441\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u0432\u0430\u0448\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435. \u041e\u043d \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0442\u044c\u0441\u044f \u0432 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435 \u043f\u0440\u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438.</p> <pre><code>{\n  \"url\": \"&lt;app-url&gt;\",                        // required\n  \"name\": \"&lt;app-name&gt;\",                      // required\n  \"iconUrl\": \"&lt;app-icon-url&gt;\",               // required\n  \"termsOfUseUrl\": \"&lt;terms-of-use-url&gt;\",     // optional\n  \"privacyPolicyUrl\": \"&lt;privacy-policy-url&gt;\" // optional\n}\n</code></pre> <p>Note</p> <p>\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u0444\u0430\u0439\u043b \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043f\u043e-\u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u043c\u0443 URL.</p>"},{"location":"ru/guide/ton-connect/sending-transactions/#_3","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430","text":"<p>\u0414\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 <code>FileStorage</code>.</p> <pre><code>import json\nimport os\nfrom asyncio import Lock\nfrom typing import Optional, Dict\n\nimport aiofiles\n\nfrom tonutils.tonconnect import IStorage\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/#tonconnect_1","title":"\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f TonConnect","text":"<p>\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 <code>TonConnect</code>, \u043f\u0435\u0440\u0435\u0434\u0430\u0432 \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442 \u0438 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435.</p> <pre><code>from storage import FileStorage\n\nfrom tonutils.tonconnect import TonConnect\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/#_4","title":"\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0441\u043e\u0431\u044b\u0442\u0438\u0439","text":"<p>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u0430 \u0434\u043b\u044f \u0440\u0435\u0430\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043d\u0430 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0438 \u043e\u0448\u0438\u0431\u043a\u0438, \u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0435 \u0441 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044f\u043c\u0438. \u0421\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0434\u0432\u0430 \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u0445 \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439: \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440\u043e\u0432 \u0438 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043d\u044b\u0445 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u043e\u0432.</p>"},{"location":"ru/guide/ton-connect/sending-transactions/#_5","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440\u043e\u0432","text":"<p>\u0414\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440\u044b \u0441\u0432\u044f\u0437\u044b\u0432\u0430\u044e\u0442 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0438 \u0441 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u043c\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u044f\u043c\u0438. \u042d\u0442\u043e\u0442 \u043f\u043e\u0434\u0445\u043e\u0434 \u043f\u0440\u043e\u0441\u0442 \u0438 \u043f\u043e\u043c\u043e\u0433\u0430\u0435\u0442 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043b\u043e\u0433\u0438\u043a\u0443 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439.</p> <pre><code>@tc.on_event(Event.TRANSACTION)\nasync def on_transaction(transaction: SendTransactionResponse) -&gt; None:\n    print(f\"[Transaction SENT] Transaction successfully sent. Message hash: {transaction.normalized_hash}\")\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/#_6","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043d\u044b\u0445 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u043e\u0432","text":"<p>\u041a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043d\u044b\u0435 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u044b \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u044e\u0442 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u0438\u0440\u0443\u0435\u043c\u0443\u044e \u0441\u0440\u0435\u0434\u0443 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439, \u0433\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u044f \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u0443\u044e \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u0438 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u0440\u0430\u0431\u043e\u0442\u044b.</p> <pre><code>async with connector.pending_transaction_context(rpc_request_id) as response:\n    if isinstance(response, TonConnectError):\n        print(f\"Error sending transaction: {response.message}\")\n    else:\n        print(f\"Transaction successful! Hash: {response.normalized_hash}\")\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/#_7","title":"\u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432","text":"<p>\u0412 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445 \u043c\u043e\u0436\u0435\u0442 \u043f\u043e\u0442\u0440\u0435\u0431\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u043b\u0438 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 \u0432 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u2014 \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0442\u0435\u0433\u0438, \u0437\u0430\u043c\u0435\u0442\u043a\u0438 \u0438\u043b\u0438 \u0444\u043b\u0430\u0433\u0438.</p> <p>\u042d\u0442\u043e \u043c\u043e\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043c\u0435\u0442\u043e\u0434\u0430 <code>connector.add_event_kwargs</code>, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043a\u0440\u0435\u043f\u043b\u044f\u0435\u0442 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b, \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0432\u043c\u0435\u0441\u0442\u0435 \u0441\u043e \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u043c\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\u0438.</p> <p>\u0428\u0430\u0433 1: \u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b</p> <p>\u0412\u044b\u0437\u043e\u0432\u0438\u0442\u0435 <code>add_event_kwargs</code> \u043f\u0435\u0440\u0435\u0434 \u0437\u0430\u043f\u0443\u0441\u043a\u043e\u043c \u0438\u043b\u0438 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u0435\u043c \u0441\u043e\u0431\u044b\u0442\u0438\u044f:</p> <pre><code>connector.add_event_kwargs(\n    event=Event.TRANSACTION,\n    comment=\"Hello from tonutils!\",\n)\n</code></pre> <p>\u0428\u0430\u0433 2: \u041e\u0431\u043d\u043e\u0432\u0438\u0442\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432</p> <p>\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0442\u0430\u043a, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u043b \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b:</p> <pre><code>@tc.on_event(Event.TRANSACTION)\nasync def on_transaction(user_id: int, transaction: SendTransactionResponse, comment: str) -&gt; None:\n    print(f\"Comment: {comment}\")\n</code></pre> <p>\u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043c\u043e\u043c\u0435\u043d\u0442\u044b:</p> <ul> <li>\u041c\u043e\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 (\u043b\u044e\u0431\u044b\u0435 \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b).</li> <li>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0438\u043c\u0435\u043d\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432.</li> <li>\u042d\u0442\u043e\u0442 \u043c\u0435\u0445\u0430\u043d\u0438\u0437\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u0445 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 (<code>CONNECT</code>, <code>DISCONNECT</code>, <code>TRANSACTION</code> \u0438 \u0434\u0440.).</li> </ul>"},{"location":"ru/guide/ton-connect/sending-transactions/#_8","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439","text":""},{"location":"ru/guide/ton-connect/sending-transactions/#_9","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u043e\u0434\u043d\u043e\u0439 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438","text":"<p>\u0427\u0442\u043e\u0431\u044b \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u043e\u0434\u043d\u0443 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043c\u0435\u0442\u043e\u0434 <code>send_transfer</code>. \u042d\u0442\u043e\u0442 \u043c\u0435\u0442\u043e\u0434 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e \u043d\u0430 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0430\u0434\u0440\u0435\u0441 \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0441\u0443\u043c\u043c\u043e\u0439 \u0438 \u043d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u043c \u0442\u0435\u043b\u043e\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.</p> <pre><code>rpc_request_id = await connector.send_transfer(\n    destination=connector.account.address,\n    amount=0.000000001,  # Amount in TON\n    body=\"Hello from tonutils!\",\n)\nprint(\"Request to send one transaction has been sent.\")\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/#_10","title":"\u041f\u0430\u043a\u0435\u0442\u043d\u0430\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439","text":"<p>\u0414\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043c\u0435\u0442\u043e\u0434 <code>send_batch_transfer</code>.</p> <pre><code># Get the maximum number of messages supported\nmax_messages = connector.get_max_supported_messages()\nprint(f\"Maximum number of messages: {max_messages}. Sending {max_messages} transactions...\")\n\nrpc_request_id = await connector.send_batch_transfer(\n    data_list=[\n        TransferData(\n            destination=connector.account.address,\n            amount=0.000000001,\n            body=\"Hello from tonutils!\",\n        ) for _ in range(max_messages)  # Create the maximum number of messages\n    ]\n)\nprint(\"Request to send a batch of transactions has been sent.\")\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/#_11","title":"\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0441\u0442\u0430\u0442\u0443\u0441\u0430 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438","text":"<p>\u041f\u043e\u0441\u043b\u0435 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c \u0435\u0451 \u0441\u0442\u0430\u0442\u0443\u0441, \u0447\u0442\u043e\u0431\u044b \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c, \u0431\u044b\u043b\u0430 \u043b\u0438 \u043e\u043d\u0430 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u043c \u0432 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435.</p> <pre><code># Get the transaction status (whether it has been confirmed by the user in the wallet)\nis_pending = connector.is_transaction_pending(rpc_request_id)\nprint(f\"Transaction is pending confirmation: {is_pending}\")\n\n# Use a context manager to get the transaction result by rpc_request_id\nasync with connector.pending_transaction_context(rpc_request_id) as response:\n    if isinstance(response, TonConnectError):\n        print(f\"Error sending transaction: {response.message}\")\n    else:\n        print(f\"Transaction successful! Hash: {response.normalized_hash}\")\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/#_12","title":"\u041f\u043e\u043b\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440","text":"<p>\u041d\u0438\u0436\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0451\u043d \u043f\u043e\u043b\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440, \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u043a\u043e\u043d\u043d\u0435\u043a\u0442\u043e\u0440\u0430, \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u0441\u043e\u0431\u044b\u0442\u0438\u0439, \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0443 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u043c.</p> <pre><code>import asyncio\nimport json\nimport os\nfrom asyncio import Lock\nfrom typing import Dict, Optional\n\nimport aiofiles\n\nfrom tonutils.tonconnect import TonConnect, IStorage\nfrom tonutils.tonconnect.models import Event, EventError, SendTransactionResponse\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\nfrom tonutils.wallet.data import TransferData\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n\n@tc.on_event(Event.TRANSACTION)\nasync def on_transaction(transaction: SendTransactionResponse) -&gt; None:\n    \"\"\"\n    Handler for successful transaction events.\n    Processes all successful transactions and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - transaction (SendTransactionResponse): Transaction information\n    - rpc_request_id (int): Transaction request identifier\n    - Additional parameters can be passed using `connector.add_event_kwargs(...)`\n      Example: `connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    Transaction details can be obtained from the following attributes:\n    - transaction.boc (str): BoC\n    - transaction.normalized_hash (str): Message hash\n    - transaction.cell (Cell): Transaction Cell\n    \"\"\"\n    print(f\"[Transaction SENT] Transaction successfully sent. Message hash: {transaction.normalized_hash}\")\n\n\n@tc.on_event(EventError.TRANSACTION)\nasync def on_transaction_error(error: TonConnectError) -&gt; None:\n    \"\"\"\n    Handler for transaction error events.\n    Processes all errors that occur when sending transactions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - error (TonConnectError): Error information\n    - rpc_request_id (int): Transaction request identifier\n    - Additional parameters can be passed using `connector.add_event_kwargs(...)`\n      Example: `connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    The type of error can be determined using isinstance:\n    - UserRejectsError: User declined the transaction.\n    - RequestTimeoutError: Send request timed out for the transaction.\n    \"\"\"\n    if isinstance(error, UserRejectsError):\n        print(f\"[Transaction ERROR] User rejected the transaction.\")\n    elif isinstance(error, RequestTimeoutError):\n        print(f\"[Transaction ERROR] Transaction request timed out.\")\n    else:\n        print(f\"[Transaction ERROR] Failed to send transaction: {error.message}\")\n\n\nasync def main() -&gt; None:\n    user_id = 12345  # Example user identifier\n\n    # Initialize the connector for the user\n    connector = await tc.init_connector(user_id)\n\n    # Start the event processing loop\n    while True:\n        # Check wallet connection\n        if not connector.connected:\n            print(\"Wallet not connected! Please connect the wallet to continue.\")\n\n            # Get all available wallets\n            wallets = await tc.get_wallets()\n\n            # As an example, we will select the wallet with index 1 (Tonkeeper)\n            selected_wallet = wallets[1]\n            connect_url = await connector.connect_wallet(selected_wallet)\n            print(f\"Please connect your wallet by visiting the following URL:\\n{connect_url}\")\n            print(\"Waiting for wallet connection...\")\n\n            async with connector.connect_wallet_context() as response:\n                if isinstance(response, TonConnectError):\n                    print(f\"Connection error: {response.message}\")\n                else:\n                    print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n\n        # If the wallet is connected, prompt the user to choose an action\n        call = input(\n            \"\\nChoose an action:\\n\"\n            \"1. Send a transaction\\n\"\n            \"2. Send a batch of transactions\\n\"\n            \"3. Disconnect wallet\\n\"\n            \"q. Quit\\n\"\n            \"\\nEnter your choice: \"\n        ).strip()\n\n        if call in [\"1\", \"2\"]:\n            if call == \"1\":\n                print(\"Preparing to send one transaction...\")\n                rpc_request_id = await connector.send_transfer(\n                    destination=connector.account.address,\n                    amount=0.000000001,\n                    body=\"Hello from tonutils!\",\n                )\n                print(\"Request to send one transaction has been sent.\")\n            else:\n                print(\"Preparing to send a batch of transactions...\")\n                # Get the maximum number of messages supported in a transaction\n                max_messages = connector.get_max_supported_messages()\n                print(f\"Maximum number of messages: {max_messages}. Sending {max_messages} transactions...\")\n\n                rpc_request_id = await connector.send_batch_transfer(\n                    data_list=[\n                        TransferData(\n                            destination=connector.account.address,\n                            amount=0.000000001,\n                            body=\"Hello from tonutils!\",\n                        ) for _ in range(max_messages)  # Create the maximum number of messages\n                    ]\n                )\n                print(\"Request to send a batch of transactions has been sent.\")\n\n            # Add additional parameters to be passed to event handlers\n            connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")\n\n            # Get the transaction status (whether it has been confirmed by the user in the wallet)\n            # Note: This is different from blockchain confirmation\n            is_pending = connector.is_transaction_pending(rpc_request_id)\n            print(f\"Transaction is pending confirmation: {is_pending}\")\n\n            # In addition to the handler, you can use a context manager to get the transaction result by rpc_request_id\n            async with connector.pending_transaction_context(rpc_request_id) as response:\n                if isinstance(response, TonConnectError):\n                    print(f\"Error sending transaction: {response.message}\")\n                else:\n                    print(f\"Transaction successful! Hash: {response.normalized_hash}\")\n\n        elif call == \"3\":\n            # Disconnect the wallet\n            await connector.disconnect_wallet()\n            print(\"Wallet successfully disconnected.\")\n\n        elif call.lower() == \"q\":\n            print(\"Exiting the program...\")\n            break\n\n        else:\n            print(\"Invalid choice! Please select a valid option.\")\n\n    # Close all TonConnect connections\n    await tc.close_all()\n\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except (KeyboardInterrupt, SystemExit):\n        # Ensure all connections are closed in case of interruption\n        asyncio.run(tc.close_all())\n</code></pre>"},{"location":"ru/guide/ton-connect/sending-transactions/#_13","title":"\u0417\u0430\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435","text":"<p>\u0421\u043b\u0435\u0434\u0443\u044f \u044d\u0442\u043e\u043c\u0443 \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u0443, \u0432\u044b \u0441\u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0438\u043d\u0442\u0435\u0433\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c TonConnect \u0432 \u0441\u0432\u043e\u0439 \u0441\u043a\u0440\u0438\u043f\u0442, \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432 \u0443\u0434\u043e\u0431\u043d\u043e\u0435 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0443 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439.</p>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/","title":"\u0418\u043d\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u044f \u0441 Telegram-\u0431\u043e\u0442\u043e\u043c","text":"<p>\u042d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u043e\u0448\u0430\u0433\u043e\u0432\u044b\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 \u043f\u043e \u0438\u043d\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u0438 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435\u043c \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u043e\u0439 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439 \u0432 Telegram-\u0431\u043e\u0442\u0435 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c <code>TonConnect</code> \u0438\u0437 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 <code>tonutils</code>. \u041d\u0435\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e \u043e\u0442 \u0442\u043e\u0433\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0435\u0441\u044c \u043b\u0438 \u0432\u044b \u043d\u0430\u0447\u0438\u043d\u0430\u044e\u0449\u0438\u043c \u0438\u043b\u0438 \u043e\u043f\u044b\u0442\u043d\u044b\u043c \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c, \u044d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043f\u043e\u043c\u043e\u0436\u0435\u0442 \u0432\u0430\u043c \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0438 \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044f\u043c\u0438 \u0432 \u0432\u0430\u0448\u0435\u043c Telegram-\u0431\u043e\u0442\u0435.</p>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430","text":"<p>\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 Python-\u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e <code>pip</code>:</p> <pre><code>pip install tonutils aiogram redis\n</code></pre>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_2","title":"\u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430","text":"<p>\u041e\u0440\u0433\u0430\u043d\u0438\u0437\u0443\u0439\u0442\u0435 \u0444\u0430\u0439\u043b\u044b \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c:</p> <pre><code>telegram-tonconnect-bot/\n\u251c\u2500\u2500 bot.py\n\u251c\u2500\u2500 storage.py\n</code></pre> <ul> <li>bot.py: \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0441\u043a\u0440\u0438\u043f\u0442 \u0431\u043e\u0442\u0430, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u0432\u0441\u044e \u043b\u043e\u0433\u0438\u043a\u0443.</li> <li>storage.py: \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0430\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430 \u0434\u043b\u044f TonConnect.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_3","title":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f","text":""},{"location":"ru/guide/ton-connect/telegram-bot-integration/#tonconnect","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442\u0430 TonConnect","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 JSON-\u0444\u0430\u0439\u043b, \u043e\u043f\u0438\u0441\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u0432\u0430\u0448\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435. \u041e\u043d \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0442\u044c\u0441\u044f \u0432 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435 \u043f\u0440\u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438.</p> <pre><code>{\n  \"url\": \"&lt;app-url&gt;\",                        // required\n  \"name\": \"&lt;app-name&gt;\",                      // required\n  \"iconUrl\": \"&lt;app-icon-url&gt;\",               // required\n  \"termsOfUseUrl\": \"&lt;terms-of-use-url&gt;\",     // optional\n  \"privacyPolicyUrl\": \"&lt;privacy-policy-url&gt;\" // optional\n}\n</code></pre> <p>Note</p> <p>\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u0444\u0430\u0439\u043b \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043f\u043e-\u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u043c\u0443 URL.</p>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_4","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430","text":"<p>TonConnect \u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0441\u0438\u0441\u0442\u0435\u043c\u0443 \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0441\u0432\u043e\u0438\u043c\u0438 \u0434\u0430\u043d\u043d\u044b\u043c\u0438. \u0417\u0434\u0435\u0441\u044c \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0430 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 Redis.</p> <pre><code># storage.py\n\nfrom typing import Optional\n\nfrom redis.asyncio import Redis\n\nfrom tonutils.tonconnect import IStorage\n\n\nclass TCRedisStorage(IStorage):\n    def __init__(self, redis_client: Redis):\n        self.redis = redis_client\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        await self.redis.set(name=key, value=value)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        value = await self.redis.get(name=key)\n        return value.decode() if value else default_value\n\n    async def remove_item(self, key: str) -&gt; None:\n        await self.redis.delete(key)\n</code></pre>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_5","title":"\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 Python-\u0441\u043a\u0440\u0438\u043f\u0442 \u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u0443\u044e \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0443.</p> <pre><code># bot.py\n\nimport base64\nfrom contextlib import suppress\nfrom typing import List\n\nfrom aiogram import Dispatcher, Bot\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.filters import CommandStart\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.storage.redis import RedisStorage\nfrom aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, CallbackQuery\nfrom aiogram.utils.keyboard import InlineKeyboardBuilder\nfrom aiogram.utils.markdown import hide_link, hcode\nfrom redis.asyncio import Redis\n\nfrom storage import TCRedisStorage\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.models import WalletApp, Event, EventError, SendTransactionResponse\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\nfrom tonutils.wallet.data import TransferData\n\nBOT_TOKEN = \"your bot token\"\nREDIS_DSN = \"redis://localhost:6379\"\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize Redis\nredis = Redis.from_url(url=REDIS_DSN)\n\n# Initialize Dispatcher with Redis Storage\ndp = Dispatcher(storage=RedisStorage(redis))\n\n# Initialize Telegram Bot\nbot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=\"HTML\"))\n\n# Initialize TonConnect\ntc = TonConnect(storage=TCRedisStorage(redis), manifest_url=TC_MANIFEST_URL,\n                wallets_fallback_file_path=\"./wallets.json\")\n</code></pre> <ul> <li>\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f Redis: \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u043e\u043c Redis.</li> <li>\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f Dispatcher \u0438 \u0431\u043e\u0442\u0430: \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u0442 \u0434\u0438\u0441\u043f\u0435\u0442\u0447\u0435\u0440 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c Redis-\u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430 \u0438 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442 \u0431\u043e\u0442\u0430.</li> <li>\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f TonConnect: \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u0442 TonConnect \u0441 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u043c Redis-\u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435\u043c \u0438 URL \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442\u0430.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_6","title":"\u0412\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0431\u043e\u0442\u0430","text":""},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_7","title":"\u041a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b","text":"<p>\u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 inline-\u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u0432 \u0431\u043e\u0442\u0435.</p>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_8","title":"\u041a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0430 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0451\u0442 inline-\u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0443 \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u0430 \u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432.</p> <pre><code>def _connect_wallet_markup(\n        wallets: List[WalletApp],\n        selected_wallet: WalletApp,\n        connect_url: str,\n) -&gt; InlineKeyboardMarkup:\n    wallets_buttons = [\n        InlineKeyboardButton(\n            text=f\"\u2022 {wallet.name} \u2022\" if wallet.app_name == selected_wallet.app_name else wallet.name,\n            callback_data=f\"app_wallet:{wallet.app_name}\",\n        )\n        for wallet in wallets\n    ]\n    connect_wallet_button = InlineKeyboardButton(\n        text=f\"Connect {selected_wallet.name}\",\n        url=connect_url,\n    )\n    builder = InlineKeyboardBuilder()\n    builder.row(connect_wallet_button)\n    builder.row(*wallets_buttons, width=2)\n\n    return builder.as_markup()\n</code></pre> <ul> <li>\u041a\u043d\u043e\u043f\u043a\u0438 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432: \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0445 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432, \u0432\u044b\u0434\u0435\u043b\u044f\u044f \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0439.</li> <li>\u041a\u043d\u043e\u043f\u043a\u0430 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f: \u041f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u0440\u044f\u043c\u0443\u044e \u0441\u0441\u044b\u043b\u043a\u0443 \u0434\u043b\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u0433\u043e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</li> <li>\u0420\u0430\u0437\u043c\u0435\u0442\u043a\u0430: \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 <code>InlineKeyboardBuilder</code> \u0434\u043b\u044f \u0430\u043a\u043a\u0443\u0440\u0430\u0442\u043d\u043e\u0439 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438 \u043a\u043d\u043e\u043f\u043e\u043a.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_9","title":"\u041a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0430 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0451\u0442 inline-\u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0443 \u0434\u043b\u044f \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u0438\u043b\u0438 \u043e\u0442\u043c\u0435\u043d\u044b \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</p> <pre><code>def _confirm_transaction_markup(url: str, wallet_name: str) -&gt; InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(\n        inline_keyboard=[\n            [InlineKeyboardButton(text=f\"Open {wallet_name}\", url=url)],\n            [InlineKeyboardButton(text=\"Cancel\", callback_data=\"cancel_transaction\")],\n        ]\n    )\n</code></pre> <ul> <li>\u041a\u043d\u043e\u043f\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430: \u041f\u0435\u0440\u0435\u043d\u0430\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u043a\u043e\u0448\u0435\u043b\u0451\u043a \u0434\u043b\u044f \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</li> <li>\u041a\u043d\u043e\u043f\u043a\u0430 \u043e\u0442\u043c\u0435\u043d\u044b: \u041f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043e\u0442\u043c\u0435\u043d\u0438\u0442\u044c \u043e\u0436\u0438\u0434\u0430\u044e\u0449\u0443\u044e \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_10","title":"\u041a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0430 \u0432\u044b\u0431\u043e\u0440\u0430 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0451\u0442 inline-\u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0443 \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u0430 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u043f\u043e\u0441\u043b\u0435 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</p> <pre><code>def _choose_action_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Send transaction\", callback_data=\"send_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Send batch transaction\", callback_data=\"send_batch_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Disconnect wallet\", callback_data=\"disconnect_wallet\"))\n\n    return builder.as_markup()\n</code></pre> <ul> <li>\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u044f: \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0436\u0435\u0442 \u0432\u044b\u0431\u0440\u0430\u0442\u044c \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0443 \u043e\u0434\u043d\u043e\u0439 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438, \u043f\u0430\u043a\u0435\u0442\u043d\u0443\u044e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0443 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439 \u0438\u043b\u0438   \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_11","title":"\u041a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0430 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430 \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0451\u0442 inline-\u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0443 \u0434\u043b\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430 \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e.</p> <pre><code>def _go_to_main_menu_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Main menu\", callback_data=\"main_menu\"))\n\n    return builder.as_markup()\n</code></pre> <ul> <li>\u041a\u043d\u043e\u043f\u043a\u0430 \u0433\u043b\u0430\u0432\u043d\u043e\u0433\u043e \u043c\u0435\u043d\u044e: \u041f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u043a \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u043c\u0443 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0443.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_12","title":"\u041e\u043a\u043d\u0430","text":"<p>\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u044e\u0442 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u043d\u044b\u0435 \u043e\u043a\u043d\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0440\u0435\u0430\u0433\u0438\u0440\u0443\u044e\u0442 \u043d\u0430 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u044f TonConnect.</p>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_13","title":"\u041e\u043a\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441 \u0434\u043b\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</p> <pre><code>async def connect_wallet_window(state: FSMContext, user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    state_data = await state.get_data()\n    wallets = await tc.get_wallets()\n\n    selected_wallet = state_data.get(\"selected_wallet\", wallets[0].app_name)\n    selected_wallet = next(wallet for wallet in wallets if wallet.app_name == selected_wallet)\n    connect_url = await connector.connect_wallet(wallet_app=selected_wallet)\n\n    qrcode_url = (\n        f\"https://qrcode.ness.su/create?\"\n        f\"box_size=20&amp;border=7&amp;image_padding=20\"\n        f\"&amp;data={base64.b64encode(connect_url.encode()).decode()}\"\n        f\"&amp;image_url={base64.b64encode(selected_wallet.image.encode()).decode()}\"\n    )\n\n    text = f\"{hide_link(qrcode_url)}Connect your wallet!\"\n    reply_markup = _connect_wallet_markup(wallets, selected_wallet, connect_url)\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043a\u043e\u043d\u043d\u0435\u043a\u0442\u043e\u0440\u0430: \u041f\u043e\u0434\u0433\u043e\u0442\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u043a\u043e\u043d\u043d\u0435\u043a\u0442\u043e\u0440 TonConnect \u0434\u043b\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f.</li> <li>\u0412\u044b\u0431\u043e\u0440 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430: \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0445 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0438 \u0432\u044b\u0431\u0438\u0440\u0430\u0435\u0442 \u043f\u0440\u0435\u0434\u043f\u043e\u0447\u0442\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439.</li> <li>\u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f QR-\u043a\u043e\u0434\u0430: \u0424\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u0441\u0441\u044b\u043b\u043a\u0443 \u0441 QR-\u043a\u043e\u0434\u043e\u043c \u0434\u043b\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</li> <li>\u0417\u0430\u043f\u0440\u043e\u0441 \u043a \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e: \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0441 \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043a\u043e\u0448\u0435\u043b\u0451\u043a \u0438 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439   inline-\u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u043e\u0439.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_14","title":"\u041e\u043a\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0451\u043d\u043d\u043e\u0433\u043e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0451\u043d\u043d\u043e\u043c \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435 \u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f.</p> <pre><code>async def wallet_connected_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    wallet_address = connector.wallet.account.address.to_str(is_bounceable=False)\n\n    reply_markup = _choose_action_markup()\n    text = f\"Connected wallet:\\n{hcode(wallet_address)}\\n\\nChoose an action:\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435: \u041f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u0430\u0434\u0440\u0435\u0441 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0451\u043d\u043d\u043e\u0433\u043e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</li> <li>\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f: \u041f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u044b \u2014 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e, \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u043f\u0430\u043a\u0435\u0442\u043d\u0443\u044e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0443 \u0438\u043b\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043a\u043e\u0448\u0435\u043b\u0451\u043a.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_15","title":"\u041e\u043a\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438","text":"<p>\u0417\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438 \u0432 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435.</p> <pre><code>async def send_transaction_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    reply_markup = _confirm_transaction_markup(\n        url=connector.wallet_app.direct_url,\n        wallet_name=connector.wallet_app.name,\n    )\n\n    text = \"Please confirm the transaction in your wallet.\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>\u0417\u0430\u043f\u0440\u043e\u0441 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e: \u041f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044c \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e \u0432 \u0441\u0432\u043e\u0451\u043c \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435.</li> <li>\u0412\u0430\u0440\u0438\u0430\u043d\u0442\u044b \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f: \u041f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043d\u043e\u043f\u043a\u0438 \u0434\u043b\u044f \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0438\u043b\u0438 \u043e\u0442\u043c\u0435\u043d\u044b \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_16","title":"\u041e\u043a\u043d\u043e \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438","text":"<p>\u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0434\u0435\u0442\u0430\u043b\u0438 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438 \u043f\u043e\u0441\u043b\u0435 \u0435\u0451 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438.</p> <pre><code>async def transaction_sent_window(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    text = (\n        \"Transaction sent!\\n\\n\"\n        f\"Transaction msg hash:\\n{hcode(transaction.normalized_hash)}\\n\"\n        f\"Transaction BoC:\\n{hcode(transaction.boc)}\\n\"\n    )\n    reply_markup = _go_to_main_menu_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>\u0414\u0435\u0442\u0430\u043b\u0438 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438: \u041f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u0445\u0435\u0448 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438 \u0438 BoC (Bag of Cells) \u0434\u043b\u044f \u0441\u043f\u0440\u0430\u0432\u043a\u0438.</li> <li>\u041d\u0430\u0432\u0438\u0433\u0430\u0446\u0438\u044f: \u041f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043d\u043e\u043f\u043a\u0443 \u0434\u043b\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430 \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_17","title":"\u041e\u043a\u043d\u043e \u043e\u0448\u0438\u0431\u043a\u0438","text":"<p>\u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435 \u0441 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u043f\u043e\u0432\u0442\u043e\u0440\u0438\u0442\u044c \u043f\u043e\u043f\u044b\u0442\u043a\u0443 \u0438\u043b\u0438 \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u043d\u0430\u0437\u0430\u0434.</p> <pre><code>async def error_window(user_id: int, message_text: str, button_text: str, callback_data: str) -&gt; None:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=button_text, callback_data=callback_data))\n    reply_markup = builder.as_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=message_text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>\u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435: \u0418\u043d\u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043e \u0432\u043e\u0437\u043d\u0438\u043a\u0448\u0435\u0439 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0435.</li> <li>\u041a\u043d\u043e\u043f\u043a\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0430: \u041f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u0432\u0442\u043e\u0440\u0438\u0442\u044c \u043d\u0435\u0443\u0434\u0430\u0447\u043d\u043e\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u0438\u043b\u0438 \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u043a \u0434\u0440\u0443\u0433\u043e\u043c\u0443 \u0440\u0430\u0437\u0434\u0435\u043b\u0443.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_18","title":"\u0423\u0442\u0438\u043b\u0438\u0442\u044b","text":"<p>\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0441 \u0446\u0435\u043b\u044c\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u044f \u0447\u0438\u0441\u0442\u043e\u0442\u044b \u0432 \u0447\u0430\u0442\u0435.</p> <pre><code>async def delete_last_message(user_id: int, message_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    last_message_id = (await state.get_data()).get(\"last_message_id\")\n\n    if last_message_id is not None:\n        with suppress(Exception):\n            await bot.delete_message(chat_id=user_id, message_id=last_message_id)\n\n    await state.update_data(last_message_id=message_id)\n</code></pre> <ul> <li>\u041d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435: \u041e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f, \u0443\u043b\u0443\u0447\u0448\u0430\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u043e\u043f\u044b\u0442.</li> <li>\u0424\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u044c:<ul> <li>\u0418\u0437\u0432\u043b\u0435\u043a\u0430\u0435\u0442 ID \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0438\u0437 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f.</li> <li>\u041f\u044b\u0442\u0430\u0435\u0442\u0441\u044f \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0435\u0441\u043b\u0438 \u043e\u043d\u043e \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442.</li> <li>\u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043d\u043e\u0432\u044b\u043c ID \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.</li> </ul> </li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#tonconnect_1","title":"\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0438 TonConnect","text":"<p>TonConnect \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439, \u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0445 \u0441 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u043c. \u0412 \u044d\u0442\u043e\u043c \u0440\u0430\u0437\u0434\u0435\u043b\u0435 \u043e\u043f\u0438\u0441\u0430\u043d\u043e, \u043a\u0430\u043a \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0442\u044c \u0442\u0430\u043a\u0438\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0432\u043d\u0443\u0442\u0440\u0438 \u0432\u0430\u0448\u0435\u0433\u043e \u0431\u043e\u0442\u0430.</p>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_19","title":"\u0421\u043e\u0431\u044b\u0442\u0438\u0435 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f","text":"<p>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</p> <pre><code>@tc.on_event(Event.CONNECT)\nasync def connect_event(user_id: int) -&gt; None:\n    await wallet_connected_window(user_id)\n</code></pre> <ul> <li>\u0422\u0440\u0438\u0433\u0433\u0435\u0440: \u0421\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u0440\u0438 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</li> <li>\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435: \u041f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0451\u043d\u043d\u043e\u043c \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435 \u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_20","title":"\u0421\u043e\u0431\u044b\u0442\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f","text":"<p>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043e\u0448\u0438\u0431\u043e\u043a, \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u044e\u0449\u0438\u0445 \u043f\u0440\u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</p> <pre><code>@tc.on_event(EventError.CONNECT)\nasync def connect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = \"You rejected the wallet connection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = \"Connection request timed out.\"\n    else:\n        message_text = f\"Connection error. Error: {error.message}\"\n    await error_window(user_id, message_text, button_text, callback_data)\n</code></pre> <ul> <li>\u0422\u0438\u043f\u044b \u043e\u0448\u0438\u0431\u043e\u043a:<ul> <li>UserRejectsError: \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043e\u0442\u043a\u043b\u043e\u043d\u0438\u043b \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435.</li> <li>RequestTimeoutError: \u0412\u0440\u0435\u043c\u044f \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u0438\u0441\u0442\u0435\u043a\u043b\u043e.</li> <li>\u0414\u0440\u0443\u0433\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438: \u041e\u0431\u0449\u0438\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u043f\u0440\u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438.</li> </ul> </li> <li>\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435: \u041f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435 \u0441 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u043f\u043e\u0432\u0442\u043e\u0440\u0438\u0442\u044c \u043f\u043e\u043f\u044b\u0442\u043a\u0443.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_21","title":"\u0421\u043e\u0431\u044b\u0442\u0438\u0435 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f","text":"<p>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</p> <pre><code>@tc.on_event(Event.DISCONNECT)\nasync def disconnect_event(user_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    await connect_wallet_window(state, user_id)\n</code></pre> <ul> <li>\u0422\u0440\u0438\u0433\u0433\u0435\u0440: \u0421\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u0440\u0438 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u043c \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</li> <li>\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435: \u041f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043a\u043e\u0448\u0435\u043b\u0451\u043a.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_22","title":"\u0421\u043e\u0431\u044b\u0442\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f","text":"<p>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043e\u0448\u0438\u0431\u043e\u043a, \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u044e\u0449\u0438\u0445 \u043f\u0440\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</p> <pre><code>@tc.on_event(EventError.DISCONNECT)\nasync def disconnect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = \"You rejected the wallet disconnection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = \"Disconnect request timed out.\"\n    else:\n        message_text = f\"Disconnect error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n</code></pre> <ul> <li>\u0422\u0438\u043f\u044b \u043e\u0448\u0438\u0431\u043e\u043a:<ul> <li>UserRejectsError: \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043e\u0442\u043a\u043b\u043e\u043d\u0438\u043b \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435.</li> <li>RequestTimeoutError: \u0412\u0440\u0435\u043c\u044f \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u043d\u0430 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0438\u0441\u0442\u0435\u043a\u043b\u043e.</li> <li>\u0414\u0440\u0443\u0433\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438: \u041e\u0431\u0449\u0438\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u043f\u0440\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438.</li> </ul> </li> <li>\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435: \u041f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435 \u0441 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u043f\u043e\u0432\u0442\u043e\u0440\u0438\u0442\u044c \u043f\u043e\u043f\u044b\u0442\u043a\u0443.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_23","title":"\u0421\u043e\u0431\u044b\u0442\u0438\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438","text":"<p>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</p> <pre><code>@tc.on_event(Event.TRANSACTION)\nasync def transaction_event(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    await transaction_sent_window(user_id, transaction)\n</code></pre> <ul> <li>\u0422\u0440\u0438\u0433\u0433\u0435\u0440: \u0421\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u0440\u0438 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</li> <li>\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435: \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_24","title":"\u0421\u043e\u0431\u044b\u0442\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438","text":"<p>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043e\u0448\u0438\u0431\u043e\u043a, \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u044e\u0449\u0438\u0445 \u043f\u0440\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</p> <pre><code>@tc.on_event(EventError.TRANSACTION)\nasync def transaction_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"main_menu\"\n    if isinstance(error, UserRejectsError):\n        message_text = \"You rejected the transaction.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = \"Transaction request timed out.\"\n    else:\n        message_text = f\"Transaction error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n</code></pre> <ul> <li>\u0422\u0438\u043f\u044b \u043e\u0448\u0438\u0431\u043e\u043a:<ul> <li>UserRejectsError: \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043e\u0442\u043a\u043b\u043e\u043d\u0438\u043b \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e.</li> <li>RequestTimeoutError: \u0412\u0440\u0435\u043c\u044f \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u043d\u0430 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e \u0438\u0441\u0442\u0435\u043a\u043b\u043e.</li> <li>\u0414\u0440\u0443\u0433\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438: \u041e\u0431\u0449\u0438\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u043f\u0440\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</li> </ul> </li> <li>\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435: \u041f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435 \u0441 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_25","title":"\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0438 \u0431\u043e\u0442\u0430","text":"<p>\u0417\u0434\u0435\u0441\u044c \u043f\u043e\u043a\u0430\u0437\u0430\u043d\u043e, \u043a\u0430\u043a \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0431\u043e\u0442\u0430 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0443\u044e\u0442 \u043f\u0440\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0435 \u0440\u0430\u0437\u043d\u044b\u0445 \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0435\u0432.</p>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#start","title":"\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043a\u043e\u043c\u0430\u043d\u0434\u044b /start","text":"<p>\u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 /start \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0438\u043b\u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u043f\u0440\u0438 \u0443\u0436\u0435 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0451\u043d\u043d\u043e\u043c \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435.</p> <pre><code>@dp.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(message.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n    if connector.is_transaction_pending(rpc_request_id):\n        connector.cancel_pending_transaction(rpc_request_id)\n\n    if not connector.connected:\n        await connect_wallet_window(state, message.from_user.id)\n    else:\n        await wallet_connected_window(message.from_user.id)\n</code></pre> <ul> <li>\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f: \u041f\u043e\u0434\u0433\u043e\u0442\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u043a\u043e\u043d\u043d\u0435\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f.</li> <li>\u041e\u0436\u0438\u0434\u0430\u044e\u0449\u0438\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438: \u041e\u0442\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438, \u0447\u0442\u043e\u0431\u044b \u0438\u0437\u0431\u0435\u0436\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u043b\u0438\u043a\u0442\u043e\u0432.</li> <li>\u0421\u0442\u0430\u0442\u0443\u0441 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f: \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442, \u043d\u0443\u0436\u043d\u043e \u043b\u0438 \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0438\u0442\u044c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 \u0438\u043b\u0438 \u043f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#callback-","title":"\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a callback-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432","text":"<p>\u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 callback-\u0437\u0430\u043f\u0440\u043e\u0441\u044b, \u043f\u043e\u0441\u0442\u0443\u043f\u0430\u044e\u0449\u0438\u0435 \u0441 inline-\u043a\u043d\u043e\u043f\u043e\u043a.</p> <pre><code>@dp.callback_query()\nasync def callback_query_handler(callback_query: CallbackQuery, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(callback_query.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n\n    if callback_query.data.startswith(\"app_wallet:\"):\n        selected_wallet = callback_query.data.split(\":\")[1]\n        await state.update_data(selected_wallet=selected_wallet)\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"main_menu\":\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"connect_wallet\":\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"disconnect_wallet\":\n        connector.add_event_kwargs(Event.DISCONNECT, state=state)\n        await connector.disconnect_wallet()\n\n    elif callback_query.data == \"cancel_transaction\":\n        if connector.is_transaction_pending(rpc_request_id):\n            connector.cancel_pending_transaction(rpc_request_id)\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"send_transaction\":\n        rpc_request_id = await connector.send_transfer(\n            destination=connector.account.address,\n            amount=0.000000001,\n            body=\"Hello from tonutils!\",\n        )\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    elif callback_query.data == \"send_batch_transaction\":\n        transfer_data = [\n            TransferData(\n                destination=connector.account.address,\n                amount=0.000000001,\n                body=\"Hello from tonutils!\",\n            ) for _ in range(4)\n        ]\n        rpc_request_id = await connector.send_batch_transfer(transfer_data)\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    await callback_query.answer()\n</code></pre> <ul> <li>\u0412\u044b\u0431\u043e\u0440 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430 (<code>app_wallet</code>): \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0439 \u043a\u043e\u0448\u0435\u043b\u0451\u043a \u0438 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043f\u0435\u0440\u0435\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f.</li> <li>\u0413\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e (<code>main_menu</code>): \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u043e\u043a\u043d\u043e \u0441 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0451\u043d\u043d\u044b\u043c \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u043c.</li> <li>\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043a\u043e\u0448\u0435\u043b\u0451\u043a (<code>connect_wallet</code>): \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</li> <li>\u041e\u0442\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043a\u043e\u0448\u0435\u043b\u0451\u043a (<code>disconnect_wallet</code>): \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</li> <li>\u041e\u0442\u043c\u0435\u043d\u0430 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438 (<code>cancel_transaction</code>): \u041e\u0442\u043c\u0435\u043d\u044f\u0435\u0442 \u043e\u0436\u0438\u0434\u0430\u044e\u0449\u0443\u044e \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0432 \u043e\u043a\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0451\u043d\u043d\u043e\u0433\u043e   \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</li> <li>\u041e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e (<code>send_transaction</code>): \u0418\u043d\u0438\u0446\u0438\u0438\u0440\u0443\u0435\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0443 \u043e\u0434\u043d\u043e\u0439 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438 \u0438 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e   \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044c \u0435\u0451.</li> <li>\u041f\u0430\u043a\u0435\u0442\u043d\u0430\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439 (<code>send_batch_transaction</code>): \u0418\u043d\u0438\u0446\u0438\u0438\u0440\u0443\u0435\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0443 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439 \u0438 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442   \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u0435.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_26","title":"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u043e\u0442\u0430","text":"<p>\u0412 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u0435 \u043e\u0441\u043d\u043e\u0432\u043d\u0443\u044e \u0442\u043e\u0447\u043a\u0443 \u0432\u0445\u043e\u0434\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u0431\u043e\u0442\u0430.</p> <pre><code>async def main():\n    await dp.start_polling(bot)\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre> <ul> <li>\u041e\u0441\u043d\u043e\u0432\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f: \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 polling \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0445 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0439 \u043e\u0442 Telegram.</li> <li>\u0422\u043e\u0447\u043a\u0430 \u0432\u0445\u043e\u0434\u0430: \u041e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0435\u0442 \u0437\u0430\u043f\u0443\u0441\u043a \u0431\u043e\u0442\u0430 \u043f\u0440\u0438 \u043f\u0440\u044f\u043c\u043e\u043c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u0441\u043a\u0440\u0438\u043f\u0442\u0430.</li> </ul>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_27","title":"\u041f\u043e\u043b\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440","text":"<p>\u0414\u043b\u044f \u0441\u043f\u0440\u0430\u0432\u043a\u0438 \u043f\u0440\u0438\u0432\u0435\u0434\u0451\u043d \u043f\u043e\u043b\u043d\u044b\u0439 \u0441\u043a\u0440\u0438\u043f\u0442 <code>bot.py</code>, \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u044f\u044e\u0449\u0438\u0439 \u0432\u0441\u0435 \u043e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u0435 \u0432\u044b\u0448\u0435 \u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442\u044b.</p> <pre><code># bot.py\nimport base64\nfrom contextlib import suppress\nfrom typing import List\n\nfrom aiogram import Dispatcher, Bot\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.filters import CommandStart\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.storage.redis import RedisStorage\nfrom aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, CallbackQuery\nfrom aiogram.utils.keyboard import InlineKeyboardBuilder\nfrom aiogram.utils.markdown import hide_link, hcode\nfrom redis.asyncio import Redis\n\nfrom storage import TCRedisStorage\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.models import WalletApp, Event, EventError, SendTransactionResponse\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\nfrom tonutils.wallet.data import TransferData\n\nBOT_TOKEN = \"your bot token\"\nREDIS_DSN = \"redis://localhost:6379\"\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\nredis = Redis.from_url(url=REDIS_DSN)\ndp = Dispatcher(storage=RedisStorage(redis))\nbot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=\"HTML\"))\ntc = TonConnect(storage=TCRedisStorage(redis), manifest_url=TC_MANIFEST_URL,\n                wallets_fallback_file_path=\"./wallets.json\")\n\n\nasync def delete_last_message(user_id: int, message_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    last_message_id = (await state.get_data()).get(\"last_message_id\")\n\n    if last_message_id is not None:\n        with suppress(Exception):\n            await bot.delete_message(chat_id=user_id, message_id=last_message_id)\n\n    await state.update_data(last_message_id=message_id)\n\n\ndef _connect_wallet_markup(\n        wallets: List[WalletApp],\n        selected_wallet: WalletApp,\n        connect_url: str,\n) -&gt; InlineKeyboardMarkup:\n    wallets_button = [\n        *[\n            InlineKeyboardButton(\n                text=f\"\u2022 {wallet.name} \u2022\" if wallet.app_name == selected_wallet.app_name else wallet.name,\n                callback_data=f\"app_wallet:{wallet.app_name}\",\n            ) for wallet in wallets\n        ]\n    ]\n    connect_wallet_button = InlineKeyboardButton(\n        text=f\"Connect {selected_wallet.name}\",\n        url=connect_url,\n    )\n    builder = InlineKeyboardBuilder()\n    builder.row(connect_wallet_button)\n    builder.row(*wallets_button, width=2)\n\n    return builder.as_markup()\n\n\ndef _confirm_transaction_markup(url: str, wallet_name: str) -&gt; InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(\n        inline_keyboard=[\n            [InlineKeyboardButton(text=f\"Open {wallet_name}\", url=url)],\n            [InlineKeyboardButton(text=f\"Cancel\", callback_data=\"cancel_transaction\")],\n        ]\n    )\n\n\ndef _choose_action_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Send transaction\", callback_data=\"send_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Send batch transaction\", callback_data=\"send_batch_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Disconnect wallet\", callback_data=\"disconnect_wallet\"))\n\n    return builder.as_markup()\n\n\ndef _go_to_main_menu_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Main menu\", callback_data=\"main_menu\"))\n\n    return builder.as_markup()\n\n\nasync def connect_wallet_window(state: FSMContext, user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    state_data = await state.get_data()\n    wallets = await tc.get_wallets()\n\n    selected_wallet = state_data.get(\"selected_wallet\", wallets[0].app_name)\n    selected_wallet = next(w for w in wallets if w.app_name == selected_wallet)\n    connect_url = await connector.connect_wallet(wallet_app=selected_wallet)\n\n    qrcode_url = (\n        f\"https://qrcode.ness.su/create?\"\n        f\"box_size=20&amp;border=7&amp;image_padding=20\"\n        f\"&amp;data={base64.b64encode(connect_url.encode()).decode()}\"\n        f\"&amp;image_url={base64.b64encode(selected_wallet.image.encode()).decode()}\"\n    )\n\n    text = f\"{hide_link(qrcode_url)}Connect your wallet!\"\n    reply_markup = _connect_wallet_markup(wallets, selected_wallet, connect_url)\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def wallet_connected_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    wallet_address = connector.wallet.account.address.to_str(is_bounceable=False)\n\n    reply_markup = _choose_action_markup()\n    text = f\"Connected wallet:\\n{hcode(wallet_address)}\\n\\nChoose an action:\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def send_transaction_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    reply_markup = _confirm_transaction_markup(\n        url=connector.wallet_app.direct_url,\n        wallet_name=connector.wallet_app.name,\n    )\n\n    text = \"Please confirm the transaction in your wallet.\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def transaction_sent_window(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    text = (\n        \"Transaction sent!\\n\\n\"\n        f\"Transaction msg hash:\\n{hcode(transaction.normalized_hash)}\\n\"\n        f\"Transaction BoC:\\n{hcode(transaction.boc)}\\n\"\n    )\n    reply_markup = _go_to_main_menu_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def error_window(user_id: int, message_text: str, button_text: str, callback_data: str) -&gt; None:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=button_text, callback_data=callback_data))\n    reply_markup = builder.as_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=message_text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\n@tc.on_event(Event.CONNECT)\nasync def connect_event(user_id: int) -&gt; None:\n    await wallet_connected_window(user_id)\n\n\n@tc.on_event(EventError.CONNECT)\nasync def connect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = f\"You rejected the wallet connection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = f\"Connection request timed out.\"\n    else:\n        message_text = f\"Connection error. Error: {error.message}\"\n    await error_window(user_id, message_text, button_text, callback_data)\n\n\n@tc.on_event(Event.DISCONNECT)\nasync def disconnect_event(user_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    await connect_wallet_window(state, user_id)\n\n\n@tc.on_event(EventError.DISCONNECT)\nasync def disconnect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = f\"You rejected the wallet disconnection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = f\"Disconnect request timed out.\"\n    else:\n        message_text = f\"Disconnect error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n\n\n@tc.on_event(Event.TRANSACTION)\nasync def transaction_event(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    await transaction_sent_window(user_id, transaction)\n\n\n@tc.on_event(EventError.TRANSACTION)\nasync def transaction_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"main_menu\"\n    if isinstance(error, UserRejectsError):\n        message_text = f\"You rejected the transaction.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = f\"Transaction request timed out.\"\n    else:\n        message_text = f\"Transaction error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n\n\n@dp.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(message.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n    if connector.is_transaction_pending(rpc_request_id):\n        connector.cancel_pending_transaction(rpc_request_id)\n\n    if not connector.connected:\n        await connect_wallet_window(state, message.from_user.id)\n    else:\n        await wallet_connected_window(message.from_user.id)\n\n\n@dp.callback_query()\nasync def callback_query_handler(callback_query: CallbackQuery, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(callback_query.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n\n    if callback_query.data.startswith(\"app_wallet:\"):\n        selected_wallet = callback_query.data.split(\":\")[1]\n        await state.update_data(selected_wallet=selected_wallet)\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"main_menu\":\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"connect_wallet\":\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"disconnect_wallet\":\n        connector.add_event_kwargs(Event.DISCONNECT, state=state)\n        await connector.disconnect_wallet()\n\n    elif callback_query.data == \"cancel_transaction\":\n        if connector.is_transaction_pending(rpc_request_id):\n            connector.cancel_pending_transaction(rpc_request_id)\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"send_transaction\":\n        rpc_request_id = await connector.send_transfer(\n            destination=connector.account.address,\n            amount=0.000000001,\n            body=\"Hello from tonutils!\",\n        )\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    elif callback_query.data == \"send_batch_transaction\":\n        transfer_data = [\n            TransferData(\n                destination=connector.account.address,\n                amount=0.000000001,\n                body=\"Hello from tonutils!\",\n            ) for _ in range(4)\n        ]\n        rpc_request_id = await connector.send_batch_transfer(transfer_data)\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    await callback_query.answer()\n\n\nasync def main():\n    await dp.start_polling(bot)\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/guide/ton-connect/telegram-bot-integration/#_28","title":"\u0417\u0430\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435","text":"<p>\u0421\u043b\u0435\u0434\u0443\u044f \u044d\u0442\u043e\u043c\u0443 \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u0443, \u0432\u044b \u0441\u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0438\u043d\u0442\u0435\u0433\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c TonConnect \u0432 \u0441\u0432\u043e\u0439 Telegram-\u0431\u043e\u0442, \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432 \u0443\u0434\u043e\u0431\u043d\u043e\u0435 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044f\u043c\u0438.</p>"},{"location":"ru/guide/ton-connect/wallet-connection/","title":"\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u042d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043a\u0440\u0430\u0442\u043a\u0438\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 \u043f\u043e \u0438\u043d\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u0438 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435\u043c \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c <code>TonConnect</code> \u0438\u0437 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 <code>tonutils</code>. \u041d\u0435\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e \u043e\u0442 \u0442\u043e\u0433\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0435\u0441\u044c \u043b\u0438 \u0432\u044b \u043d\u0430\u0447\u0438\u043d\u0430\u044e\u0449\u0438\u043c \u0438\u043b\u0438 \u043e\u043f\u044b\u0442\u043d\u044b\u043c \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c, \u044d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043f\u043e\u043c\u043e\u0436\u0435\u0442 \u0432\u0430\u043c \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</p>"},{"location":"ru/guide/ton-connect/wallet-connection/#_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430","text":"<p>\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 Python-\u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e <code>pip</code>:</p> <pre><code>pip install tonutils aiofiles\n</code></pre>"},{"location":"ru/guide/ton-connect/wallet-connection/#_2","title":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f","text":""},{"location":"ru/guide/ton-connect/wallet-connection/#tonconnect","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442\u0430 TonConnect","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 JSON-\u0444\u0430\u0439\u043b, \u043e\u043f\u0438\u0441\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u0432\u0430\u0448\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435. \u041e\u043d \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0442\u044c\u0441\u044f \u0432 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0435 \u043f\u0440\u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438.</p> <pre><code>{\n  \"url\": \"&lt;app-url&gt;\",                        // required\n  \"name\": \"&lt;app-name&gt;\",                      // required\n  \"iconUrl\": \"&lt;app-icon-url&gt;\",               // required\n  \"termsOfUseUrl\": \"&lt;terms-of-use-url&gt;\",     // optional\n  \"privacyPolicyUrl\": \"&lt;privacy-policy-url&gt;\" // optional\n}\n</code></pre> <p>Note</p> <p>\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u0444\u0430\u0439\u043b \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043f\u043e-\u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u043c\u0443 URL.</p>"},{"location":"ru/guide/ton-connect/wallet-connection/#_3","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430","text":"<p>\u0414\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 <code>FileStorage</code>.</p> <pre><code>import json\nimport os\nfrom asyncio import Lock\nfrom typing import Optional, Dict\n\nimport aiofiles\n\nfrom tonutils.tonconnect import IStorage\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n</code></pre>"},{"location":"ru/guide/ton-connect/wallet-connection/#tonconnect_1","title":"\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f TonConnect","text":"<p>\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 <code>TonConnect</code>, \u043f\u0435\u0440\u0435\u0434\u0430\u0432 \u043c\u0430\u043d\u0438\u0444\u0435\u0441\u0442 \u0438 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435.</p> <pre><code>from storage import FileStorage\n\nfrom tonutils.tonconnect import TonConnect\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n</code></pre>"},{"location":"ru/guide/ton-connect/wallet-connection/#_4","title":"\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0441\u043e\u0431\u044b\u0442\u0438\u0439","text":"<p>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u0430 \u0434\u043b\u044f \u0440\u0435\u0430\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043d\u0430 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0438 \u043e\u0448\u0438\u0431\u043a\u0438, \u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0435 \u0441 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u043c. \u0421\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0434\u0432\u0430 \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u0445 \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439: \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440\u043e\u0432 \u0438 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043d\u044b\u0445 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u043e\u0432.</p>"},{"location":"ru/guide/ton-connect/wallet-connection/#_5","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440\u043e\u0432","text":"<p>\u0414\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440\u044b \u0441\u0432\u044f\u0437\u044b\u0432\u0430\u044e\u0442 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0438 \u0441 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u043c\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u044f\u043c\u0438. \u042d\u0442\u043e\u0442 \u043c\u0435\u0442\u043e\u0434 \u043f\u0440\u043e\u0441\u0442 \u0438 \u043f\u043e\u043c\u043e\u0433\u0430\u0435\u0442 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043b\u043e\u0433\u0438\u043a\u0443 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439.</p> <pre><code>@tc.on_event(Event.CONNECT)\nasync def on_wallet_connect(user_id: int, wallet: WalletInfo) -&gt; None:\n    wallet_address = wallet.account.address.to_str(is_bounceable=False)\n    print(f\"Wallet {wallet_address} connected to user {user_id}.\")\n</code></pre>"},{"location":"ru/guide/ton-connect/wallet-connection/#_6","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043d\u044b\u0445 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u043e\u0432","text":"<p>\u041a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043d\u044b\u0435 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u044b \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u044e\u0442 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u0438\u0440\u0443\u0435\u043c\u0443\u044e \u0441\u0440\u0435\u0434\u0443 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439, \u0433\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u044f \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u0443\u044e \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u0438 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u0440\u0430\u0431\u043e\u0442\u044b.</p> <pre><code>async with connector.connect_wallet_context() as response:\n    if isinstance(response, TonConnectError):\n        print(f\"Connection error: {response.message}\")\n    else:\n        print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n</code></pre>"},{"location":"ru/guide/ton-connect/wallet-connection/#_7","title":"\u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432","text":"<p>\u0412 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445 \u043c\u043e\u0436\u0435\u0442 \u043f\u043e\u0442\u0440\u0435\u0431\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u043b\u0438 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 \u0432 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u2014 \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0442\u0435\u0433\u0438, \u0437\u0430\u043c\u0435\u0442\u043a\u0438 \u0438\u043b\u0438 \u0444\u043b\u0430\u0433\u0438.</p> <p>\u042d\u0442\u043e \u043c\u043e\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043c\u0435\u0442\u043e\u0434\u0430 <code>connector.add_event_kwargs</code>, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043a\u0440\u0435\u043f\u043b\u044f\u0435\u0442 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b, \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0432\u043c\u0435\u0441\u0442\u0435 \u0441\u043e \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u043c\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\u0438.</p> <p>\u0428\u0430\u0433 1: \u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b</p> <p>\u0412\u044b\u0437\u043e\u0432\u0438\u0442\u0435 <code>add_event_kwargs</code> \u043f\u0435\u0440\u0435\u0434 \u0437\u0430\u043f\u0443\u0441\u043a\u043e\u043c \u0438\u043b\u0438 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u0435\u043c \u0441\u043e\u0431\u044b\u0442\u0438\u044f:</p> <pre><code>connector.add_event_kwargs(\n    event=Event.CONNECT,\n    comment=\"Hello from tonutils!\",\n)\n</code></pre> <p>\u0428\u0430\u0433 2: \u041e\u0431\u043d\u043e\u0432\u0438\u0442\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432</p> <p>\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0442\u0430\u043a, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u043b \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b:</p> <pre><code>@tc.on_event(Event.CONNECT)\nasync def on_wallet_connect(user_id: int, wallet: WalletInfo, comment: str) -&gt; None:\n    print(f\"Comment: {comment}\")\n</code></pre> <p>\u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043c\u043e\u043c\u0435\u043d\u0442\u044b:</p> <ul> <li>\u041c\u043e\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 (\u043b\u044e\u0431\u044b\u0435 \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b).</li> <li>\u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0438\u043c\u0435\u043d\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432.</li> <li>\u042d\u0442\u043e\u0442 \u043c\u0435\u0445\u0430\u043d\u0438\u0437\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u0445 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 (<code>CONNECT</code>, <code>DISCONNECT</code>, <code>TRANSACTION</code> \u0438 \u0434\u0440.).</li> </ul>"},{"location":"ru/guide/ton-connect/wallet-connection/#_8","title":"\u041f\u043e\u043b\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440","text":"<p>\u041d\u0438\u0436\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0451\u043d \u043f\u043e\u043b\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440, \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u043a\u043e\u043d\u043d\u0435\u043a\u0442\u043e\u0440\u0430, \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u043c.</p> <pre><code>import json\nimport os\nfrom asyncio import Lock\nfrom typing import Dict, Optional\n\nimport aiofiles\n\nfrom tonutils.tonconnect import TonConnect, IStorage\nfrom tonutils.tonconnect.models import Event, EventError, WalletInfo\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"  # noqa\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n\n@tc.on_event(Event.CONNECT)\nasync def on_wallet_connect(user_id: int, wallet: WalletInfo) -&gt; None:\n    \"\"\"\n    Handler for successful wallet connection events.\n    Processes all successful wallet connections and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - wallet (WalletInfo): Wallet information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.CONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    Wallet details can be obtained from the following attributes:\n    - wallet.account (Account): Information about an account with an address, chain/network,\n                                wallet state_init, and optional public key information.\n    - wallet.ton_proof (TonProof): Verification details such as timestamp, domain information,\n                                   payload, and a signature.\n    - wallet.device (DeviceInfo): Information about a device associated with a wallet.\n    \"\"\"\n    wallet_address = wallet.account.address.to_str(is_bounceable=False)\n    print(f\"[CONNECT EVENT] Wallet {wallet_address} connected to user {user_id}.\")\n\n\n@tc.on_event(EventError.CONNECT)\nasync def on_wallet_connect_error(user_id: int, error: TonConnectError) -&gt; None:\n    \"\"\"\n    Handler for connection error events.\n    Processes all errors that occur when connecting wallets.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - error (TonConnectError): Error information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.CONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    The type of error can be determined using isinstance:\n    - UserRejectsError: User rejected the wallet connection.\n    - RequestTimeoutError: Wallet connection timed out.\n    \"\"\"\n    if isinstance(error, UserRejectsError):\n        print(f\"[CONNECT ERROR] User {user_id} rejected the wallet connection.\")\n    elif isinstance(error, RequestTimeoutError):\n        print(f\"[CONNECT ERROR] Connection request timed out for user {user_id}.\")\n    else:\n        print(f\"[CONNECT ERROR] Connection error for user {user_id}. Error: {error.message}\")\n\n\n@tc.on_event(Event.DISCONNECT)\nasync def on_wallet_disconnect(user_id: int, wallet: WalletInfo) -&gt; None:\n    \"\"\"\n    Handler for disconnected wallet events.\n    Processes all successful wallet disconnections and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - wallet (WalletInfo): Wallet information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.DISCONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n    \"\"\"\n    wallet_address = wallet.account.address.to_str(is_bounceable=False)\n    print(f\"[DISCONNECT EVENT] Wallet {wallet_address} disconnected from user {user_id}.\")\n\n\n@tc.on_event(EventError.DISCONNECT)\nasync def on_wallet_disconnect_error(user_id: int, error: TonConnectError) -&gt; None:\n    \"\"\"\n    Handler for disconnected wallet events.\n    Processes all successful wallet disconnections and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - error (TonConnectError): Error information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.DISCONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n    \"\"\"\n    if isinstance(error, RequestTimeoutError):\n        print(f\"[DISCONNECT ERROR] Disconnect request timed out for user {user_id}.\")\n    else:\n        print(f\"[DISCONNECT ERROR] Disconnect error for user {user_id}. Error: {error.message}\")\n\n\nasync def main() -&gt; None:\n    user_id = 12345  # Example user ID\n\n    # Initialize the connector for the user\n    connector = await tc.init_connector(user_id)\n\n    # Check if the wallet is already connected\n    if not connector.connected:\n        # Get all available wallets\n        wallets = await tc.get_wallets()\n\n        # As an example, we will select the wallet with index 1 (Tonkeeper)\n        selected_wallet = wallets[1]\n        connect_url = await connector.connect_wallet(selected_wallet)\n        print(f\"Please connect your wallet by visiting the following URL:\\n{connect_url}\")\n\n        # Add additional parameters to be passed to event handlers\n        connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")\n        # After this, you can use:\n        \"\"\"\n        @tc.on_event(Event.CONNECT)\n        async def on_wallet_connect(user_id: int, wallet: WalletInfo, comment: str) -&gt; None:...\n        \"\"\"\n\n        print(\"Waiting for wallet connection...\")\n        async with connector.connect_wallet_context() as response:\n            if isinstance(response, TonConnectError):\n                print(f\"Connection error: {response.message}\")\n            else:\n                print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n\n    else:\n        wallet_address = connector.account.address.to_str(is_bounceable=False)\n        print(f\"Wallet already connected: {wallet_address}\")\n\n        # Prompt the user to disconnect the wallet\n        user_input = input(\"Do you want to disconnect the wallet? (y/n): \").strip().lower()\n\n        if user_input == 'y':\n            # Disconnect the wallet\n            await connector.disconnect_wallet()\n            print(\"Wallet successfully disconnected.\")\n        else:\n            print(\"Wallet remains connected.\")\n\n    # Close all TonConnect connections\n    await tc.close_all()\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    try:\n        asyncio.run(main())\n    except (KeyboardInterrupt, SystemExit):\n        # Ensure all connections are closed in case of interruption\n        asyncio.run(tc.close_all())\n</code></pre>"},{"location":"ru/guide/ton-connect/wallet-connection/#ton-proof","title":"\u041f\u0440\u0438\u043c\u0435\u0440 Ton Proof","text":"<p>\u0427\u0442\u043e\u0431\u044b \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044c \u0432\u043b\u0430\u0434\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u043c, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 Ton Proof \u0434\u043b\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043f\u043e\u0434\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445.</p> <pre><code>from storage import FileStorage\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError\nfrom tonutils.tonconnect.utils.proof import generate_proof_payload, verify_proof_payload\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n\nasync def main() -&gt; None:\n    user_id = 1  # Example user ID\n\n    # Initialize the connector for the user\n    connector = await tc.init_connector(user_id)\n\n    # Generate the proof payload\n    proof_payload = generate_proof_payload()\n\n    # Check if the wallet is already connected\n    if not connector.connected:\n        # Get all available wallets\n        wallets = await tc.get_wallets()\n\n        # As an example, we will select the wallet with index 1 (Tonkeeper)\n        selected_wallet = wallets[1]\n        connect_url = await connector.connect_wallet(selected_wallet, ton_proof=proof_payload)\n        print(f\"Please connect your wallet by visiting the following URL:\\n{connect_url}\")\n\n        print(\"Waiting for wallet connection...\")\n        async with connector.connect_wallet_context() as response:\n            if isinstance(response, TonConnectError):\n                print(f\"Connection error: {response.message}\")\n            else:\n                if verify_proof_payload(proof_payload, connector.wallet):\n                    print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n                else:\n                    await connector.disconnect_wallet()\n                    print(\"Proof verification failed.\")\n\n    else:\n        wallet_address = connector.account.address.to_str(is_bounceable=False)\n        print(f\"Wallet already connected: {wallet_address}\")\n\n        # Prompt the user to disconnect the wallet\n        user_input = input(\"Do you want to disconnect the wallet? (y/n): \").strip().lower()\n\n        if user_input == 'y':\n            # Disconnect the wallet\n            await connector.disconnect_wallet()\n            print(\"Wallet successfully disconnected.\")\n        else:\n            print(\"Wallet remains connected.\")\n\n    # Close all TonConnect connections\n    await tc.close_all()\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    try:\n        asyncio.run(main())\n    except (KeyboardInterrupt, SystemExit):\n        # Ensure all connections are closed in case of interruption\n        asyncio.run(tc.close_all())\n</code></pre>"},{"location":"ru/guide/ton-connect/wallet-connection/#_9","title":"\u0417\u0430\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435","text":"<p>\u0421\u043b\u0435\u0434\u0443\u044f \u044d\u0442\u043e\u043c\u0443 \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u0443, \u0432\u044b \u0441\u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0438\u043d\u0442\u0435\u0433\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c TonConnect \u0432 \u0441\u0432\u043e\u0439 \u0441\u043a\u0440\u0438\u043f\u0442, \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432 \u0443\u0434\u043e\u0431\u043d\u043e\u0435 \u0438 \u043d\u0430\u0434\u0451\u0436\u043d\u043e\u0435 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432.</p>"},{"location":"ru/how-to/create-multiple-wallets/","title":"\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432","text":"<p>\u042d\u0442\u043e\u0442 \u043f\u0440\u0438\u043c\u0435\u0440 \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u0435\u0442, \u043a\u0430\u043a \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0438\u0437 \u043e\u0434\u043d\u043e\u0439 \u043c\u043d\u0435\u043c\u043e\u043d\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0444\u0440\u0430\u0437\u044b \u043f\u0443\u0442\u0451\u043c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f <code>subwallet_id</code>. \u041a\u0430\u0436\u0434\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 <code>subwallet_id</code> \u0441\u043e\u0437\u0434\u0430\u0451\u0442 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u0434\u0440\u0435\u0441 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043e\u0434\u043d\u043e\u0439 \u0438 \u0442\u043e\u0439 \u0436\u0435 seed-\u0444\u0440\u0430\u0437\u044b.</p>"},{"location":"ru/how-to/create-multiple-wallets/#_1","title":"\u041f\u0440\u0438\u043c\u0435\u0440","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Subwallet ID\nWALLET_ID = 0\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC, WALLET_ID)\n\n    print(f\"Address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/how-to/create-multiple-wallets/#_2","title":"\u041f\u043e\u044f\u0441\u043d\u0435\u043d\u0438\u0435","text":"<ul> <li><code>subwallet_id</code> \u2192 32-\u0431\u0438\u0442\u043d\u043e\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0440\u0430\u0437\u043d\u044b\u0445 \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0438\u0437 \u043e\u0434\u043d\u043e\u0439 \u0438 \u0442\u043e\u0439 \u0436\u0435 \u043c\u043d\u0435\u043c\u043e\u043d\u0438\u043a\u0438.</li> <li> <p>\u041f\u0440\u0438\u043c\u0435\u0440\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f:</p> </li> <li> <p>\u0420\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u043f\u043e \u043b\u043e\u0433\u0438\u0447\u0435\u0441\u043a\u0438\u043c \u0430\u043a\u043a\u0430\u0443\u043d\u0442\u0430\u043c.</p> </li> <li>\u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u0434\u0435\u043b\u044c\u043d\u044b\u043c\u0438 \u0431\u0430\u043b\u0430\u043d\u0441\u0430\u043c\u0438.</li> <li>\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0445 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430\u043c\u0438.</li> </ul>"},{"location":"ru/how-to/create-multiple-wallets/#_3","title":"\u0412\u0430\u0436\u043d\u044b\u0435 \u0437\u0430\u043c\u0435\u0447\u0430\u043d\u0438\u044f","text":"<ul> <li> <p><code>subwallet_id</code> (\u0438\u043b\u0438 <code>wallet_id</code>) \u043d\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0442\u0438\u043f\u0430\u0445 \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432:</p> <ul> <li><code>WalletV2*</code></li> <li><code>PreprocessedWallet*</code></li> </ul> </li> <li> <p>\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f <code>wallet_id</code> \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e:</p> <ul> <li>\u0412\u0441\u0435 \u0442\u0438\u043f\u044b \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u043e\u0432, \u043a\u0440\u043e\u043c\u0435 <code>WalletV5R1</code> \u2192 <code>698983191</code></li> <li> <p>\u0414\u043b\u044f <code>WalletV5R1</code>:</p> global_id workchain wallet_version subwallet_number wallet_id -239 0 0 0 2147483409 -239 -1 0 0 8388369 -3 0 0 0 2147483645 -3 -1 0 0 8388605 </li> </ul> </li> </ul>"},{"location":"ru/how-to/get-contract-code-and-data/","title":"\u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u043e\u0434 \u0438 \u0434\u0430\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430","text":"<p>\u0427\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u043e\u0434 \u0438 \u0434\u0430\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430, \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u043e\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u044f\u043c\u0438 TON, \u0442\u0430\u043a\u0438\u043c\u0438 \u043a\u0430\u043a tonviewer.com, tonscan.org \u0438 \u0434\u0440., \u043b\u0438\u0431\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043c\u0435\u0442\u043e\u0434\u0430 <code>get_raw_account</code>.</p>"},{"location":"ru/how-to/get-contract-code-and-data/#ton","title":"\u0427\u0435\u0440\u0435\u0437 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u0438 TON","text":"<ol> <li>\u041f\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u043d\u0430 \u0441\u0430\u0439\u0442 Tonviewer.</li> <li>\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 \u0432 \u0441\u0442\u0440\u043e\u043a\u0443 \u043f\u043e\u0438\u0441\u043a\u0430.</li> <li>\u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 Code.</li> <li>\u0412 \u0440\u0430\u0437\u0434\u0435\u043b\u0435 Bytecode \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d \u043a\u043e\u0434 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430.</li> <li>\u0412 \u0440\u0430\u0437\u0434\u0435\u043b\u0435 Raw data \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u044b \u0434\u0430\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430.</li> </ol>"},{"location":"ru/how-to/get-contract-code-and-data/#get_raw_account","title":"\u0427\u0435\u0440\u0435\u0437 \u043c\u0435\u0442\u043e\u0434 <code>get_raw_account</code>","text":"<pre><code>from tonutils.client import ToncenterV3Client\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    contract_address = \"EQ...\"\n    account = await client.get_raw_account(contract_address)\n\n    # Print contract code (hex-encoded BOC)\n    print(account.code.to_boc().hex())\n\n    # Print contract data (hex-encoded BOC)\n    print(account.data.to_boc().hex())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre> <p>\u041e\u0431\u0437\u043e\u0440 \u043f\u043e\u043b\u0435\u0439 RawAccount</p>"},{"location":"ru/how-to/get-contract-information/","title":"\u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0435","text":"<p>\u042d\u0442\u043e\u0442 \u043f\u0440\u0438\u043c\u0435\u0440 \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u0435\u0442, \u043a\u0430\u043a \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043f\u043e\u043b\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0435, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u0431\u0430\u043b\u0430\u043d\u0441, \u0441\u0442\u0430\u0442\u0443\u0441, \u043a\u043e\u0434, \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</p>"},{"location":"ru/how-to/get-contract-information/#_1","title":"\u041f\u0440\u0438\u043c\u0435\u0440","text":"<pre><code>from tonutils.client import ToncenterV3Client\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    contract_address = \"EQ...\"\n\n    contract = await client.get_raw_account(contract_address)\n\n    print(f\"Balance: {contract.balance}\")\n    print(f\"Status: {contract.status}\")\n    print(f\"Code: {contract.code}\")\n    print(f\"Data: {contract.data}\")\n    print(f\"Last Transaction LT: {contract.last_transaction_lt}\")\n    print(f\"Last Transaction Hash: {contract.last_transaction_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/get-contract-information/#rawaccount","title":"\u041e\u0431\u0437\u043e\u0440 \u043f\u043e\u043b\u0435\u0439 <code>RawAccount</code>","text":"<ul> <li> <p>balance \u2192 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e (\u0432 nanoTON)   \u0422\u0435\u043a\u0443\u0449\u0438\u0439 \u0431\u0430\u043b\u0430\u043d\u0441 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430.</p> </li> <li> <p>status \u2192 \u0441\u0442\u0440\u043e\u043a\u0430   \u0421\u0442\u0430\u0442\u0443\u0441 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430, \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f:</p> <ul> <li><code>active</code> \u2192 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0438 \u0430\u043a\u0442\u0438\u0432\u0435\u043d</li> <li><code>nonexist</code> \u2192 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442</li> <li><code>frozen</code> \u2192 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u0437\u0430\u043c\u043e\u0440\u043e\u0436\u0435\u043d</li> <li><code>uninit</code> \u2192 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442, \u043d\u043e \u043d\u0435 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d</li> </ul> </li> <li> <p>code \u2192 <code>Cell</code> (\u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e)   \u0418\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u044b\u0439 \u043a\u043e\u0434 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 (\u0435\u0441\u043b\u0438 \u0435\u0441\u0442\u044c).</p> </li> <li> <p>data \u2192 <code>Cell</code> (\u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e)   \u041f\u0435\u0440\u0441\u0438\u0441\u0442\u0435\u043d\u0442\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 (\u0435\u0441\u043b\u0438 \u0435\u0441\u0442\u044c).</p> </li> <li> <p>last_transaction_lt \u2192 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e (\u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e)   \u041b\u043e\u0433\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f (LT) \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</p> </li> <li> <p>last_transaction_hash \u2192 \u0441\u0442\u0440\u043e\u043a\u0430 (\u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e)   \u0425\u0435\u0448 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0438.</p> </li> <li> <p>state_init \u2192 <code>StateInit</code> (\u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e)   \u041e\u0431\u044a\u0435\u0434\u0438\u043d\u0451\u043d\u043d\u044b\u0439 \u043e\u0431\u044a\u0435\u043a\u0442, \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0439 \u043f\u043e\u043b\u043d\u043e\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430, \u0435\u0441\u043b\u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b \u0438 \u043a\u043e\u0434, \u0438 \u0434\u0430\u043d\u043d\u044b\u0435.</p> </li> </ul>"},{"location":"ru/how-to/get-jetton-wallet-address/","title":"\u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0430\u0434\u0440\u0435\u0441 Jetton \u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430","text":"<p>\u0421\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u043f\u043e\u0441\u043e\u0431\u043e\u0432 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0430\u0434\u0440\u0435\u0441 Jetton-\u043a\u043e\u0448\u0435\u043b\u044c\u043a\u0430.</p>"},{"location":"ru/how-to/get-jetton-wallet-address/#jetton","title":"\u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 Jetton","text":""},{"location":"ru/how-to/get-jetton-wallet-address/#get-","title":"\u0427\u0435\u0440\u0435\u0437 get-\u043c\u0435\u0442\u043e\u0434","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    owner_address = \"UQ...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = await JettonMasterStandard.get_wallet_address(\n        client,\n        owner_address,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/get-jetton-wallet-address/#_1","title":"\u041b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0441\u0447\u0451\u0442","text":"<p>Note</p> <p>\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u044c\u0442\u0435 \u043a\u043e\u0434 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 Jetton Wallet, \u0441\u043b\u0435\u0434\u0443\u044f \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 \u0438\u0437 \u0440\u0430\u0437\u0434\u0435\u043b\u0430 \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0434\u0430 \u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430.</p> <pre><code>from tonutils.jetton import JettonMasterStandard\n\n\ndef main() -&gt; None:\n    owner_address = \"UQ...\"\n    jetton_wallet_code = \"...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = JettonMasterStandard.calculate_user_jetton_wallet_address(\n        owner_address,\n        jetton_wallet_code,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/how-to/get-jetton-wallet-address/#stablecoin-jetton","title":"Stablecoin Jetton","text":"<p>\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, USD\u20ae, NOT</p>"},{"location":"ru/how-to/get-jetton-wallet-address/#get-_1","title":"\u0427\u0435\u0440\u0435\u0437 get-\u043c\u0435\u0442\u043e\u0434","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    owner_address = \"UQ...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = await JettonMasterStablecoin.get_wallet_address(\n        client,\n        owner_address,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/get-jetton-wallet-address/#_2","title":"\u041b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0441\u0447\u0451\u0442","text":"<p>Note</p> <p>\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u044c\u0442\u0435 \u043a\u043e\u0434 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 Jetton Wallet, \u0441\u043b\u0435\u0434\u0443\u044f \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 \u0438\u0437 \u0440\u0430\u0437\u0434\u0435\u043b\u0430 \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0434\u0430 \u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430.</p> <pre><code>from tonutils.jetton import JettonMasterStablecoin\n\n\ndef main() -&gt; None:\n    owner_address = \"UQ...\"\n    jetton_wallet_code = \"...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = JettonMasterStablecoin.calculate_user_jetton_wallet_address(\n        owner_address,\n        jetton_wallet_code,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/how-to/get-nft-item-address/","title":"\u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0430\u0434\u0440\u0435\u0441 NFT","text":"<p>\u0421\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u043f\u043e\u0441\u043e\u0431\u043e\u0432 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0430\u0434\u0440\u0435\u0441 NFT-\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430.</p>"},{"location":"ru/how-to/get-nft-item-address/#_1","title":"\u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0435 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438","text":""},{"location":"ru/how-to/get-nft-item-address/#get-","title":"\u0427\u0435\u0440\u0435\u0437 get-\u043c\u0435\u0442\u043e\u0434","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    nft_index = 1\n    collection_address = \"EQ...\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        nft_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/get-nft-item-address/#_2","title":"\u041b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0441\u0447\u0451\u0442","text":"<p>Note</p> <p>\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u044c\u0442\u0435 \u043a\u043e\u0434 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 NFT Item, \u0441\u043b\u0435\u0434\u0443\u044f \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 \u0438\u0437 \u0440\u0430\u0437\u0434\u0435\u043b\u0430 \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0434\u0430 \u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430.</p> <pre><code>from tonutils.nft import Collection\n\n\ndef main() -&gt; None:\n    nft_index = 1\n    nft_item_code = \"...\"\n    collection_address = \"EQ...\"\n\n    nft_address = Collection.calculate_nft_item_address(\n        nft_index,\n        nft_item_code,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/how-to/get-nft-item-address/#ton-dns-domains","title":"\u041a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u044f TON DNS Domains","text":"<p>Note</p> <p>\u0418\u043d\u0434\u0435\u043a\u0441 \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043a\u0430\u043a <code>slice_hash(name)</code>. \u041f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0441\u043c\u043e\u0442\u0440\u0438\u0442\u0435 \u0432 \u0440\u0430\u0437\u0434\u0435\u043b\u0435 \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0445\u0435\u0448-\u0444\u0443\u043d\u043a\u0446\u0438\u0439 FunC.</p>"},{"location":"ru/how-to/get-nft-item-address/#get-_1","title":"\u0427\u0435\u0440\u0435\u0437 get-\u043c\u0435\u0442\u043e\u0434","text":"<pre><code>from pytoniq_core import begin_cell\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\nfrom tonutils.utils import slice_hash\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    domain_name = \"temp\"\n    domain_index = slice_hash(begin_cell().store_string(domain_name))\n    collection_address = \"EQ...\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        domain_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/get-nft-item-address/#_3","title":"\u041b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0441\u0447\u0451\u0442","text":"<p>Note</p> <p>\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u044c\u0442\u0435 \u043a\u043e\u0434 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 NFT Item, \u0441\u043b\u0435\u0434\u0443\u044f \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 \u0438\u0437 \u0440\u0430\u0437\u0434\u0435\u043b\u0430 \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0434\u0430 \u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430.</p> <pre><code>from pytoniq_core import begin_cell\nfrom tonutils.nft import Collection\nfrom tonutils.utils import slice_hash\n\n\ndef main() -&gt; None:\n    domain_name = \"temp\"\n    domain_index = slice_hash(begin_cell().store_string(domain_name))\n    nft_item_code = \"...\"\n    collection_address = \"EQ...\"\n\n    nft_address = Collection.calculate_nft_item_address(\n        domain_index,\n        nft_item_code,\n        collection_address,\n        index_len=256,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/how-to/get-nft-item-address/#telegram-gifts-anonymous-telegram-numbers","title":"Telegram Gifts / Anonymous Telegram Numbers","text":"<p>Note</p> <p>\u0418\u043d\u0434\u0435\u043a\u0441 \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043a\u0430\u043a <code>string_hash(telemint_token_name)</code>. \u041f\u043e\u0434\u0440\u043e\u0431\u043d\u0435\u0435 \u0432 \u0440\u0430\u0437\u0434\u0435\u043b\u0435 \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0445\u0435\u0448-\u0444\u0443\u043d\u043a\u0446\u0438\u0439 FunC.</p>"},{"location":"ru/how-to/get-nft-item-address/#get-_2","title":"\u0427\u0435\u0440\u0435\u0437 get-\u043c\u0435\u0442\u043e\u0434","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\nfrom tonutils.utils import string_hash\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    telemint_token_name = \"8888888\"\n    token_index = string_hash(telemint_token_name)\n    collection_address = \"EQ...\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        token_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/get-nft-item-address/#_4","title":"\u041b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0441\u0447\u0451\u0442","text":"<p>Note</p> <p>\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u044c\u0442\u0435 \u043a\u043e\u0434 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 NFT Item, \u0441\u043b\u0435\u0434\u0443\u044f \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 \u0438\u0437 \u0440\u0430\u0437\u0434\u0435\u043b\u0430 \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0434\u0430 \u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430.</p> <pre><code>from tonutils.nft import Collection\nfrom tonutils.utils import string_hash\n\n\ndef main() -&gt; None:\n    telemint_token_name = \"8888888\"\n    token_index = string_hash(telemint_token_name)\n    nft_item_code = \"...\"\n    collection_address = \"EQ...\"\n\n    nft_address = Collection.calculate_nft_item_address(\n        token_index,\n        nft_item_code,\n        collection_address,\n        index_len=256,\n        is_telemint_token=True,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/how-to/send-claim-mintless-jetton/","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c/\u0417\u0430\u043f\u0440\u043e\u0441\u0438\u0442\u044c Mintless jetton","text":"<p>\u042d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0442\u043e\u043c, \u043a\u0430\u043a \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044c (claim) \u0438\u043b\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c Jetton Mintless \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c <code>TonapiClient</code>.</p> <p>Note</p> <p>\u0414\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c API-\u043a\u043b\u044e\u0447, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043d\u0430 tonconsole.com.</p>"},{"location":"ru/how-to/send-claim-mintless-jetton/#mintless-jetton","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c Mintless Jetton","text":"<pre><code>from typing import Any, Dict, Union\n\nimport aiohttp\nfrom aiohttp import ClientResponseError\nfrom pytoniq_core import Address, Cell, Slice, StateInit, begin_cell\n\nfrom tonutils.client import TonapiClient\nfrom tonutils.jetton import JettonWalletStandard\nfrom tonutils.utils import to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# API key for accessing the Tonapi (obtainable from https://tonconsole.com)\nAPI_KEY = \"\"\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Comment for transfer payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = TonapiClient(api_key=API_KEY)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_data = await get_jetton(client, wallet.address.to_str())\n    if jetton_data is None:\n        raise Exception(\"Jetton data not found. Are there jettons in this wallet?\")\n\n    jetton_balance = int(jetton_data[\"balance\"])\n    custom_payload_api_uri = jetton_data[\"jetton\"][\"custom_payload_api_uri\"]\n    jetton_custom_payload = await get_payload(custom_payload_api_uri, wallet.address.to_str())\n    jetton_wallet_address = jetton_custom_payload[\"jetton_wallet\"]\n\n    if not await is_claimed(client, jetton_wallet_address):\n        custom_payload = Cell.one_from_boc(jetton_custom_payload[\"custom_payload\"])\n        state_init = StateInit.deserialize(Slice.one_from_boc(jetton_custom_payload[\"state_init\"]))\n    else:\n        custom_payload = state_init = None\n\n    body = JettonWalletStandard.build_transfer_body(\n        recipient_address=Address(DESTINATION_ADDRESS),\n        response_address=wallet.address,\n        jetton_amount=jetton_balance,\n        custom_payload=custom_payload,\n        forward_payload=(\n            begin_cell()\n            .store_uint(0, 32)\n            .store_snake_string(COMMENT)\n            .end_cell()\n        ),\n        forward_amount=1,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_wallet_address,\n        amount=0.1,\n        body=body,\n        state_init=state_init,\n        bounce=True,\n    )\n\n    print(f\"Successfully transferred {to_amount(jetton_balance)} jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nasync def get_jetton(client: TonapiClient, addr: str) -&gt; Union[Dict[str, Any], None]:\n    method = f\"/v2/accounts/{addr}/jettons\"\n    params = {\"supported_extensions\": \"custom_payload\"}\n    try:\n        result = await client._request(\"GET\", path=method, params=params)  # noqa\n        return next(\n            (b for b in result.get(\"balances\", [])\n             if Address(b[\"jetton\"][\"address\"]) == Address(JETTON_MASTER_ADDRESS)),\n            None\n        )\n    except Exception as e:\n        print(f\"Error fetching jetton data: {e}\")\n        return None\n\n\nasync def get_payload(api_uri: str, wallet_address: str) -&gt; Dict[str, Any]:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"{api_uri}/wallet/{wallet_address}\") as response:\n            response.raise_for_status()\n            return await response.json()\n\n\nasync def is_claimed(client: TonapiClient, jetton_addr: str) -&gt; bool:\n    try:\n        result = await client.run_get_method(jetton_addr, \"is_claimed\")\n        return bool(result[0])\n    except ClientResponseError as e:\n        if e.status == 404:\n            return False\n        raise\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/send-claim-mintless-jetton/#mintless-jetton_1","title":"\u0417\u0430\u043f\u0440\u043e\u0441\u0438\u0442\u044c Mintless Jetton","text":"<pre><code>from typing import Any, Dict, Union\n\nimport aiohttp\nfrom aiohttp import ClientResponseError\nfrom pytoniq_core import Address, Cell, Slice, StateInit\n\nfrom tonutils.client import TonapiClient\nfrom tonutils.jetton import JettonWalletStandard\nfrom tonutils.utils import to_amount\nfrom tonutils.wallet import WalletV4R2\n\n# API key for accessing the Tonapi (obtainable from https://tonconsole.com)\nAPI_KEY = \"\"\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n    client = TonapiClient(api_key=API_KEY)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    jetton_data = await get_jetton(client, wallet.address.to_str())\n    if jetton_data is None:\n        raise Exception(\"Jetton data not found. Are there jettons in this wallet?\")\n\n    jetton_balance = int(jetton_data[\"balance\"])\n    custom_payload_api_uri = jetton_data[\"jetton\"][\"custom_payload_api_uri\"]\n    jetton_custom_payload = await get_payload(custom_payload_api_uri, wallet.address.to_str())\n    jetton_wallet_address = jetton_custom_payload[\"jetton_wallet\"]\n\n    if not await is_claimed(client, jetton_wallet_address):\n        custom_payload = Cell.one_from_boc(jetton_custom_payload[\"custom_payload\"])\n        state_init = StateInit.deserialize(Slice.one_from_boc(jetton_custom_payload[\"state_init\"]))\n    else:\n        print(\"Jetton already claimed!\")\n        return\n\n    body = JettonWalletStandard.build_transfer_body(\n        recipient_address=wallet.address,\n        response_address=wallet.address,\n        jetton_amount=jetton_balance,\n        custom_payload=custom_payload,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=jetton_wallet_address,\n        amount=0.1,\n        body=body,\n        state_init=state_init,\n        bounce=True,\n    )\n\n    print(f\"Successfully claimed {to_amount(jetton_balance)} jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nasync def get_jetton(client: TonapiClient, addr: str) -&gt; Union[Dict[str, Any], None]:\n    method = f\"/v2/accounts/{addr}/jettons\"\n    params = {\"supported_extensions\": \"custom_payload\"}\n    try:\n        result = await client._request(\"GET\", path=method, params=params)  # noqa\n        return next(\n            (b for b in result.get(\"balances\", [])\n             if Address(b[\"jetton\"][\"address\"]) == Address(JETTON_MASTER_ADDRESS)),\n            None\n        )\n    except Exception as e:\n        print(f\"Error fetching jetton data: {e}\")\n        return None\n\n\nasync def get_payload(api_uri: str, wallet_address: str) -&gt; Dict[str, Any]:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"{api_uri}/wallet/{wallet_address}\") as response:\n            response.raise_for_status()\n            return await response.json()\n\n\nasync def is_claimed(client: TonapiClient, jetton_addr: str) -&gt; bool:\n    try:\n        result = await client.run_get_method(jetton_addr, \"is_claimed\")\n        return bool(result[0])\n    except ClientResponseError as e:\n        if e.status == 404:\n            return False\n        raise\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/send-encrypted-message/","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u0437\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f","text":"<p>\u042d\u0442\u043e\u0442 \u043f\u0440\u0438\u043c\u0435\u0440 \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u0435\u0442, \u043a\u0430\u043a \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u043f\u0435\u0440\u0435\u0432\u043e\u0434 TON \u0441 \u0437\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0435\u043c. \u0417\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439 \u0433\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u0435\u0442, \u0447\u0442\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0431\u0443\u0434\u0435\u0442 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e \u0434\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u043e \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u0435\u043b\u044e.</p>"},{"location":"ru/how-to/send-encrypted-message/#_1","title":"\u041f\u0440\u0438\u043c\u0435\u0440","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the recipient wallet\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Amount to transfer in TON\nTRANSFER_AMOUNT = 0.01\n\n# Comment to include in the transfer payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    body = await wallet.build_encrypted_comment_body(\n        text=COMMENT,\n        destination=DESTINATION_ADDRESS,\n    )\n\n    tx_hash = await wallet.transfer(\n        destination=DESTINATION_ADDRESS,\n        amount=TRANSFER_AMOUNT,\n        body=body,\n    )\n\n    print(f\"Successfully transferred {TRANSFER_AMOUNT} TON to address {DESTINATION_ADDRESS}.\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/send-gasless-transaction/","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044e \u0431\u0435\u0437 \u043e\u043f\u043b\u0430\u0442\u044b \u0433\u0430\u0437\u0430","text":"<p>\u042d\u0442\u043e\u0442 \u043f\u0440\u0438\u043c\u0435\u0440 \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u0435\u0442, \u043a\u0430\u043a \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u043f\u0435\u0440\u0435\u0432\u043e\u0434 Jetton \u0431\u0435\u0437 \u043e\u043f\u043b\u0430\u0442\u044b \u0433\u0430\u0437\u0430 (gasless).</p> <p>Note</p> <p>\u041c\u0435\u0442\u043e\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e gasless relayer, \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c\u0443\u044e \u0441\u0435\u0440\u0432\u0438\u0441\u043e\u043c tonapi.io. \u0414\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c API-\u043a\u043b\u044e\u0447 \u043d\u0430 tonconsole.com.</p>"},{"location":"ru/how-to/send-gasless-transaction/#_1","title":"\u041f\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0442\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f","text":"<p>\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438:</p> <pre><code>pip install pytonapi\n</code></pre>"},{"location":"ru/how-to/send-gasless-transaction/#_2","title":"\u041f\u0440\u0438\u043c\u0435\u0440","text":"<pre><code>from pytonapi import AsyncTonapi\nfrom pytoniq_core import Address, Cell\n\nfrom tonutils.client import TonapiClient\nfrom tonutils.jetton import JettonMasterStandard, JettonWalletStandard\nfrom tonutils.utils import to_nano\nfrom tonutils.wallet import WalletV5R1\n\n# API key for accessing the Tonapi (obtainable from https://tonconsole.com)\nAPI_KEY = \"\"\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to transfer (in base units, considering decimals)\nJETTON_AMOUNT = 0.01\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Amount for jetton transfer.\nBASE_JETTON_SEND_AMOUNT = 0.05\n\n\nasync def main() -&gt; None:\n    tonapi, client = AsyncTonapi(api_key=API_KEY), TonapiClient(api_key=API_KEY)\n    wallet, public_key, private_key, _ = WalletV5R1.from_mnemonic(client, MNEMONIC)\n\n    gasless_config = await tonapi.gasless.get_config()\n    relayer_address = Address(gasless_config.relay_address)\n\n    jetton_wallet_address = await JettonMasterStandard.get_wallet_address(\n        client=client,\n        owner_address=wallet.address,\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n    )\n    tether_transfer_body = JettonWalletStandard.build_transfer_body(\n        jetton_amount=to_nano(JETTON_AMOUNT, JETTON_DECIMALS),\n        recipient_address=Address(DESTINATION_ADDRESS),\n        response_address=relayer_address,\n        forward_amount=1,\n    )\n    message_to_estimate = wallet.create_internal_msg(\n        dest=jetton_wallet_address,\n        value=to_nano(BASE_JETTON_SEND_AMOUNT),\n        body=tether_transfer_body,\n    )\n\n    sign_raw_params = await tonapi.gasless.estimate_gas_price(\n        master_id=JETTON_MASTER_ADDRESS,\n        body={\n            \"wallet_address\": wallet.address.to_str(),\n            \"wallet_public_key\": public_key.hex(),\n            \"messages\": [\n                {\n                    \"boc\": message_to_estimate.serialize().to_boc().hex(),\n                }\n            ]\n        }\n    )\n\n    try:\n        seqno = await WalletV5R1.get_seqno(client, wallet.address)\n    except (Exception,):\n        seqno = 0\n\n    tether_transfer_for_send = wallet.create_signed_internal_msg(\n        messages=[\n            wallet.create_wallet_internal_message(\n                destination=Address(message.address),\n                value=int(message.amount),\n                body=Cell.one_from_boc(message.payload),\n            ) for message in sign_raw_params.messages\n        ],\n        seqno=seqno,\n        valid_until=sign_raw_params.valid_until,\n    )\n    ext_message = wallet.create_external_msg(\n        dest=wallet.address,\n        body=tether_transfer_for_send,\n        state_init=wallet.state_init if seqno == 0 else None,\n    )\n\n    await tonapi.gasless.send(\n        body={\n            \"wallet_public_key\": public_key.hex(),\n            \"boc\": ext_message.serialize().to_boc().hex(),\n        }\n    )\n\n    print(f\"A gasless transfer sent!\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"ru/how-to/use-func-hash-functions/","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0445\u0435\u0448-\u0444\u0443\u043d\u043a\u0446\u0438\u0439 FunC","text":""},{"location":"ru/how-to/use-func-hash-functions/#cell_hash","title":"cell_hash","text":"<p>\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u0445\u0435\u0448 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u044f\u0447\u0435\u0439\u043a\u0438 <code>c</code> \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0435\u0433\u043e \u0432 \u0432\u0438\u0434\u0435 256-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u0431\u0435\u0437 \u0437\u043d\u0430\u043a\u043e\u0432\u043e\u0433\u043e \u0446\u0435\u043b\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 <code>x</code>. \u042d\u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u043b\u0435\u0437\u043d\u0430 \u0434\u043b\u044f \u043f\u043e\u0434\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043f\u043e\u0434\u043f\u0438\u0441\u0435\u0439 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u044b\u0445 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u0435\u0439, \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0445 \u0432 \u0432\u0438\u0434\u0435 \u0434\u0435\u0440\u0435\u0432\u0430 \u044f\u0447\u0435\u0435\u043a.</p> <pre><code>from tonutils.utils import cell_hash\nfrom pytoniq_core import begin_cell\n\n\ndef main() -&gt; None:\n    c = begin_cell().store_string(\"ness\").end_cell()\n    x = cell_hash(c)\n    print(x)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/how-to/use-func-hash-functions/#slice_hash","title":"slice_hash","text":"<p>\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u0445\u0435\u0448 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0441\u0440\u0435\u0437\u0430 <code>s</code> \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0435\u0433\u043e \u0432 \u0432\u0438\u0434\u0435 256-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u0431\u0435\u0437 \u0437\u043d\u0430\u043a\u043e\u0432\u043e\u0433\u043e \u0446\u0435\u043b\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 <code>x</code>. \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u044d\u043a\u0432\u0438\u0432\u0430\u043b\u0435\u043d\u0442\u0435\u043d \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044e \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0439 \u044f\u0447\u0435\u0439\u043a\u0438, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0439 \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0441\u0441\u044b\u043b\u043a\u0438 \u0438\u0437 <code>s</code>, \u0441 \u043f\u043e\u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435\u043c \u0435\u0451 \u0445\u0435\u0448\u0430 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e <code>cell_hash</code>.</p> <pre><code>from tonutils.utils import slice_hash\nfrom pytoniq_core import begin_cell\n\n\ndef main() -&gt; None:\n    s = begin_cell().store_string(\"ness\")\n    x = slice_hash(s)\n    print(x)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"ru/how-to/use-func-hash-functions/#string_hash","title":"string_hash","text":"<p>\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 SHA-256 \u0445\u0435\u0448 \u0431\u0438\u0442\u043e\u0432 \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c \u0441\u0440\u0435\u0437\u0435 <code>s</code>. \u0415\u0441\u043b\u0438 \u0434\u043b\u0438\u043d\u0430 <code>s</code> \u0432 \u0431\u0438\u0442\u0430\u0445 \u043d\u0435 \u043a\u0440\u0430\u0442\u043d\u0430 \u0432\u043e\u0441\u044c\u043c\u0438, \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u0435\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 cell underflow. \u0425\u0435\u0448 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044f \u0432 \u0432\u0438\u0434\u0435 256-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u0431\u0435\u0437\u0437\u043d\u0430\u043a\u043e\u0432\u043e\u0433\u043e \u0446\u0435\u043b\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 <code>x</code>.</p> <pre><code>from tonutils.utils import string_hash\n\n\ndef main() -&gt; None:\n    s = \"ness\"\n    x = string_hash(s)\n    print(x)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"}]}